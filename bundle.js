(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";function find(n,t,r){if("function"==typeof Array.prototype.find)return n.find(t,r);r=r||this;var f,i=n.length;if("function"!=typeof t)throw new TypeError(t+" is not a function");for(f=0;f<i;f++)if(t.call(r,n[f],f,n))return n[f]}module.exports=find;

},{}],2:[function(require,module,exports){
function belCreateElement(e,t,n){function a(e){if(Array.isArray(e))for(var t=0;t<e.length;t++){var n=e[t];if(Array.isArray(n))a(n);else{if(("number"==typeof n||"boolean"==typeof n||"function"==typeof n||n instanceof Date||n instanceof RegExp)&&(n=n.toString()),"string"==typeof n){if(o.lastChild&&"#text"===o.lastChild.nodeName){o.lastChild.nodeValue+=n;continue}n=document.createTextNode(n)}n&&n.nodeType&&o.appendChild(n)}}}var o;-1!==SVG_TAGS.indexOf(e)&&(t.namespace=SVGNS);var l=!1;if(t.namespace&&(l=t.namespace,delete t.namespace),l)o=document.createElementNS(l,e);else{if(e===COMMENT_TAG)return document.createComment(t.comment);o=document.createElement(e)}if(t.onload||t.onunload){var r=t.onload||function(){},i=t.onunload||function(){};onload(o,function(){r(o)},function(){i(o)},belCreateElement.caller.caller.caller),delete t.onload,delete t.onunload}for(var f in t)if(t.hasOwnProperty(f)){var c=f.toLowerCase(),s=t[f];if("classname"===c&&(c="class",f="class"),"htmlFor"===f&&(f="for"),BOOL_PROPS[c])if("true"===s)s=c;else if("false"===s)continue;"on"===c.slice(0,2)?o[f]=s:l?"xlink:href"===f?o.setAttributeNS(XLINKNS,f,s):/^xmlns($|:)/i.test(f)||o.setAttributeNS(null,f,s):o.setAttribute(f,s)}return a(n),o}var document=require("global/document"),hyperx=require("hyperx"),onload=require("on-load"),SVGNS="http://www.w3.org/2000/svg",XLINKNS="http://www.w3.org/1999/xlink",BOOL_PROPS={autofocus:1,checked:1,defaultchecked:1,disabled:1,formnovalidate:1,indeterminate:1,readonly:1,required:1,selected:1,willvalidate:1},COMMENT_TAG="!--",SVG_TAGS=["svg","altGlyph","altGlyphDef","altGlyphItem","animate","animateColor","animateMotion","animateTransform","circle","clipPath","color-profile","cursor","defs","desc","ellipse","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","filter","font","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignObject","g","glyph","glyphRef","hkern","image","line","linearGradient","marker","mask","metadata","missing-glyph","mpath","path","pattern","polygon","polyline","radialGradient","rect","set","stop","switch","symbol","text","textPath","title","tref","tspan","use","view","vkern"];module.exports=hyperx(belCreateElement,{comments:!0}),module.exports.default=module.exports,module.exports.createElement=belCreateElement;
},{"global/document":6,"hyperx":10,"on-load":17}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(e){if(cachedSetTimeout===setTimeout)return setTimeout(e,0);if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout)return cachedSetTimeout=setTimeout,setTimeout(e,0);try{return cachedSetTimeout(e,0)}catch(t){try{return cachedSetTimeout.call(null,e,0)}catch(t){return cachedSetTimeout.call(this,e,0)}}}function runClearTimeout(e){if(cachedClearTimeout===clearTimeout)return clearTimeout(e);if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout)return cachedClearTimeout=clearTimeout,clearTimeout(e);try{return cachedClearTimeout(e)}catch(t){try{return cachedClearTimeout.call(null,e)}catch(t){return cachedClearTimeout.call(this,e)}}}function cleanUpNextTick(){draining&&currentQueue&&(draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue())}function drainQueue(){if(!draining){var e=runTimeout(cleanUpNextTick);draining=!0;for(var t=queue.length;t;){for(currentQueue=queue,queue=[];++queueIndex<t;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,t=queue.length}currentQueue=null,draining=!1,runClearTimeout(e)}}function Item(e,t){this.fun=e,this.array=t}function noop(){}var process=module.exports={},cachedSetTimeout,cachedClearTimeout;!function(){try{cachedSetTimeout="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){cachedSetTimeout=defaultSetTimout}try{cachedClearTimeout="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){cachedClearTimeout=defaultClearTimeout}}();var queue=[],draining=!1,currentQueue,queueIndex=-1;process.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];queue.push(new Item(e,t)),1!==queue.length||draining||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.prependListener=noop,process.prependOnceListener=noop,process.listeners=function(e){return[]},process.binding=function(e){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(e){throw new Error("process.chdir is not supported")},process.umask=function(){return 0};
},{}],5:[function(require,module,exports){
module.exports=function(){for(var o=0;o<arguments.length;o++)if(void 0!==arguments[o])return arguments[o]};
},{}],6:[function(require,module,exports){
(function (global){
var topLevel="undefined"!=typeof global?global:"undefined"!=typeof window?window:{},minDoc=require("min-document"),doccy;"undefined"!=typeof document?doccy=document:(doccy=topLevel["__GLOBAL_DOCUMENT_CACHE@4"])||(doccy=topLevel["__GLOBAL_DOCUMENT_CACHE@4"]=minDoc),module.exports=doccy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"min-document":3}],7:[function(require,module,exports){
(function (global){
var win;win="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},module.exports=win;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],8:[function(require,module,exports){
module.exports=function(e,r){var l=r||"/";return 0===e.length?l:(e=e.replace("#",""),e=e.replace(/\/$/,""),0!=e.indexOf("/")&&(e="/"+e),"/"==l?e:e.replace(l,""))};
},{}],9:[function(require,module,exports){
function attributeToProperty(r){return function(t,o,e){for(var n in o)n in transform&&(o[transform[n]]=o[n],delete o[n]);return r(t,o,e)}}module.exports=attributeToProperty;var transform={class:"className",for:"htmlFor","http-equiv":"httpEquiv"};
},{}],10:[function(require,module,exports){
function quot(T){return T===ATTR_VALUE_SQ||T===ATTR_VALUE_DQ}function has(T,e){return hasOwn.call(T,e)}function selfClosing(T){return closeRE.test(T)}var attrToProp=require("hyperscript-attribute-to-property"),VAR=0,TEXT=1,OPEN=2,CLOSE=3,ATTR=4,ATTR_KEY=5,ATTR_KEY_W=6,ATTR_VALUE_W=7,ATTR_VALUE=8,ATTR_VALUE_SQ=9,ATTR_VALUE_DQ=10,ATTR_EQ=11,ATTR_BREAK=12,COMMENT=13;module.exports=function(T,e){function A(T){return"function"==typeof T?T:"string"==typeof T?T:T&&"object"==typeof T?T:t("",T)}e||(e={});var t=e.concat||function(T,e){return String(T)+String(e)};return!1!==e.attrToProp&&(T=attrToProp(T)),function(E){function n(T){var A=[];r===ATTR_VALUE_W&&(r=ATTR);for(var t=0;t<T.length;t++){var E=T.charAt(t);r===TEXT&&"<"===E?(R.length&&A.push([TEXT,R]),R="",r=OPEN):">"!==E||quot(r)||r===COMMENT?r===COMMENT&&/-$/.test(R)&&"-"===E?(e.comments&&A.push([ATTR_VALUE,R.substr(0,R.length-1)],[CLOSE]),R="",r=TEXT):r===OPEN&&/^!--$/.test(R)?(e.comments&&A.push([OPEN,R],[ATTR_KEY,"comment"],[ATTR_EQ]),R=E,r=COMMENT):r===TEXT||r===COMMENT?R+=E:r===OPEN&&/\s/.test(E)?(A.push([OPEN,R]),R="",r=ATTR):r===OPEN?R+=E:r===ATTR&&/[^\s"'=\/]/.test(E)?(r=ATTR_KEY,R=E):r===ATTR&&/\s/.test(E)?(R.length&&A.push([ATTR_KEY,R]),A.push([ATTR_BREAK])):r===ATTR_KEY&&/\s/.test(E)?(A.push([ATTR_KEY,R]),R="",r=ATTR_KEY_W):r===ATTR_KEY&&"="===E?(A.push([ATTR_KEY,R],[ATTR_EQ]),R="",r=ATTR_VALUE_W):r===ATTR_KEY?R+=E:r!==ATTR_KEY_W&&r!==ATTR||"="!==E?r!==ATTR_KEY_W&&r!==ATTR||/\s/.test(E)?r===ATTR_VALUE_W&&'"'===E?r=ATTR_VALUE_DQ:r===ATTR_VALUE_W&&"'"===E?r=ATTR_VALUE_SQ:r===ATTR_VALUE_DQ&&'"'===E?(A.push([ATTR_VALUE,R],[ATTR_BREAK]),R="",r=ATTR):r===ATTR_VALUE_SQ&&"'"===E?(A.push([ATTR_VALUE,R],[ATTR_BREAK]),R="",r=ATTR):r!==ATTR_VALUE_W||/\s/.test(E)?r===ATTR_VALUE&&/\s/.test(E)?(A.push([ATTR_VALUE,R],[ATTR_BREAK]),R="",r=ATTR):r!==ATTR_VALUE&&r!==ATTR_VALUE_SQ&&r!==ATTR_VALUE_DQ||(R+=E):(r=ATTR_VALUE,t--):(A.push([ATTR_BREAK]),/[\w-]/.test(E)?(R+=E,r=ATTR_KEY):r=ATTR):(A.push([ATTR_EQ]),r=ATTR_VALUE_W):(r===OPEN?A.push([OPEN,R]):r===ATTR_KEY?A.push([ATTR_KEY,R]):r===ATTR_VALUE&&R.length&&A.push([ATTR_VALUE,R]),A.push([CLOSE]),R="",r=TEXT)}return r===TEXT&&R.length?(A.push([TEXT,R]),R=""):r===ATTR_VALUE&&R.length?(A.push([ATTR_VALUE,R]),R=""):r===ATTR_VALUE_DQ&&R.length?(A.push([ATTR_VALUE,R]),R=""):r===ATTR_VALUE_SQ&&R.length?(A.push([ATTR_VALUE,R]),R=""):r===ATTR_KEY&&(A.push([ATTR_KEY,R]),R=""),A}for(var r=TEXT,R="",s=arguments.length,_=[],o=0;o<E.length;o++)if(o<s-1){var l=arguments[o+1],h=n(E[o]),i=r;i===ATTR_VALUE_DQ&&(i=ATTR_VALUE),i===ATTR_VALUE_SQ&&(i=ATTR_VALUE),i===ATTR_VALUE_W&&(i=ATTR_VALUE),i===ATTR&&(i=ATTR_KEY),h.push([VAR,i,l]),_.push.apply(_,h)}else _.push.apply(_,n(E[o]));for(var f=[null,{},[]],p=[[f,-1]],o=0;o<_.length;o++){var a=p[p.length-1][0],h=_[o],u=h[0];if(u===OPEN&&/^\//.test(h[1])){var g=p[p.length-1][1];p.length>1&&(p.pop(),p[p.length-1][0][2][g]=T(a[0],a[1],a[2].length?a[2]:void 0))}else if(u===OPEN){var L=[h[1],{},[]];a[2].push(L),p.push([L,a[2].length-1])}else if(u===ATTR_KEY||u===VAR&&h[1]===ATTR_KEY){for(var V,c="";o<_.length;o++)if(_[o][0]===ATTR_KEY)c=t(c,_[o][1]);else{if(_[o][0]!==VAR||_[o][1]!==ATTR_KEY)break;if("object"!=typeof _[o][2]||c)c=t(c,_[o][2]);else for(V in _[o][2])_[o][2].hasOwnProperty(V)&&!a[1][V]&&(a[1][V]=_[o][2][V])}_[o][0]===ATTR_EQ&&o++;for(var U=o;o<_.length;o++)if(_[o][0]===ATTR_VALUE||_[o][0]===ATTR_KEY)a[1][c]?a[1][c]=t(a[1][c],_[o][1]):a[1][c]=A(_[o][1]);else{if(_[o][0]!==VAR||_[o][1]!==ATTR_VALUE&&_[o][1]!==ATTR_KEY){!c.length||a[1][c]||o!==U||_[o][0]!==CLOSE&&_[o][0]!==ATTR_BREAK||(a[1][c]=c.toLowerCase());break}a[1][c]?a[1][c]=t(a[1][c],_[o][2]):a[1][c]=A(_[o][2])}}else if(u===ATTR_KEY)a[1][h[1]]=!0;else if(u===VAR&&h[1]===ATTR_KEY)a[1][h[2]]=!0;else if(u===CLOSE){if(selfClosing(a[0])&&p.length){var g=p[p.length-1][1];p.pop(),p[p.length-1][0][2][g]=T(a[0],a[1],a[2].length?a[2]:void 0)}}else if(u===VAR&&h[1]===TEXT)void 0===h[2]||null===h[2]?h[2]="":h[2]||(h[2]=t("",h[2])),Array.isArray(h[2][0])?a[2].push.apply(a[2],h[2]):a[2].push(h[2]);else if(u===TEXT)a[2].push(h[1]);else if(u!==ATTR_EQ&&u!==ATTR_BREAK)throw new Error("unhandled: "+u)}if(f[2].length>1&&/^\s*$/.test(f[2][0])&&f[2].shift(),f[2].length>2||2===f[2].length&&/\S/.test(f[2][1]))throw new Error("multiple root elements must be wrapped in an enclosing tag");return Array.isArray(f[2][0])&&"string"==typeof f[2][0][0]&&Array.isArray(f[2][0][2])&&(f[2][0]=T(f[2][0][0],f[2][0][1],f[2][0][2])),f[2][0]}};var hasOwn=Object.prototype.hasOwnProperty,closeRE=RegExp("^("+["area","base","basefont","bgsound","br","col","command","embed","frame","hr","img","input","isindex","keygen","link","meta","param","source","track","wbr","!--","animate","animateTransform","circle","cursor","desc","ellipse","feBlend","feColorMatrix","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","font-face-format","font-face-name","font-face-uri","glyph","glyphRef","hkern","image","line","missing-glyph","mpath","path","polygon","polyline","rect","set","stop","tref","use","view","vkern"].join("|")+")(?:[.#][a-zA-Z0-9-￿_:-]+)*$");
},{"hyperscript-attribute-to-property":9}],11:[function(require,module,exports){
function insertCss(e,t){t=t||{};var s=!0===t.prepend?"prepend":"append",n=void 0!==t.container?t.container:document.querySelector("head"),r=containers.indexOf(n);-1===r&&(r=containers.push(n)-1,styleElements[r]={});var l;return void 0!==styleElements[r]&&void 0!==styleElements[r][s]?l=styleElements[r][s]:(l=styleElements[r][s]=createStyleElement(),"prepend"===s?n.insertBefore(l,n.childNodes[0]):n.appendChild(l)),65279===e.charCodeAt(0)&&(e=e.substr(1,e.length)),l.styleSheet?l.styleSheet.cssText+=e:l.textContent+=e,l}function createStyleElement(){var e=document.createElement("style");return e.setAttribute("type","text/css"),e}var containers=[],styleElements=[];module.exports=insertCss,module.exports.insertCss=insertCss;

},{}],12:[function(require,module,exports){
module.exports=require("yo-yo");

},{"yo-yo":51}],13:[function(require,module,exports){
module.exports={start:require("./start"),pull:require("./pull"),html:require("./html")};
},{"./html":12,"./pull":14,"./start":15}],14:[function(require,module,exports){
module.exports=require("pull-stream");

},{"pull-stream":20}],15:[function(require,module,exports){
(function (process){
function start(n){function l(n){f(n)}function t(){[f,a,p,d,c,s].forEach(function(n){n.end()})}n=defined(n,{});var e=defined(n.init,defaultInit),i=defined(n.update,defaultUpdate),u=defined(n.view,noop),r=defined(n.run,noop),f=notify(),o=e.call(n),a=notify();pull(f.listen(),scan(o,function(l,t){return i.call(n,l.model,t)}),pull.drain(a));var p=notify();pull(a.listen(),pull.map(function(n){return n.model}),difference(),pull.drain(p));var d=notify();pull(p.listen(),pull.map(function(t){return u.call(n,t,l)}),pull.filter(isNotNil),pull.drain(d));var c=notify();pull(a.listen(),pull.map(function(n){return n.effect}),pull.filter(isNotNil),pull.drain(c));var s=notify();return pull(c.listen(),pull.map(function(l){return r.call(n,l,f.listen)}),pull.filter(isNotNil),pull.drain(s)),pull(s.listen(),drainMany(f)),process.nextTick(function(){a(o)}),{stop:t,actions:f.listen,states:a.listen,models:p.listen,views:d.listen,effects:c.listen,effectActionStreams:s.listen}}function noop(){}function isNotNil(n){return null!=n}function defaultInit(){return{model:null}}function defaultUpdate(n){return{model:n}}function scan(n,l){return pull.map(function(t){return n=l(n,t)})}function difference(){var n;return pull.filter(function(l){var t=l!==n;return n=l,t})}function drainMany(n){return function(l){pull(l,pull.drain(function(l){pull(l,pull.drain(n))}))}}var defined=require("defined"),pull=require("pull-stream"),notify=require("pull-notify");module.exports=start;
}).call(this,require('_process'))
},{"_process":4,"defined":5,"pull-notify":18,"pull-stream":20}],16:[function(require,module,exports){
"use strict";function toElement(e){!range&&doc.createRange&&(range=doc.createRange(),range.selectNode(doc.body));var t;return range&&range.createContextualFragment?t=range.createContextualFragment(e):(t=doc.createElement("body"),t.innerHTML=e),t.childNodes[0]}function compareNodeNames(e,t){var n=e.nodeName,o=t.nodeName;return n===o||!!(t.actualize&&n.charCodeAt(0)<91&&o.charCodeAt(0)>90)&&n===o.toUpperCase()}function createElementNS(e,t){return t&&t!==NS_XHTML?doc.createElementNS(t,e):doc.createElement(e)}function moveChildren(e,t){for(var n=e.firstChild;n;){var o=n.nextSibling;t.appendChild(n),n=o}return t}function morphAttrs(e,t){var n,o,r,a,i,d=t.attributes;for(n=d.length-1;n>=0;--n)o=d[n],r=o.name,a=o.namespaceURI,i=o.value,a?(r=o.localName||r,e.getAttributeNS(a,r)!==i&&e.setAttributeNS(a,r,i)):e.getAttribute(r)!==i&&e.setAttribute(r,i);for(d=e.attributes,n=d.length-1;n>=0;--n)o=d[n],!1!==o.specified&&(r=o.name,a=o.namespaceURI,a?(r=o.localName||r,hasAttributeNS(t,a,r)||e.removeAttributeNS(a,r)):hasAttributeNS(t,null,r)||e.removeAttribute(r))}function syncBooleanAttrProp(e,t,n){e[n]!==t[n]&&(e[n]=t[n],e[n]?e.setAttribute(n,""):e.removeAttribute(n,""))}function noop(){}function defaultGetNodeKey(e){return e.id}function morphdomFactory(e){return function(t,n,o){function r(e){N?N.push(e):N=[e]}function a(e,t){if(e.nodeType===ELEMENT_NODE)for(var n=e.firstChild;n;){var o=void 0;t&&(o=f(n))?r(o):(h(n),n.firstChild&&a(n,t)),n=n.nextSibling}}function i(e,t,n){!1!==v(e)&&(t&&t.removeChild(e),h(e),a(e,n))}function d(e){if(e.nodeType===ELEMENT_NODE)for(var t=e.firstChild;t;){var n=f(t);n&&(S[n]=t),d(t),t=t.nextSibling}}function l(e){m(e);for(var t=e.firstChild;t;){var n=t.nextSibling,o=f(t);if(o){var r=S[o];r&&compareNodeNames(t,r)&&(t.parentNode.replaceChild(r,t),u(r,t))}l(t),t=n}}function u(o,a,d){var c,N=f(a);if(N&&delete S[N],!n.isSameNode||!n.isSameNode(t)){if(!d){if(!1===p(o,a))return;if(e(o,a),E(o),!1===b(o,a))return}if("TEXTAREA"!==o.nodeName){var m,v,h,A,T=a.firstChild,g=o.firstChild;e:for(;T;){for(h=T.nextSibling,m=f(T);g;){if(v=g.nextSibling,T.isSameNode&&T.isSameNode(g)){T=h,g=v;continue e}c=f(g);var C=g.nodeType,y=void 0;if(C===T.nodeType&&(C===ELEMENT_NODE?(m?m!==c&&((A=S[m])?g.nextSibling===A?y=!1:(o.insertBefore(A,g),v=g.nextSibling,c?r(c):i(g,o,!0),g=A):y=!1):c&&(y=!1),(y=!1!==y&&compareNodeNames(g,T))&&u(g,T)):C!==TEXT_NODE&&C!=COMMENT_NODE||(y=!0,g.nodeValue!==T.nodeValue&&(g.nodeValue=T.nodeValue))),y){T=h,g=v;continue e}c?r(c):i(g,o,!0),g=v}if(m&&(A=S[m])&&compareNodeNames(A,T))o.appendChild(A),u(A,T);else{var O=s(T);!1!==O&&(O&&(T=O),T.actualize&&(T=T.actualize(o.ownerDocument||doc)),o.appendChild(T),l(T))}T=h,g=v}for(;g;)v=g.nextSibling,(c=f(g))?r(c):i(g,o,!0),g=v}var M=specialElHandlers[o.nodeName];M&&M(o,a)}}if(o||(o={}),"string"==typeof n)if("#document"===t.nodeName||"HTML"===t.nodeName){var c=n;n=doc.createElement("html"),n.innerHTML=c}else n=toElement(n);var N,f=o.getNodeKey||defaultGetNodeKey,s=o.onBeforeNodeAdded||noop,m=o.onNodeAdded||noop,p=o.onBeforeElUpdated||noop,E=o.onElUpdated||noop,v=o.onBeforeNodeDiscarded||noop,h=o.onNodeDiscarded||noop,b=o.onBeforeElChildrenUpdated||noop,A=!0===o.childrenOnly,S={};d(t);var T=t,g=T.nodeType,C=n.nodeType;if(!A)if(g===ELEMENT_NODE)C===ELEMENT_NODE?compareNodeNames(t,n)||(h(t),T=moveChildren(t,createElementNS(n.nodeName,n.namespaceURI))):T=n;else if(g===TEXT_NODE||g===COMMENT_NODE){if(C===g)return T.nodeValue!==n.nodeValue&&(T.nodeValue=n.nodeValue),T;T=n}if(T===n)h(t);else if(u(T,n,A),N)for(var y=0,O=N.length;y<O;y++){var M=S[N[y]];M&&i(M,M.parentNode,!1)}return!A&&T!==t&&t.parentNode&&(T.actualize&&(T=T.actualize(t.ownerDocument||doc)),t.parentNode.replaceChild(T,t)),T}}var range,NS_XHTML="http://www.w3.org/1999/xhtml",doc="undefined"==typeof document?void 0:document,testEl=doc?doc.body||doc.createElement("div"):{},actualHasAttributeNS;actualHasAttributeNS=testEl.hasAttributeNS?function(e,t,n){return e.hasAttributeNS(t,n)}:testEl.hasAttribute?function(e,t,n){return e.hasAttribute(n)}:function(e,t,n){return null!=e.getAttributeNode(t,n)};var hasAttributeNS=actualHasAttributeNS,specialElHandlers={OPTION:function(e,t){syncBooleanAttrProp(e,t,"selected")},INPUT:function(e,t){syncBooleanAttrProp(e,t,"checked"),syncBooleanAttrProp(e,t,"disabled"),e.value!==t.value&&(e.value=t.value),hasAttributeNS(t,null,"value")||e.removeAttribute("value")},TEXTAREA:function(e,t){var n=t.value;e.value!==n&&(e.value=n);var o=e.firstChild;if(o){var r=o.nodeValue;if(r==n||!n&&r==e.placeholder)return;o.nodeValue=n}},SELECT:function(e,t){if(!hasAttributeNS(t,null,"multiple")){for(var n=0,o=t.firstChild;o;){var r=o.nodeName;if(r&&"OPTION"===r.toUpperCase()){if(hasAttributeNS(o,null,"selected")){n;break}n++}o=o.nextSibling}e.selectedIndex=n}}},ELEMENT_NODE=1,TEXT_NODE=3,COMMENT_NODE=8,morphdom=morphdomFactory(morphAttrs);module.exports=morphdom;

},{}],17:[function(require,module,exports){
function turnon(t,e){watch[t][0]&&0===watch[t][2]&&(watch[t][0](e),watch[t][2]=1)}function turnoff(t,e){watch[t][1]&&1===watch[t][2]&&(watch[t][1](e),watch[t][2]=0)}function eachAttr(t,e,a){var r=t.target.getAttribute(KEY_ATTR);if(sameOrigin(t.oldValue,r))return void(watch[r]=watch[t.oldValue]);watch[t.oldValue]&&a(t.oldValue,t.target),watch[r]&&e(r,t.target)}function sameOrigin(t,e){return!(!t||!e)&&watch[t][3]===watch[e][3]}function eachMutation(t,e){for(var a=Object.keys(watch),r=0;r<t.length;r++){if(t[r]&&t[r].getAttribute&&t[r].getAttribute(KEY_ATTR)){var n=t[r].getAttribute(KEY_ATTR);a.forEach(function(a){n===a&&e(a,t[r])})}t[r].childNodes.length>0&&eachMutation(t[r].childNodes,e)}}var document=require("global/document"),window=require("global/window"),watch=Object.create(null),KEY_ID="onloadid"+(new Date%9e6).toString(36),KEY_ATTR="data-"+KEY_ID,INDEX=0;if(window&&window.MutationObserver){var observer=new MutationObserver(function(t){if(!(Object.keys(watch).length<1))for(var e=0;e<t.length;e++)t[e].attributeName!==KEY_ATTR?(eachMutation(t[e].removedNodes,turnoff),eachMutation(t[e].addedNodes,turnon)):eachAttr(t[e],turnon,turnoff)});observer.observe(document.body,{childList:!0,subtree:!0,attributes:!0,attributeOldValue:!0,attributeFilter:[KEY_ATTR]})}module.exports=function t(e,a,r,n){return a=a||function(){},r=r||function(){},e.setAttribute(KEY_ATTR,"o"+INDEX),watch["o"+INDEX]=[a,r,0,n||t.caller],INDEX+=1,e};

},{"global/document":6,"global/window":7}],18:[function(require,module,exports){
var pushable=require("pull-pushable");module.exports=function(){function n(n){for(var e=0;e<r.length;e++)r[e].push(n);return n}var r=[];return n.listen=function(){var n=pushable(function(){var e=r.indexOf(n);-1!==e&&r.splice(e,1)});return r.push(n),n},n.abort=function(n){for(;r.length;)r[0].end(n)},n.end=function(){return n.abort(!0)},n};

},{"pull-pushable":19}],19:[function(require,module,exports){
function pullPushable(n,u){function l(n,u){n&&(o=n,r&&i(o)),r=u,f()}function t(n){c=c||n||!0,f()}function e(n){if(!c){if(r)return void i(o,n);h.push(n),f()}}function f(){r&&(o?i(o):!h.length&&c?i(c):h.length&&i(null,h.shift()))}function i(n,l){var t=r;if(n&&u){var e=u;u=null,e(!0===n?null:n)}r=null,t(n,l)}"function"==typeof n&&(u=n,n=!1);var o,r,c,h=[];return n?{push:e,end:t,source:l}:(l.push=e,l.end=t,l)}module.exports=pullPushable;

},{}],20:[function(require,module,exports){
"use strict";var sources=require("./sources"),sinks=require("./sinks"),throughs=require("./throughs");exports=module.exports=require("./pull"),exports.pull=exports;for(var k in sources)exports[k]=sources[k];for(var k in throughs)exports[k]=throughs[k];for(var k in sinks)exports[k]=sinks[k];

},{"./pull":21,"./sinks":26,"./sources":33,"./throughs":42}],21:[function(require,module,exports){
"use strict";module.exports=function r(e){var n=arguments.length;if("function"==typeof e&&1===e.length){for(var t=new Array(n),u=0;u<n;u++)t[u]=arguments[u];return function(e){if(null==t)throw new TypeError("partial sink should only be called once!");var u=t;switch(t=null,n){case 1:return r(e,u[0]);case 2:return r(e,u[0],u[1]);case 3:return r(e,u[0],u[1],u[2]);case 4:return r(e,u[0],u[1],u[2],u[3]);default:return u.unshift(e),r.apply(null,u)}}}var o=e;o&&"function"==typeof o.source&&(o=o.source);for(var u=1;u<n;u++){var c=arguments[u];"function"==typeof c?o=c(o):c&&"object"==typeof c&&(c.sink(o),o=c.source)}return o};
},{}],22:[function(require,module,exports){
"use strict";var reduce=require("./reduce");module.exports=function(e){return reduce(function(e,r){return e.push(r),e},[],e)};

},{"./reduce":29}],23:[function(require,module,exports){
"use strict";var reduce=require("./reduce");module.exports=function(e){return reduce(function(e,r){return e+r},"",e)};

},{"./reduce":29}],24:[function(require,module,exports){
"use strict";module.exports=function(n,t){function f(r){if(i=r,o)return f.abort();!function f(){for(var r=!0,u=!1;r;)if(u=!1,i(null,function(e,c){if(u=!0,e=e||o){if(r=!1,t)t(!0===e?null:e);else if(e&&!0!==e)throw e}else n&&!1===n(c)||o?(r=!1,i(o||!0,t||function(){})):r||f()}),!u)return void(r=!1)}()}var i,o;return f.abort=function(n,t){if("function"==typeof n&&(t=n,n=!0),o=n||!0,i)return i(o,t||function(){})},f};

},{}],25:[function(require,module,exports){
"use strict";function id(r){return r}var prop=require("../util/prop"),drain=require("./drain");module.exports=function(r,n){var i=!1;return n?r=prop(r)||id:(n=r,r=id),drain(function(u){if(r(u))return i=!0,n(null,u),!1},function(r){i||n(!0===r?null:r,null)})};

},{"../util/prop":49,"./drain":24}],26:[function(require,module,exports){
"use strict";module.exports={drain:require("./drain"),onEnd:require("./on-end"),log:require("./log"),find:require("./find"),reduce:require("./reduce"),collect:require("./collect"),concat:require("./concat")};

},{"./collect":22,"./concat":23,"./drain":24,"./find":25,"./log":27,"./on-end":28,"./reduce":29}],27:[function(require,module,exports){
"use strict";var drain=require("./drain");module.exports=function(r){return drain(function(r){console.log(r)},r)};

},{"./drain":24}],28:[function(require,module,exports){
"use strict";var drain=require("./drain");module.exports=function(r){return drain(null,r)};

},{"./drain":24}],29:[function(require,module,exports){
"use strict";var drain=require("./drain");module.exports=function(n,r,u){u||(u=r,r=null);var i=drain(function(u){r=n(r,u)},function(n){u(n,r)});return 2===arguments.length?function(n){n(null,function(t,e){if(t)return u(!0===t?null:t);r=e,i(n)})}:i};

},{"./drain":24}],30:[function(require,module,exports){
"use strict";module.exports=function(n){var r=0;return n=n||1/0,function(t,u){return t?u&&u(t):r>n?u(!0):void u(null,r++)}};

},{}],31:[function(require,module,exports){
"use strict";module.exports=function(){return function(t,n){n(!0)}};

},{}],32:[function(require,module,exports){
"use strict";module.exports=function(t){return function(n,u){u(t)}};

},{}],33:[function(require,module,exports){
"use strict";module.exports={keys:require("./keys"),once:require("./once"),values:require("./values"),count:require("./count"),infinite:require("./infinite"),empty:require("./empty"),error:require("./error")};

},{"./count":30,"./empty":31,"./error":32,"./infinite":34,"./keys":35,"./once":36,"./values":37}],34:[function(require,module,exports){
"use strict";module.exports=function(n){return n=n||Math.random,function(t,r){return t?r&&r(t):r(null,n())}};

},{}],35:[function(require,module,exports){
"use strict";var values=require("./values");module.exports=function(e){return values(Object.keys(e))};
},{"./values":37}],36:[function(require,module,exports){
"use strict";var abortCb=require("../util/abort-cb");module.exports=function(r,t){return function(u,e){if(u)return abortCb(e,u,t);if(null!=r){var l=r;r=null,e(null,l)}else e(!0)}};

},{"../util/abort-cb":48}],37:[function(require,module,exports){
"use strict";var abortCb=require("../util/abort-cb");module.exports=function(r,t){if(!r)return function(r,n){return r?abortCb(n,r,t):n(!0)};Array.isArray(r)||(r=Object.keys(r).map(function(t){return r[t]}));var n=0;return function(u,e){if(u)return abortCb(e,u,t);n>=r.length?e(!0):e(null,r[n++])}};

},{"../util/abort-cb":48}],38:[function(require,module,exports){
"use strict";function id(n){return n}var prop=require("../util/prop");module.exports=function(n){if(!n)return id;n=prop(n);var r,u,t=!1;return function(i){return function o(e,f){if(u)return f(u);e?(u=e,t?i(e,function(){t?r=f:f(e)}):i(e,f)):i(null,function(i,e){i?f(i):u?f(u):(t=!0,n(e,function(n,i){t=!1,u?(f(u),r(u)):n?o(n,f):f(null,i)}))})}}};

},{"../util/prop":49}],39:[function(require,module,exports){
"use strict";var tester=require("../util/tester"),filter=require("./filter");module.exports=function(e){return e=tester(e),filter(function(r){return!e(r)})};

},{"../util/tester":50,"./filter":40}],40:[function(require,module,exports){
"use strict";var tester=require("../util/tester");module.exports=function(t){return t=tester(t),function(r){return function e(n,u){for(var i,o=!0;o;)o=!1,i=!0,r(n,function(r,n){if(!r&&!t(n))return i?o=!0:e(r,u);u(r,n)}),i=!1}}};

},{"../util/tester":50}],41:[function(require,module,exports){
"use strict";var values=require("../sources/values"),once=require("../sources/once");module.exports=function(){return function(n){var u;return function(e,o){function r(){u(null,function(u,e){!0===u?t():u?n(!0,function(n){o(u)}):o(null,e)})}function t(){u=null,n(null,function(n,e){if(n)return o(n);Array.isArray(e)||e&&"object"==typeof e?e=values(e):"function"!=typeof e&&(e=once(e)),u=e,r()})}e?u?u(e,function(u){n(u||e,o)}):n(e,o):u?r():t()}}};

},{"../sources/once":36,"../sources/values":37}],42:[function(require,module,exports){
"use strict";module.exports={map:require("./map"),asyncMap:require("./async-map"),filter:require("./filter"),filterNot:require("./filter-not"),through:require("./through"),take:require("./take"),unique:require("./unique"),nonUnique:require("./non-unique"),flatten:require("./flatten")};

},{"./async-map":38,"./filter":40,"./filter-not":39,"./flatten":41,"./map":43,"./non-unique":44,"./take":45,"./through":46,"./unique":47}],43:[function(require,module,exports){
"use strict";function id(r){return r}var prop=require("../util/prop");module.exports=function(r){return r?(r=prop(r),function(n){return function(t,u){n(t,function(t,i){try{i=t?null:r(i)}catch(r){return n(r,function(){return u(r)})}u(t,i)})}}):id};

},{"../util/prop":49}],44:[function(require,module,exports){
"use strict";var unique=require("./unique");module.exports=function(u){return unique(u,!0)};

},{"./unique":47}],45:[function(require,module,exports){
"use strict";module.exports=function(n,u){u=u||{};var t=u.last||!1,r=!1;if("number"==typeof n){t=!0;var o=n;n=function(){return--o}}return function(u){function o(n){u(!0,function(u){t=!1,n(u||!0)})}return function(f,i){r?t?o(i):i(r):(r=f)?u(r,i):u(null,function(u,f){(r=r||u)?i(r):n(f)?i(null,f):(r=!0,t?i(null,f):o(i))})}}};

},{}],46:[function(require,module,exports){
"use strict";module.exports=function(n,t){function u(n){!r&&t&&(r=!0,t(!0===n?null:n))}var r=!1;return function(t){return function(r,o){return r&&u(r),t(r,function(t,r){t?u(t):n&&n(r),o(t,r)})}}};

},{}],47:[function(require,module,exports){
"use strict";function id(r){return r}var prop=require("../util/prop"),filter=require("./filter");module.exports=function(r,e){r=prop(r)||id;var t={};return filter(function(i){var u=r(i);return t[u]?!!e:(t[u]=!0,!e)})};

},{"../util/prop":49,"./filter":40}],48:[function(require,module,exports){
module.exports=function(l,n,o){l(n),o&&o(!0===n?null:n)};
},{}],49:[function(require,module,exports){
module.exports=function(e){return e&&("string"==typeof e?function(t){return t[e]}:"object"==typeof e&&"function"==typeof e.exec?function(t){var n=e.exec(t);return n&&n[0]}:e)};

},{}],50:[function(require,module,exports){
function id(t){return t}var prop=require("./prop");module.exports=function(t){return"object"==typeof t&&"function"==typeof t.test?function(r){return t.test(r)}:prop(t)||id};

},{"./prop":49}],51:[function(require,module,exports){
var bel=require("bel"),morphdom=require("morphdom"),defaultEvents=require("./update-events.js");module.exports=bel,module.exports.update=function(e,t,u){function a(e,t){for(var a=u.events||defaultEvents,l=0;l<a.length;l++){var r=a[l];t[r]?e[r]=t[r]:e[r]&&(e[r]=void 0)}var o=e.value,v=t.value;"INPUT"===e.nodeName&&"file"!==e.type||"SELECT"===e.nodeName?v||t.hasAttribute("value")?v!==o&&(e.value=v):t.value=e.value:"TEXTAREA"===e.nodeName&&null===t.getAttribute("value")&&(e.value=t.value)}return u||(u={}),!1!==u.events&&(u.onBeforeElUpdated||(u.onBeforeElUpdated=a)),morphdom(e,t,u)};

},{"./update-events.js":52,"bel":2,"morphdom":16}],52:[function(require,module,exports){
module.exports=["onclick","ondblclick","onmousedown","onmouseup","onmouseover","onmousemove","onmouseout","ondragstart","ondrag","ondragenter","ondragleave","ondragover","ondrop","ondragend","onkeydown","onkeypress","onkeyup","onunload","onabort","onerror","onresize","onscroll","onselect","onchange","onsubmit","onreset","onfocus","onblur","oninput","oncontextmenu","onfocusin","onfocusout"];
},{}],53:[function(require,module,exports){
function formatHash(e){return hashMatch(e).slice(1)||null}var hashMatch=require("hash-match"),Pushable=require("pull-pushable");module.exports={init:function(){return{model:formatHash(window.location.hash),effect:{type:"router:init"}}},update:function(e,t){switch(t.type){case"router:set":return{model:t.payload};default:return{model:e}}},run:function(e,t){if("router:init"===e.type){var n,r=function(){n.push({type:"router:set",payload:formatHash(window.location.hash)})};return n=Pushable(function(e){window.removeEventListener(r)}),window.addEventListener("hashchange",r),n}}};
},{"hash-match":8,"pull-pushable":19}],54:[function(require,module,exports){
function _taggedTemplateLiteral(e,n){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function contributorsList(e){return html(_templateObject,"contrib "+prefix,e.slice(0,20).sort(shuffle).map(function(e){return html(_templateObject2,e.name,"https://github.com/"+e.name,e.image)}))}function shuffle(){return Math.random()-.5}var _templateObject=_taggedTemplateLiteral(["\n    <div class=",">\n      <ul>\n        ","\n      </ul>\n    </div>\n  "],["\n    <div class=",">\n      <ul>\n        ","\n      </ul>\n    </div>\n  "]),_templateObject2=_taggedTemplateLiteral(["\n          <li>\n            <a target='_blank' title="," href=",">\n              <img src="," />\n            </a>\n          </li>\n        "],["\n          <li>\n            <a target='_blank' title="," href=",">\n              <img src="," />\n            </a>\n          </li>\n        "]),html=require("inu/html"),css=0,prefix=(null||!0)&&"_c8360755";module.exports=contributorsList;

},{"insert-css":11,"inu/html":12}],55:[function(require,module,exports){
function modulePage(n){var l=document.createElement("article");l.innerHTML=n.readme;var e=l.querySelector(".title"),o=e.querySelector(".contrib");return e.replaceChild(contribList(n.contributors),o),l}var css=0,contribList=require("./contributor-list");null,module.exports=modulePage;

},{"./contributor-list":54,"insert-css":11}],56:[function(require,module,exports){
function _taggedTemplateLiteral(e,n){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function nav(e){return html(_templateObject,e.categories.map(function(n){return html(_templateObject2,n,e.modules.filter(function(e){return e.category===n}).map(function(e){return html(_templateObject3,"#"+e.name,e.name)}))}))}var _templateObject=_taggedTemplateLiteral(["\n    <nav>\n      <a class='logo' href='/'>\n        <h1>pull-stream</h1>\n      </a>\n      <ul class='categories'>\n        ","\n      </ul>\n    </nav>\n  "],["\n    <nav>\n      <a class='logo' href='/'>\n        <h1>pull-stream</h1>\n      </a>\n      <ul class='categories'>\n        ","\n      </ul>\n    </nav>\n  "]),_templateObject2=_taggedTemplateLiteral(["\n          <li class='category'>\n            <h2>","</h2>\n            <ul class='modules'>\n              ","\n            </ul>\n          </li>\n        "],["\n          <li class='category'>\n            <h2>","</h2>\n            <ul class='modules'>\n              ","\n            </ul>\n          </li>\n        "]),_templateObject3=_taggedTemplateLiteral(["\n                    <a href=",">\n                      <li>","</li>\n                    </a>\n                  "],["\n                    <a href=",">\n                      <li>","</li>\n                    </a>\n                  "]),html=require("inu").html;module.exports=nav;

},{"inu":13}],57:[function(require,module,exports){
function _taggedTemplateLiteral(s,a){return Object.freeze(Object.defineProperties(s,{raw:{value:Object.freeze(a)}}))}function deIndexContributors(s,a){return a.map(function(a){return s[a]})}var _templateObject=_taggedTemplateLiteral(["\n      <main class=",">\n        ","\n        ","\n      </main>\n    "],["\n      <main class=",">\n        ","\n        ","\n      </main>\n    "]),inu=require("inu"),pull=inu.pull,find=require("array-find"),css=0;null
;var model=JSON.parse('{"contributors":[{"name":"dominictarr","image":"https://avatars3.githubusercontent.com/u/259374?v=4"},{"name":"regular","image":"https://avatars0.githubusercontent.com/u/122962?v=4"},{"name":"0x00A","image":"https://avatars2.githubusercontent.com/u/136109?v=4"},{"name":"ahdinosaur","image":"https://avatars0.githubusercontent.com/u/719605?v=4"},{"name":"timoxley","image":"https://avatars1.githubusercontent.com/u/43438?v=4"},{"name":"tjconcept","image":"https://avatars2.githubusercontent.com/u/801895?v=4"},{"name":"nichoth","image":"https://avatars0.githubusercontent.com/u/5776508?v=4"},{"name":"yoshuawuyts","image":"https://avatars3.githubusercontent.com/u/2467194?v=4"},{"name":"anko","image":"https://avatars3.githubusercontent.com/u/5231746?v=4"},{"name":"zetxx","image":"https://avatars0.githubusercontent.com/u/704384?v=4"},{"name":"jamen","image":"https://avatars2.githubusercontent.com/u/6251703?v=4"},{"name":"joliss","image":"https://avatars0.githubusercontent.com/u/524783?v=4"},{"name":"dignifiedquire","image":"https://avatars0.githubusercontent.com/u/790842?v=4"},{"name":"isiahmeadows","image":"https://avatars1.githubusercontent.com/u/4483844?v=4"},{"name":"TehShrike","image":"https://avatars0.githubusercontent.com/u/1141869?v=4"},{"name":"kemitchell","image":"https://avatars1.githubusercontent.com/u/205760?v=4"},{"name":"matthewmueller","image":"https://avatars0.githubusercontent.com/u/170299?v=4"},{"name":"ungoldman","image":"https://avatars0.githubusercontent.com/u/427322?v=4"},{"name":"nrn","image":"https://avatars1.githubusercontent.com/u/357596?v=4"},{"name":"pfrazee","image":"https://avatars2.githubusercontent.com/u/1270099?v=4"},{"name":"noffle","image":"https://avatars2.githubusercontent.com/u/489362?v=4"},{"name":"tounano","image":"https://avatars2.githubusercontent.com/u/5513418?v=4"},{"name":"mvayngrib","image":"https://avatars1.githubusercontent.com/u/83948?v=4"},{"name":"CoderPuppy","image":"https://avatars2.githubusercontent.com/u/714198?v=4"},{"name":"clehner","image":"https://avatars2.githubusercontent.com/u/95347?v=4"},{"name":"ChiperSoft","image":"https://avatars2.githubusercontent.com/u/231157?v=4"},{"name":"jo","image":"https://avatars2.githubusercontent.com/u/17586?v=4"},{"name":"csabapalfi","image":"https://avatars2.githubusercontent.com/u/181959?v=4"},{"name":"elavoie","image":"https://avatars3.githubusercontent.com/u/28413?v=4"},{"name":"amsross","image":"https://avatars0.githubusercontent.com/u/450220?v=4"},{"name":"greenkeeper[bot]","image":"https://avatars3.githubusercontent.com/in/505?v=4"},{"name":"JDvorak","image":"https://avatars0.githubusercontent.com/u/821240?v=4"},{"name":"toddself","image":"https://avatars3.githubusercontent.com/u/193412?v=4"},{"name":"myTerminal","image":"https://avatars1.githubusercontent.com/u/2478559?v=4"},{"name":"brechtcs","image":"https://avatars0.githubusercontent.com/u/6107054?v=4"},{"name":"DamonOehlman","image":"https://avatars1.githubusercontent.com/u/609693?v=4"},{"name":"onbjerg","image":"https://avatars0.githubusercontent.com/u/8862627?v=4"},{"name":"kumavis","image":"https://avatars0.githubusercontent.com/u/1474978?v=4"},{"name":"diasdavid","image":"https://avatars0.githubusercontent.com/u/1211152?v=4"},{"name":"RichardLitt","image":"https://avatars3.githubusercontent.com/u/910753?v=4"},{"name":"greenkeeperio-bot","image":"https://avatars1.githubusercontent.com/u/14790466?v=4"},{"name":"SidHarder","image":"https://avatars1.githubusercontent.com/u/1598857?v=4"},{"name":"VictorBjelkholm","image":"https://avatars2.githubusercontent.com/u/459764?v=4"},{"name":"dryajov","image":"https://avatars1.githubusercontent.com/u/1094341?v=4"},{"name":"alanshaw","image":"https://avatars1.githubusercontent.com/u/152863?v=4"},{"name":"mkg20001","image":"https://avatars2.githubusercontent.com/u/7735145?v=4"},{"name":"Beanow","image":"https://avatars3.githubusercontent.com/u/497556?v=4"},{"name":"pgte","image":"https://avatars1.githubusercontent.com/u/47910?v=4"},{"name":"jhiesey","image":"https://avatars0.githubusercontent.com/u/490140?v=4"},{"name":"lachenmayer","image":"https://avatars1.githubusercontent.com/u/38614?v=4"},{"name":"myf","image":"https://avatars0.githubusercontent.com/u/694376?v=4"},{"name":"reqshark","image":"https://avatars1.githubusercontent.com/u/937826?v=4"},{"name":"arj03","image":"https://avatars0.githubusercontent.com/u/350682?v=4"},{"name":"mmckegg","image":"https://avatars2.githubusercontent.com/u/66834?v=4"},{"name":"moimikey","image":"https://avatars3.githubusercontent.com/u/182661?v=4"},{"name":"sastan","image":"https://avatars1.githubusercontent.com/u/514405?v=4"},{"name":"queckezz","image":"https://avatars0.githubusercontent.com/u/2580598?v=4"},{"name":"rjmk","image":"https://avatars1.githubusercontent.com/u/12041390?v=4"},{"name":"allouis","image":"https://avatars3.githubusercontent.com/u/3218915?v=4"},{"name":"nrkn","image":"https://avatars1.githubusercontent.com/u/607925?v=4"},{"name":"maackle","image":"https://avatars0.githubusercontent.com/u/896230?v=4"},{"name":"iankronquist","image":"https://avatars3.githubusercontent.com/u/5192353?v=4"},{"name":"staltz","image":"https://avatars3.githubusercontent.com/u/90512?v=4"},{"name":"AljoschaMeyer","image":"https://avatars2.githubusercontent.com/u/12977795?v=4"},{"name":"adjohnson916","image":"https://avatars0.githubusercontent.com/u/29082502?v=4"},{"name":"pietgeursen","image":"https://avatars3.githubusercontent.com/u/10556538?v=4"},{"name":"santiagogil","image":"https://avatars3.githubusercontent.com/u/1757760?v=4"}],"categories":["core","combinators","real-time","file system and databases","text","binary","networks","interop","crypto","dom","parser","debugging"],"modules":[{"user":"pull-stream","name":"pull-stream","path":"pull-stream/pull-stream","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream\\">pull-stream</a><div class=\\"contrib\\"></div></h1>\\n<p>Minimal Pipeable Pull-stream</p>\\n<p>In <a href=\\"https://github.com/nodejs/node-v0.x-archive/blob/v0.8/doc/api/stream.markdown\\">classic-streams</a>,\\nstreams <em>push</em> data to the next stream in the pipeline.\\nIn <a href=\\"https://github.com/nodejs/node-v0.x-archive/blob/v0.10/doc/api/stream.markdown\\">new-streams</a>,\\ndata is pulled out of the source stream, into the destination.\\n<code>pull-stream</code> is a minimal take on streams,\\npull streams work great for &quot;object&quot; streams as well as streams of raw text or binary data.</p>\\n<p><a href=\\"https://travis-ci.org/pull-stream/pull-stream\\"></a></p>\\n<h2>Quick Example</h2>\\n<p>Stat some files:</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull.values([<span class=\\"hljs-string\\">&apos;file1&apos;</span>, <span class=\\"hljs-string\\">&apos;file2&apos;</span>, <span class=\\"hljs-string\\">&apos;file3&apos;</span>]),\\n  pull.asyncMap(fs.stat),\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, array</span>) </span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(array)\\n  })\\n)</code></pre>\\n<p>note that <code>pull(a, b, c)</code> is basically the same as <code>a.pipe(b).pipe(c)</code>.</p>\\n<p>to grok how pull-streams work, read through <a href=\\"https://github.com/dominictarr/pull-stream-examples\\">pull-streams by example</a></p>\\n<h2>How do I do X with pull-streams?</h2>\\n<p>There is a module for that!</p>\\n<p>Check the <a href=\\"https://github.com/pull-stream/pull-stream-faq\\">pull-stream FAQ</a>\\nand post an issue if you have a question that is not on that.</p>\\n<h2>Compatibily with node streams</h2>\\n<p>pull-streams are not <em>directly</em> compatible with node streams,\\nbut pull-streams can be converted into node streams with\\n<a href=\\"https://github.com/pull-stream/pull-stream-to-stream\\">pull-stream-to-stream</a>\\nand node streams can be converted into pull-stream using <a href=\\"https://github.com/pull-stream/stream-to-pull-stream\\">stream-to-pull-stream</a>\\ncorrect back pressure is preserved.</p>\\n<h3>Readable &amp; Reader vs. Readable &amp; Writable</h3>\\n<p>Instead of a readable stream, and a writable stream, there is a <code>readable</code> stream,\\n(aka &quot;Source&quot;) and a <code>reader</code> stream (aka &quot;Sink&quot;). Through streams\\nis a Sink that returns a Source.</p>\\n<p>See also:</p>\\n<ul>\\n<li><a href=\\"http://github.com/pull-stream/pull-stream/blob/master/./docs/sources/index.md\\">Sources</a></li>\\n<li><a href=\\"http://github.com/pull-stream/pull-stream/blob/master/./docs/throughs/index.md\\">Throughs</a></li>\\n<li><a href=\\"http://github.com/pull-stream/pull-stream/blob/master/./docs/sinks/index.md\\">Sinks</a></li>\\n</ul>\\n<h3>Source (aka, Readable)</h3>\\n<p>The readable stream is just a <code>function read(end, cb)</code>,\\nthat may be called many times,\\nand will (asynchronously) <code>cb(null, data)</code> once for each call.</p>\\n<p>To signify an end state, the stream eventually returns <code>cb(err)</code> or <code>cb(true)</code>.\\nWhen indicating a terminal state, <code>data</code> <em>must</em> be ignored.</p>\\n<p>The <code>read</code> function <em>must not</em> be called until the previous call has called back.\\nUnless, it is a call to abort the stream (<code>read(truthy, cb)</code>).</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-comment\\">//a stream of random numbers.</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">random</span> (<span class=\\"hljs-params\\">n</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">end, cb</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(end) <span class=\\"hljs-keyword\\">return</span> cb(end)\\n    <span class=\\"hljs-comment\\">//only read n times, then stop.</span>\\n    <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-number\\">0</span>&gt;--n) <span class=\\"hljs-keyword\\">return</span> cb(<span class=\\"hljs-literal\\">true</span>)\\n    cb(<span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-built_in\\">Math</span>.random())\\n  }\\n}</code></pre>\\n<h3>Sink; (aka, Reader, &quot;writable&quot;)</h3>\\n<p>A sink is just a <code>reader</code> function that calls a Source (read function),\\nuntil it decideds to stop, or the readable ends. <code>cb(err || true)</code></p>\\n<p>All <a href=\\"http://github.com/pull-stream/pull-stream/blob/master/./docs/throughs/index.md\\">Throughs</a>\\nand <a href=\\"http://github.com/pull-stream/pull-stream/blob/master/./docs/sinks/index.md\\">Sinks</a>\\nare reader streams.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-comment\\">//read source and log it.</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">logger</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">read</span>) </span>{\\n    read(<span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">next</span>(<span class=\\"hljs-params\\">end, data</span>) </span>{\\n      <span class=\\"hljs-keyword\\">if</span>(end === <span class=\\"hljs-literal\\">true</span>) <span class=\\"hljs-keyword\\">return</span>\\n      <span class=\\"hljs-keyword\\">if</span>(end) <span class=\\"hljs-keyword\\">throw</span> end\\n\\n      <span class=\\"hljs-built_in\\">console</span>.log(data)\\n      read(<span class=\\"hljs-literal\\">null</span>, next)\\n    })\\n  }\\n}</code></pre>\\n<p>Since these are just functions, you can pass them to each other!</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> rand = random(<span class=\\"hljs-number\\">100</span>)\\n<span class=\\"hljs-keyword\\">var</span> log = logger()\\n\\nlog(rand) <span class=\\"hljs-comment\\">//&quot;pipe&quot; the streams.</span></code></pre>\\n<p>but, it&apos;s easier to read if you use&apos;s pull-stream&apos;s <code>pull</code> method</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\npull(random(), logger())</code></pre>\\n<h3>Through</h3>\\n<p>A through stream is a reader on one end and a readable on the other.\\nIt&apos;s Sink that returns a Source.\\nThat is, it&apos;s just a function that takes a <code>read</code> function,\\nand returns another <code>read</code> function.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">map</span> (<span class=\\"hljs-params\\">read, map</span>) </span>{\\n  <span class=\\"hljs-comment\\">//return a readable function!</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">end, cb</span>) </span>{\\n    read(end, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">end, data</span>) </span>{\\n      cb(end, data != <span class=\\"hljs-literal\\">null</span> ? map(data) : <span class=\\"hljs-literal\\">null</span>)\\n    })\\n  }\\n}</code></pre>\\n<h3>Pipeability</h3>\\n<p>Every pipeline must go from a <code>source</code> to a <code>sink</code>.\\nData will not start moving until the whole thing is connected.</p>\\n<pre><code class=\\"hljs language-js\\">pull(source, through, sink)</code></pre>\\n<p>some times, it&apos;s simplest to describe a stream in terms of other streams.\\npull can detect what sort of stream it starts with (by counting arguments)\\nand if you pull together through streams, it gives you a new through stream.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> tripleThrough =\\n  pull(through1(), through2(), through3())\\n<span class=\\"hljs-comment\\">//THE THREE THROUGHS BECOME ONE</span>\\n\\npull(source(), tripleThrough, sink())</code></pre>\\n<p>pull detects if it&apos;s missing a Source by checking function arity,\\nif the function takes only one argument it&apos;s either a sink or a through.\\nOtherwise it&apos;s a Source.</p>\\n<h2>Duplex Streams</h2>\\n<p>Duplex streams, which are used to communicate between two things,\\n(i.e. over a network) are a little different. In a duplex stream,\\nmessages go both ways, so instead of a single function that represents the stream,\\nyou need a pair of streams. <code>{source: sourceStream, sink: sinkStream}</code></p>\\n<p>pipe duplex streams like this:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> a = duplex()\\n<span class=\\"hljs-keyword\\">var</span> b = duplex()\\n\\npull(a.source, b.sink)\\npull(b.source, a.sink)\\n\\n<span class=\\"hljs-comment\\">//which is the same as</span>\\n\\nb.sink(a.source); a.sink(b.source)\\n\\n<span class=\\"hljs-comment\\">//but the easiest way is to allow pull to handle this</span>\\n\\npull(a, b, a)\\n\\n<span class=\\"hljs-comment\\">//&quot;pull from a to b and then back to a&quot;</span></code></pre>\\n<h2>Design Goals &amp; Rationale</h2>\\n<p>There is a deeper,\\n<a href=\\"http://en.wikipedia.org/wiki/Platonic_idealism\\">platonic abstraction</a>,\\nwhere a streams is just an array in time, instead of in space.\\nAnd all the various streaming &quot;abstractions&quot; are just crude implementations\\nof this abstract idea.</p>\\n<p><a href=\\"https://github.com/joyent/node/blob/v0.8.16/doc/api/stream.markdown\\">classic-streams</a>,\\n<a href=\\"https://github.com/joyent/node/blob/v0.10/doc/api/stream.markdown\\">new-streams</a>,\\n<a href=\\"https://github.com/Gozala/reducers\\">reducers</a></p>\\n<p>The objective here is to find a simple realization of the best features of the above.</p>\\n<h3>Type Agnostic</h3>\\n<p>A stream abstraction should be able to handle both streams of text and streams\\nof objects.</p>\\n<h3>A pipeline is also a stream.</h3>\\n<p>Something like this should work: <code>a.pipe(x.pipe(y).pipe(z)).pipe(b)</code>\\nthis makes it possible to write a custom stream simply by\\ncombining a few available streams.</p>\\n<h3>Propagate End/Error conditions.</h3>\\n<p>If a stream ends in an unexpected way (error),\\nthen other streams in the pipeline should be notified.\\n(this is a problem in node streams - when an error occurs,\\nthe stream is disconnected, and the user must handle that specially)</p>\\n<p>Also, the stream should be able to be ended from either end.</p>\\n<h3>Transparent Backpressure &amp; Laziness</h3>\\n<p>Very simple transform streams must be able to transfer back pressure\\ninstantly.</p>\\n<p>This is a problem in node streams, pause is only transfered on write, so\\non a long chain (<code>a.pipe(b).pipe(c)</code>), if <code>c</code> pauses, <code>b</code> will have to write to it\\nto pause, and then <code>a</code> will have to write to <code>b</code> to pause.\\nIf <code>b</code> only transforms <code>a</code>&apos;s output, then <code>a</code> will have to write to <code>b</code> twice to\\nfind out that <code>c</code> is paused.</p>\\n<p><a href=\\"https://github.com/Gozala/reducers\\">reducers</a> reducers has an interesting method,\\nwhere synchronous tranformations propagate back pressure instantly!</p>\\n<p>This means you can have two &quot;smart&quot; streams doing io at the ends, and lots of dumb\\nstreams in the middle, and back pressure will work perfectly, as if the dumb streams\\nare not there.</p>\\n<p>This makes laziness work right.</p>\\n<h3>handling end, error, and abort.</h3>\\n<p>in pull streams, any part of the stream (source, sink, or through)\\nmay terminate the stream. (this is the case with node streams too,\\nbut it&apos;s not handled well).</p>\\n<h4>source: end, error</h4>\\n<p>A source may end (<code>cb(true)</code> after read) or error (<code>cb(error)</code> after read)\\nAfter ending, the source <em>must</em> never <code>cb(null, data)</code></p>\\n<h4>sink: abort</h4>\\n<p>Sinks do not normally end the stream, but if they decide they do\\nnot need any more data they may &quot;abort&quot; the source by calling <code>read(true, cb)</code>.\\nA abort (<code>read(true, cb)</code>) may be called before a preceding read call\\nhas called back.</p>\\n<h3>handling end/abort/error in through streams</h3>\\n<p>Rules for implementing <code>read</code> in a through stream:\\n1) Sink wants to stop. sink aborts the through</p>\\n<pre><code>just forward the exact read() call to your source,\\nany future read calls should cb(true).\\n</code></pre>\\n<p>2) We want to stop. (abort from the middle of the stream)</p>\\n<pre><code>abort your source, and then cb(true) to tell the sink we have ended.\\nIf the source errored during abort, end the sink by cb read with `cb(err)`.\\n(this will be an ordinary end/error for the sink)\\n</code></pre>\\n<p>3) Source wants to stop. (<code>read(null, cb) -&gt; cb(err||true)</code>)</p>\\n<pre><code>forward that exact callback towards the sink chain,\\nwe must respond to any future read calls with `cb(err||true)`.\\n</code></pre>\\n<p>In none of the above cases data is flowing!\\n4) If data is flowing (normal operation:   <code>read(null, cb) -&gt; cb(null, data)</code></p>\\n<pre><code>forward data downstream (towards the Sink)\\ndo none of the above!\\n</code></pre>\\n<p>There either is data flowing (4) OR you have the error/abort cases (1-3), never both.</p>\\n<h2>1:1 read-callback ratio</h2>\\n<p>A pull stream source (and thus transform) returns <em>exactly one value</em> per read.</p>\\n<p>This differs from node streams, which can use <code>this.push(value)</code> and in internal\\nbuffer to create transforms that write many values from a single read value.</p>\\n<p>Pull streams don&apos;t come with their own buffering mechanism, but <a href=\\"https://github.com/dominictarr/pull-stream-examples/blob/master/buffering.js\\">there are ways\\nto get around this</a>.</p>\\n<h2>Minimal bundle</h2>\\n<p>If you need only the <code>pull</code> function from this package you can reduce the size\\nof the imported code (for instance to reduce a Browserify bundle) by requiring\\nit directly:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream/pull&apos;</span>)\\n\\npull(random(), logger())</code></pre>\\n<h2>Further Examples</h2>\\n<ul>\\n<li><a href=\\"https://github.com/dominictarr/pull-stream-examples\\">dominictarr/pull-stream-examples</a></li>\\n<li><a href=\\"http://github.com/pull-stream/pull-stream/blob/master/./docs/examples.md\\">./docs/examples</a></li>\\n</ul>\\n<p>Explore this repo further for more information about\\n<a href=\\"http://github.com/pull-stream/pull-stream/blob/master/./docs/sources/index.md\\">sources</a>,\\n<a href=\\"http://github.com/pull-stream/pull-stream/blob/master/./docs/throughs/index.md\\">throughs</a>,\\n<a href=\\"http://github.com/pull-stream/pull-stream/blob/master/./docs/sinks/index.md\\">sinks</a>, and\\n<a href=\\"http://github.com/pull-stream/pull-stream/blob/master/./docs/glossary.md\\">glossary</a>.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":"3.6.0","npmName":"pull-stream","category":null},{"user":"pull-stream","name":"pull-cat","path":"pull-stream/pull-cat","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-cat\\">pull-cat</a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>Concatenate pull-streams</p>\\n</blockquote>\\n<h2>Install</h2>\\n<pre><code class=\\"hljs language-shell\\">npm install --save pull-cat</code></pre>\\n<h2>Example</h2>\\n<p>Construct a new source stream from a sequential list of source streams,\\nreading from each one in turn until it ends, then the next, etc.\\nIf one stream errors, then the rest of the streams are aborted immediately.\\nIf the cat stream is aborted (i.e. if it&apos;s sink errors) then all the streams\\nare aborted.</p>\\n<p>A cat stream is a moderately challenging stream to implement,\\nespecially in the context of error states.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> cat = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-cat&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\npull(\\n  cat([\\n    pull.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]),\\n    pull.values([<span class=\\"hljs-number\\">4</span>,<span class=\\"hljs-number\\">5</span>,<span class=\\"hljs-number\\">6</span>])\\n  ]),\\n  pull.log()\\n)\\n<span class=\\"hljs-comment\\">// 1</span>\\n<span class=\\"hljs-comment\\">// 2</span>\\n<span class=\\"hljs-comment\\">// 3</span>\\n<span class=\\"hljs-comment\\">// 4</span>\\n<span class=\\"hljs-comment\\">// 5</span>\\n<span class=\\"hljs-comment\\">// 6</span></code></pre>\\n<h2>Api</h2>\\n<h3><code>cat = require(&apos;pull-cat&apos;)</code></h3>\\n<h3><code>stream = cat(streams)</code></h3>\\n<p>Reads from each stream in <code>streams</code> until finished.</p>\\n<p>If a stream errors, stop all the streams.\\nif the concatenated stream is aborted, abort all the streams,\\nthen callback to the aborter.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,3,12,22],"version":"1.1.11","npmName":"pull-cat","category":"combinators"},{"user":"pull-stream","name":"pull-defer","path":"pull-stream/pull-defer","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-defer\\">pull-defer</a><div class=\\"contrib\\"></div></h1>\\n<p>create a placeholder for a pull stream that won&apos;t start moving until later.</p>\\n<h2>examples</h2>\\n<p><code>pull-defer</code> can be used with source, sinks and transform streams.</p>\\n<h3>through</h3>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-comment\\">//create a deferred through stream</span>\\n<span class=\\"hljs-keyword\\">var</span> deferred = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-defer&apos;</span>).through()\\n\\npull(\\n  input,\\n  deferred,\\n  output\\n)\\n\\n<span class=\\"hljs-comment\\">//nothing will happen until deferred.resolve(stream) is called.</span>\\ndeferred.resolve(transform)</code></pre>\\n<h3>source</h3>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-comment\\">//create a deferred through stream</span>\\n<span class=\\"hljs-keyword\\">var</span> deferred = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-defer&apos;</span>).source()\\n\\npull(\\n  deferred,\\n  output\\n)\\n\\n<span class=\\"hljs-comment\\">//nothing will happen until deferred.resolve(stream) is called.</span>\\ndeferred.resolve(input)</code></pre>\\n<h3>sink</h3>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-comment\\">//create a deferred through stream</span>\\n<span class=\\"hljs-keyword\\">var</span> deferred = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-defer&apos;</span>).sink()\\n\\npull(\\n  input,\\n  deferred\\n)\\n\\n<span class=\\"hljs-comment\\">//nothing will happen until deferred.start(stream) is called.</span>\\ndeferred.resolve(output)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,23],"version":"0.2.2","npmName":"pull-defer","category":"combinators"},{"user":"pull-stream","name":"pull-many","path":"pull-stream/pull-many","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-many\\">pull-many</a><div class=\\"contrib\\"></div></h1>\\n<p>Combine many streams into one stream, as they come, while respecting back pressure.</p>\\n<p>A chunk is read from each stream,\\nand the next available chunk is\\nselected in a round-robbin.</p>\\n<p>If a any stream errors, then all the remaining streams are aborted,\\nand then the sink is passed the error. If you want instead to drop the\\nerroring stream, and continue reading from the other streams, you should\\npipe each stream through a stream that handles the error(ignores, logs, whatever)\\nand then ends normally.</p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> many = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-many&apos;</span>)\\n\\npull(\\n  many([\\n    pull.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]),\\n    pull.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">3</span>,<span class=\\"hljs-number\\">5</span>]),\\n    pull.values([<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">4</span>,<span class=\\"hljs-number\\">6</span>])\\n  ]),\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, ary</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">throw</span> err\\n    <span class=\\"hljs-built_in\\">console</span>.log(ary)\\n    <span class=\\"hljs-comment\\">//=&gt; [1, 1, 2, 2, 3, 4, 3, 5, 6]</span>\\n  })\\n)\\n\\n<span class=\\"hljs-comment\\">// add streams later too</span>\\n<span class=\\"hljs-keyword\\">var</span> m = many()\\n\\npull(\\n  m,\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, ary</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">throw</span> err\\n    <span class=\\"hljs-built_in\\">console</span>.log(ary)\\n    <span class=\\"hljs-comment\\">//=&gt; [1,2,3,4,5,6]</span>\\n  })\\n)\\n\\nm.add(pull.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]))\\nm.add(pull.values([<span class=\\"hljs-number\\">4</span>,<span class=\\"hljs-number\\">5</span>,<span class=\\"hljs-number\\">6</span>]))</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,6],"version":"1.0.8","npmName":"pull-many","category":"combinators"},{"user":"pull-stream","name":"pull-merge","path":"pull-stream/pull-merge","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-merge\\">pull-merge</a><div class=\\"contrib\\"></div></h1>\\n<p>merge sorted pull-streams into one pull stream, while maintaining back-pressure.\\nSource pull streams MUST be in order.</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> merge = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-merge&apos;</span>)\\n\\npull(\\n  merge(pull.values([<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">5</span>, <span class=\\"hljs-number\\">6</span>]), pull.values([<span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-number\\">7</span>])),\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, ary</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">throw</span> err\\n\\n    <span class=\\"hljs-built_in\\">console</span>.log(ary)\\n    <span class=\\"hljs-comment\\">//=&gt; [1, 2, 4, 5, 6, 7]</span>\\n  })\\n)</code></pre>\\n<h2>signatures</h2>\\n<h3>merge(left, right, compare?)</h3>\\n<p>return a stream that is the merge of left and right streams.\\nmerge pulls a chunk from both <code>left</code> and <code>right</code> and then\\ncompares them. <code>compare</code> has the same signature as <code>Array#sort(compare)</code>.\\nIf the two chunks are compared the same, the chunk from the right stream\\nis taken, but the left chunk is dropped.\\nOtherwise, the lowest chunk is passed to the stream.</p>\\n<h3>merge([streams...], compare?)</h3>\\n<p>Merge a collection of steams. This calls the first signature recursively.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.0.3","npmName":"pull-merge","category":"combinators"},{"user":"pull-stream","name":"pull-paramap","path":"pull-stream/pull-paramap","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-paramap\\">pull-paramap</a><div class=\\"contrib\\"></div></h1>\\n<p>parallel mapping pull-stream.</p>\\n<p><a href=\\"https://travis-ci.org/dominictarr/pull-paramap\\">\\n</a></p>\\n<p><a href=\\"http://ci.testling.com/dominictarr/pull-paramap\\">\\n</a></p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> paramap = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-paramap&apos;</span>)\\n\\npull(\\n  pull.values([....]),\\n  <span class=\\"hljs-comment\\">//perform an async job in parallel,</span>\\n  <span class=\\"hljs-comment\\">//but return results in the same order as they went in.</span>\\n  paramap(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">data, cb</span>) </span>{\\n    asyncJob(data, cb)\\n  }, width), <span class=\\"hljs-comment\\">//optional number.</span>\\n             <span class=\\"hljs-comment\\">//limits stream to process width items at once</span>\\n  pull.collect(cb)\\n)\\n\\npull(\\n  pull.values([....]),\\n  <span class=\\"hljs-comment\\">//perform an async job in parallel,</span>\\n  <span class=\\"hljs-comment\\">//and return results in the order they arrive</span>\\n  paramap(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">data, cb</span>) </span>{\\n    asyncJob(data, cb)\\n  }, <span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-literal\\">false</span>), <span class=\\"hljs-comment\\">// optional flag `inOrder`, default true</span>\\n  pull.collect(cb)\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,24,25,6],"version":"1.2.2","npmName":"pull-paramap","category":"combinators"},{"user":"pull-stream","name":"pull-flatmap","path":"pull-stream/pull-flatmap","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-flatmap\\">pull-flatmap</a><div class=\\"contrib\\"></div></h1>\\n<p>flatmap for pull-streams</p>\\n<p>map an input to an array, but the items in those arrays become the stream.\\nso you can use this module to make expanding or contracting streams.</p>\\n<p>taken from example on <a href=\\"http://dominictarr.com/post/149248845122/pull-streams-pull-streams-are-a-very-simple\\">introduction to pull-streams</a></p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\npull(\\n  pull.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]),\\n  flatmap(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">n</span>) </span>{\\n    <span class=\\"hljs-comment\\">//return an array of n n&apos;s [2,2] or [3,3,3], etc</span>\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Array</span>(n).map(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{ <span class=\\"hljs-keyword\\">return</span> n })\\n  }),\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, ary</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">throw</span> err\\n    <span class=\\"hljs-built_in\\">console</span>.log(ary)\\n  })\\n)</code></pre>\\n<p>output:</p>\\n<pre><code>[1, 2, 2, 3, 3, 3]\\n</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"0.0.1","npmName":"pull-flatmap","category":"combinators"},{"user":"dominictarr","name":"pull-map-last","path":"dominictarr/pull-map-last","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-map-last\\">pull-map-last</a><div class=\\"contrib\\"></div></h1>\\n<p>Like pull-stream/throughs/map except also takes a function to be called when the source ends.</p>\\n<p>Used to create streams that map 1:1 with input, but also need a special case for the end of the stream.</p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  source...,\\n  MapLast(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">each</span> (<span class=\\"hljs-params\\">data</span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> the transformed item...\\n  }, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> last item...\\n  }),\\n  ...sink\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.0.0","npmName":"pull-map-last","category":"combinators"},{"user":"pull-stream","name":"pull-pair","path":"pull-stream/pull-pair","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-pair\\">pull-pair</a><div class=\\"contrib\\"></div></h1>\\n<p>A pair of {source, sink} streams that are internally connected,\\n(what goes into the sink comes out the source)</p>\\n<p>This can be used to construct pipelines that are connected.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pair = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-pair&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> p = pair()\\n\\n<span class=\\"hljs-comment\\">//read values into this sink...</span>\\npull(pull.values([<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>]), p.sink)\\n\\n<span class=\\"hljs-comment\\">//but that should become the source over here.</span>\\npull(p.source, pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, values</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">throw</span> err\\n  <span class=\\"hljs-built_in\\">console</span>.log(values) <span class=\\"hljs-comment\\">//[1, 2, 3]</span>\\n}))</code></pre>\\n<p>This is particularily useful for creating duplex streams especilaly\\naround servers. Use <code>pull-pair/duplex</code> to get two duplex streams\\nthat are attached to each other.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> DuplexPair = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-pair/duplex&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> d = DuplexPair()\\n\\n<span class=\\"hljs-comment\\">//the &quot;client&quot;: pipe to the first duplex and get the response.</span>\\npull(\\n  pull.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]),\\n  d[<span class=\\"hljs-number\\">0</span>],\\n  pull.collect(<span class=\\"hljs-built_in\\">console</span>.log) <span class=\\"hljs-comment\\">// =&gt; 10, 20, 30</span>\\n)\\n\\n<span class=\\"hljs-comment\\">//the &quot;server&quot;: pipe from the second stream back to itself</span>\\n<span class=\\"hljs-comment\\">//(in this case) appling a transformation.</span>\\npull(\\n  d[<span class=\\"hljs-number\\">1</span>],\\n  pull.map(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">e</span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> e*<span class=\\"hljs-number\\">10</span>\\n  }),\\n  d[<span class=\\"hljs-number\\">1</span>]\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.1.0","npmName":"pull-pair","category":"combinators"},{"user":"pull-stream","name":"pull-through","path":"pull-stream/pull-through","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-through\\">pull-through</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://github.com/dominictarr/through\\">through</a> ported to\\n<a href=\\"https://github.com/dominictarr/pull-stream\\">pull-stream</a> style.</p>\\n<h2>Example</h2>\\n<p>Same Good Old Api, Brand New Underlying Mechanism.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> through = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-through&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> ts = through(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">data</span>) </span>{\\n  <span class=\\"hljs-keyword\\">this</span>.queue(data)\\n}, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">end</span>) </span>{\\n  <span class=\\"hljs-keyword\\">this</span>.queue(<span class=\\"hljs-literal\\">null</span>)\\n})</code></pre>\\n<h2>Incompatibility</h2>\\n<h3>DON&apos;T</h3>\\n<p>use <code>var self = this</code>, don&apos;t keep a reference.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> WRONG = through(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">data</span>) </span>{ WRONG.queue(data) })</code></pre>\\n<h3>DO</h3>\\n<pre><code class=\\"hljs language-js\\">through(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">data</span>) </span>{ <span class=\\"hljs-keyword\\">this</span>.queue(data) })</code></pre>\\n<p>Maybe this will change. this is a little more tricky with pull-streams, though.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.0.18","npmName":"pull-through","category":"combinators"},{"user":"pull-stream","name":"pull-traverse","path":"pull-stream/pull-traverse","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-traverse\\">pull-traverse</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://travis-ci.org/dominictarr/pull-traverse\\"></a></p>\\n<h2>depthFirst, widthFirst, leafFirst (start, createStream)</h2>\\n<p>Traverse a tree structure. <code>start</code> is a value that represents\\na node. <code>createStream</code> is a function that returns\\na pull-stream of the children of a node.\\n<code>start</code> must be the same type output by <code>createStream</code>.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pt   = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-traverse&apos;</span>)\\n\\npull(\\n  pt.widthFirst(objects, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">object</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(object &amp;&amp; <span class=\\"hljs-string\\">&apos;object&apos;</span> === <span class=\\"hljs-keyword\\">typeof</span> object)\\n      <span class=\\"hljs-keyword\\">return</span> pull.values(object)\\n    <span class=\\"hljs-keyword\\">return</span> pull.empty()\\n  }),\\n  pull.log()\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.0.3","npmName":"pull-traverse","category":"combinators"},{"user":"pull-stream","name":"pull-window","path":"pull-stream/pull-window","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-window\\">pull-window</a><div class=\\"contrib\\"></div></h1>\\n<p>Aggregate a pull-stream into windows.</p>\\n<p>Several helpers are provided for particular types of windows,\\nsliding, tumbling, etc.</p>\\n<p>And also, a low level</p>\\n<h2>Example: &quot;tumbling&quot; window</h2>\\n<p>sum every 10 items.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull   = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> <span class=\\"hljs-built_in\\">window</span> = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-window&apos;</span>)\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">everyTen</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">var</span> i = <span class=\\"hljs-number\\">0</span>\\n  <span class=\\"hljs-comment\\">//window calls init with each data item,</span>\\n  <span class=\\"hljs-comment\\">//and a callback to close that window.</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">window</span>(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">data, cb</span>) </span>{\\n    <span class=\\"hljs-comment\\">//if you don&apos;t want to start a window here,</span>\\n    <span class=\\"hljs-comment\\">//return undefined</span>\\n    <span class=\\"hljs-keyword\\">if</span>(i != <span class=\\"hljs-number\\">0</span>) <span class=\\"hljs-keyword\\">return</span>\\n    <span class=\\"hljs-keyword\\">var</span> sum = <span class=\\"hljs-number\\">0</span>\\n\\n    <span class=\\"hljs-comment\\">//else return a function.</span>\\n    <span class=\\"hljs-comment\\">//this will be called all data</span>\\n    <span class=\\"hljs-comment\\">//until you callback.</span>\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">end, data</span>) </span>{\\n      <span class=\\"hljs-keyword\\">if</span>(end) <span class=\\"hljs-keyword\\">return</span> cb(<span class=\\"hljs-literal\\">null</span>, sum)\\n      sum += data\\n      <span class=\\"hljs-keyword\\">if</span>(++i &gt;= <span class=\\"hljs-number\\">10</span>) {\\n        i = <span class=\\"hljs-number\\">0</span>\\n        cb(<span class=\\"hljs-literal\\">null</span>, sum)\\n      }\\n    }\\n  }\\n}\\n\\npull(\\n  pull.count(<span class=\\"hljs-number\\">1000</span>),\\n  everyTen(),\\n  pull.log()\\n)</code></pre>\\n<h2>Example: variable sized window</h2>\\n<p>Each window doesn&apos;t have to be the same size...</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull   = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> <span class=\\"hljs-built_in\\">window</span> = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-window&apos;</span>)\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">groupTo100</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">var</span> sum = <span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">window</span>(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">_, cb</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(sum != <span class=\\"hljs-literal\\">null</span>) <span class=\\"hljs-keyword\\">return</span>\\n\\n    <span class=\\"hljs-comment\\">//sum stuff together until you have 100 or more</span>\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">end, data</span>) </span>{\\n      <span class=\\"hljs-keyword\\">if</span>(end) <span class=\\"hljs-keyword\\">return</span> cb(<span class=\\"hljs-literal\\">null</span>, sum)\\n      sum += data\\n      <span class=\\"hljs-keyword\\">if</span>(sum &gt;= <span class=\\"hljs-number\\">100</span>) {\\n        <span class=\\"hljs-comment\\">//copy sum like this, incase the next item</span>\\n        <span class=\\"hljs-comment\\">//comes through sync</span>\\n        <span class=\\"hljs-keyword\\">var</span> _sum = sum; sum = <span class=\\"hljs-literal\\">null</span>\\n        cb(<span class=\\"hljs-literal\\">null</span>, _sum)\\n      }\\n    }\\n  })\\n}\\n\\npull(\\n  pull.count(<span class=\\"hljs-number\\">1000</span>)\\n  groupTo100(),\\n  pull.log()\\n)</code></pre>\\n<h2>Example: sliding window</h2>\\n<p>to make more over lapping windows\\njust return the window function more often.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull   = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> <span class=\\"hljs-built_in\\">window</span> = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-window&apos;</span>)\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">sliding</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">window</span>(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">_, cb</span>) </span>{\\n    <span class=\\"hljs-keyword\\">var</span> sum = <span class=\\"hljs-number\\">0</span>, i = <span class=\\"hljs-number\\">0</span>\\n\\n    <span class=\\"hljs-comment\\">//sum stuff together until you have 100 or more</span>\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">end, data</span>) </span>{\\n      <span class=\\"hljs-keyword\\">if</span>(end) <span class=\\"hljs-keyword\\">return</span> cb(<span class=\\"hljs-literal\\">null</span>, sum)\\n      sum += data\\n      <span class=\\"hljs-keyword\\">if</span>(++i &gt;= <span class=\\"hljs-number\\">10</span>) {\\n        <span class=\\"hljs-comment\\">//in this example, each window gets it&apos;s own sum,</span>\\n        <span class=\\"hljs-comment\\">//so we don&apos;t need to copy it.</span>\\n        cb(<span class=\\"hljs-literal\\">null</span>, sum)\\n      }\\n    }\\n  })\\n}\\n\\npull(\\n  pull.count(<span class=\\"hljs-number\\">100</span>)\\n  sliding(),\\n  pull.log()\\n)</code></pre>\\n<h2>API</h2>\\n<h3>window (start, map)</h3>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-built_in\\">window</span>(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">startWindow</span> (<span class=\\"hljs-params\\">data, cb</span>) </span>{\\n\\n  <span class=\\"hljs-comment\\">//called on each chunk</span>\\n  <span class=\\"hljs-comment\\">//including the first one</span>\\n  <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">addToWindow</span> (<span class=\\"hljs-params\\">end, data</span>) </span>{\\n    <span class=\\"hljs-comment\\">//cb(null, aggregate) when done.</span>\\n  }\\n}, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">mapWindow</span> (<span class=\\"hljs-params\\">start, data</span>) </span>{\\n  <span class=\\"hljs-comment\\">//(optional)</span>\\n  <span class=\\"hljs-comment\\">//map the window to something that tracks start, also</span>\\n})</code></pre>\\n<p>By default, windows are mapped to <code>{start: firstData, data: aggregate}</code>.\\nunless you pass in an different <code>mapWindow</code> function.</p>\\n<h3>window.sliding(reduce, size)</h3>\\n<p>reduce every <code>size</code> items into a single value, in a sliding window</p>\\n<h3>window.recent(size, time)</h3>\\n<p>tumbling window that groups items onto an array,\\neither every <code>size</code> items, or within <code>time</code> ms,\\nwhich ever occurs earliest.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,1],"version":"2.1.4","npmName":"pull-window","category":"combinators"},{"user":"pull-stream","name":"pull-next","path":"pull-stream/pull-next","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-next\\">pull-next</a><div class=\\"contrib\\"></div></h1>\\n<p>read from one pull-stream, then the next, then the next...</p>\\n<p>when one stream end (unless it errored) call a function\\nto get the next stream. much like <a href=\\"https://github.com/pull-stream/pull-cat\\">pull-cat</a>\\nexcept creates streams by calling a function instead of takeing them out of an array.</p>\\n<p>in particular, this is useful for making a read stream that reconnects\\nto a source.</p>\\n<h2>example</h2>\\n<p>create a stream that reads from a leveldb 100 items at a time.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> next = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-next&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pl = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-level&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> db = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;level&apos;</span>)(path_to_level)\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">resume</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">var</span> last = <span class=\\"hljs-literal\\">null</span>\\n  <span class=\\"hljs-keyword\\">return</span> Next(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> pull(\\n      pl.read(db, {<span class=\\"hljs-attr\\">gt</span>: last &amp;&amp; last.key, <span class=\\"hljs-attr\\">limit</span>: <span class=\\"hljs-number\\">100</span>}),\\n      pull.through(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">data</span>) </span>{ last = data })\\n    )\\n  })\\n}</code></pre>\\n<p>hint: this might be even more useful over <a href=\\"https://github.com/level/multilevel\\">multilevel</a></p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,15],"version":"1.0.1","npmName":"pull-next","category":"combinators"},{"user":"pull-stream","name":"pull-zip","path":"pull-stream/pull-zip","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-zip\\">pull-zip</a><div class=\\"contrib\\"></div></h1>\\n<p>zip <a href=\\"https://github.com/dominictarr/pull-stream\\">pull-stream</a></p>\\n<p>combine N streams into N length tuples.</p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> zip  = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-zip&apos;</span>)\\n\\npull(\\n  zip(pull.values([<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>]), pull.values([<span class=\\"hljs-string\\">&apos;A&apos;</span>, <span class=\\"hljs-string\\">&apos;B&apos;</span>, <span class=\\"hljs-string\\">&apos;C&apos;</span>])),\\n  pull.log()\\n)\\n<span class=\\"hljs-comment\\">// [1, &apos;A&apos;]</span>\\n<span class=\\"hljs-comment\\">// [2, &apos;B&apos;]</span>\\n<span class=\\"hljs-comment\\">// [3, &apos;C&apos;]</span></code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"2.0.1","npmName":"pull-zip","category":"combinators"},{"user":"pull-stream","name":"pull-sort","path":"pull-stream/pull-sort","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-sort\\">pull-sort</a><div class=\\"contrib\\"></div></h1>\\n<p>sort a pull-stream, necessarily, this buffers the stream and then streams\\nthe sorted stream.</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Sort = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-sort&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream/pull&apos;</span>)\\n\\npull(\\n  source,\\n  Sort(compare),\\n  sink\\n)</code></pre>\\n<p><code>Sort</code> takes an optional comparitor, the same signature as <code>Array#sort</code></p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.0.0","npmName":"pull-sort","category":"combinators"},{"user":"pull-stream","name":"pull-sorted-merge","path":"pull-stream/pull-sorted-merge","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-sorted-merge\\">pull-sorted-merge</a><div class=\\"contrib\\"></div></h1>\\n<p>merge a series of pull-streams into one pull-stream.</p>\\n<p><a href=\\"http://travis-ci.org/dominictarr/pull-stream-merge\\"></a></p>\\n<p><a href=\\"https://ci.testling.com/dominictarr/pull-stream-merge\\"></a></p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> merge = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-sorted-merge&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull  = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\nmerge([stream1, stream2, stream3], sort)\\n  .pipe(pull.log())</code></pre>\\n<p><code>Merge</code> assumes that the each pull streams are in order.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,26],"version":"1.0.5","npmName":"pull-sorted-merge","category":"combinators"},{"user":"pull-stream","name":"pull-tee","path":"pull-stream/pull-tee","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-tee\\">pull-tee</a><div class=\\"contrib\\"></div></h1>\\n<p>feed a pull-stream into multiple sinks</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> tee  = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;../&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> assert = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;assert&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> a, b\\n\\npull(\\n  pull.values([<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-number\\">5</span>]),\\n  tee(\\n    pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, _a</span>) </span>{\\n      a = _a\\n      <span class=\\"hljs-keyword\\">if</span> (b &amp;&amp; a) assert.deepEqual(a, b)\\n    })\\n  ),\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, _b</span>) </span>{\\n    b = _b\\n    <span class=\\"hljs-keyword\\">if</span> (b &amp;&amp; a) assert.deepEqual(a, b)\\n  })\\n)\\n\\n<span class=\\"hljs-built_in\\">console</span>.log(a, b)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,6],"version":"2.0.1","npmName":"pull-tee","category":"combinators"},{"user":"pull-stream","name":"pull-high-watermark","path":"pull-stream/pull-high-watermark","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-high-watermark\\">pull-high-watermark</a><div class=\\"contrib\\"></div></h1>\\n<p>a pull stream that eagerly reads ahead until it has reached the watermark.</p>\\n<h2>example</h2>\\n<p>if there is medium/heavy sync processing in the pipe line (say, parsing),\\nit may go faster if we ensure there is always something coming in the async part,</p>\\n<p>We never want the io to be waiting for the parsing.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> HighWatermark = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-high-watermark&apos;</span>)\\n\\npull(\\n  asyncSource,\\n  HighWatermark(<span class=\\"hljs-number\\">10</span>, <span class=\\"hljs-number\\">2</span>), <span class=\\"hljs-comment\\">//go faster!</span>\\n  heavySyncProcessing(),\\n  sink\\n)</code></pre>\\n<h2>HighWatermark(hwm, lwm) =&gt; through</h2>\\n<p>read ahead at most to the high water mark (<code>hwm</code>) and at least to the low water mark (<code>lwm</code>)\\n<code>hwm</code> default to 10, and <code>lwm</code> defaults to 0.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"0.1.0","npmName":"pull-high-watermark","category":"combinators"},{"user":"pull-stream","name":"pull-abortable","path":"pull-stream/pull-abortable","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-abortable\\">pull-abortable</a><div class=\\"contrib\\"></div></h1>\\n<p>a pull-stream that may be aborted from the outside.</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> Abortable = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-abortable&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> abortable = Abortable()\\npull(\\n  source,\\n  abortable,\\n  sink\\n)\\n<span class=\\"hljs-comment\\">//at any time you can abort the pipeline,</span>\\n<span class=\\"hljs-comment\\">//the source will be cleaned up, and any</span>\\n<span class=\\"hljs-comment\\">//error will be passed to the sink next time it reads.</span>\\natAnyTime(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n  abortable.abort()\\n})\\n\\n<span class=\\"hljs-comment\\">// abort the stream and end with an error</span>\\nabortable.abort(<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(<span class=\\"hljs-string\\">&apos;example&apos;</span>))</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,27,6],"version":"4.1.1","npmName":"pull-abortable","category":"combinators"},{"user":"pull-stream","name":"pull-peek","path":"pull-stream/pull-peek","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-peek\\">pull-peek</a><div class=\\"contrib\\"></div></h1>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"0.0.0","npmName":"pull-peek","category":"combinators"},{"user":"pull-stream","name":"pull-cache","path":"pull-stream/pull-cache","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-cache\\">pull-cache</a><div class=\\"contrib\\"></div></h1>\\n<p>Cache a pull-stream source so that you can read it multiple times and the\\nunderlying source only gets read once. Backpressure is respected, so if none of\\nthe resulting cached sources are read, the underlying source is not read.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> cache = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-cache&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> sourceCache = pull(expensiveSource, cache)\\npull(sourceCache(), ...)\\npull(sourceCache(), ...)\\npull(sourceCache(), ...)</code></pre>\\n<h2>API</h2>\\n<h4><code>cache(source): sourceCache</code></h4>\\n<p>Transform a readable stream <code>source</code> into a <code>sourceCache</code> function</p>\\n<h4><code>sourceCache(): cachedSource</code></h4>\\n<p>Return a new readable stream <code>cachedSource</code> that streams the same data as would\\nbe read from <code>source</code></p>\\n<h4><code>sourceCache(end, cb)</code></h4>\\n<p>Abort the underlying source and end its cached sources</p>\\n<h2>License</h2>\\n<p>Copyright (c) 2016 Charles Lehner</p>\\n<p>Usage of the works is permitted provided that this instrument is\\nretained with the works, so that any entity that uses the works is\\nnotified of this instrument.</p>\\n<p>DISCLAIMER: THE WORKS ARE WITHOUT WARRANTY.</p>\\n","contributors":[24],"version":"0.0.0","npmName":"pull-cache","category":"combinators"},{"user":"regular","name":"pull-generate","path":"regular/pull-generate","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/regular/pull-generate\\">pull-generate</a><div class=\\"contrib\\"></div></h1>\\n<p>A <a href=\\"https://github.com/dominictarr/pull-stream\\">pull-stream</a> source that produces data on state transitions</p>\\n<h2>Simple Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> generate = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-generate&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\npull(\\n    generate(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">state, cb</span>) </span>{\\n        cb(state&gt;<span class=\\"hljs-number\\">3</span> ? <span class=\\"hljs-literal\\">true</span> : <span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-number\\">1</span>&lt;&lt;state, state + <span class=\\"hljs-number\\">1</span>)\\n    }),\\n    pull.log()\\n)\\n\\n<span class=\\"hljs-comment\\">// ==&gt; 1 2 4 8</span></code></pre>\\n<h2>Usage</h2>\\n<h3><code>generate(initialState, expand [, onAbort])</code></h3>\\n<ul>\\n<li>\\n<p><code>expand</code>: function that is called with <code>initialstate</code> and a callback.</p>\\n<ul>\\n<li>\\n<p>the callback has the following signature: <code>callback(err, data, newState)</code></p>\\n<ul>\\n<li>\\n<p><code>err</code></p>\\n<ul>\\n<li><code>null</code> to pass <code>data</code> downstream (normal operation)</li>\\n<li><code>true</code> indicates the end of the stream</li>\\n<li>everything else is treated as an error</li>\\n</ul>\\n</li>\\n<li><code>data</code> is send downstream (only if err === null)</li>\\n<li><code>newState</code> is used as <code>state</code> in the next call to <code>expand</code>.</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>onAbort: optional function that is called after the stream ended</p>\\n<ul>\\n<li>is called with <code>null</code> or an error object</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[1],"version":"2.2.0","npmName":"pull-generate","category":"combinators"},{"user":"regular","name":"pull-debounce","path":"regular/pull-debounce","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/regular/pull-debounce\\">pull-debounce</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://nodei.co/npm/pull-debounce/\\"></a></p>\\n<p>debounce for pull-streams</p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> debounce = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-debounce&apos;</span>)\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">timedSource</span>(<span class=\\"hljs-params\\">data</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> pull(\\n    pull.values(data),\\n    pull.asyncMap(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">item, cb</span>) </span>{\\n      setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n        cb(<span class=\\"hljs-literal\\">null</span>, item[<span class=\\"hljs-number\\">1</span>])\\n      }, item[<span class=\\"hljs-number\\">0</span>]);\\n    })\\n  )\\n}\\n\\npull(\\n  timedSource([\\n    [<span class=\\"hljs-number\\">0</span>,   <span class=\\"hljs-number\\">0</span>],\\n    [<span class=\\"hljs-number\\">250</span>, <span class=\\"hljs-number\\">1</span>],\\n    [<span class=\\"hljs-number\\">10</span>,  <span class=\\"hljs-number\\">2</span>],\\n    [<span class=\\"hljs-number\\">250</span>, <span class=\\"hljs-number\\">3</span>],\\n    [<span class=\\"hljs-number\\">2000</span>,<span class=\\"hljs-number\\">4</span>],\\n    [<span class=\\"hljs-number\\">10</span>,  <span class=\\"hljs-number\\">5</span>]\\n  ]),\\n  debounce(<span class=\\"hljs-number\\">200</span>),\\n  pull.log()\\n)\\n<span class=\\"hljs-comment\\">// =&gt; 0,2,3,5</span></code></pre>\\n<h2>Credits</h2>\\n<p>Many thanks to <a href=\\"https://github.com/amsross\\">@amsross</a>, who provided valuable feedback, bug reports and code</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[1],"version":"1.1.1","npmName":"pull-debounce","category":"combinators"},{"user":"nichoth","name":"pull-combine-latest","path":"nichoth/pull-combine-latest","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/nichoth/pull-combine-latest\\">pull combine latest </a><div class=\\"contrib\\"></div></h1>\\n<p>Combine the latest values from many streams. The algorithm waits until every stream has emitted a value, then emits a new array whenever one of the streams has more data.</p>\\n<h2>install</h2>\\n<pre><code>$ npm install pull-combine-latest\\n</code></pre>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> S = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> combineLatest = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-combine-latest&apos;</span>)\\n\\nS(\\n    <span class=\\"hljs-comment\\">// pass an array of streams</span>\\n    combineLatest([S.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]), S.values([<span class=\\"hljs-string\\">&apos;a&apos;</span>,<span class=\\"hljs-string\\">&apos;b&apos;</span>,<span class=\\"hljs-string\\">&apos;c&apos;</span>])]),\\n    S.log()\\n)\\n\\nS(\\n    <span class=\\"hljs-comment\\">// or pass streams as arguments</span>\\n    combineLatest(S.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]), S.values([<span class=\\"hljs-string\\">&apos;a&apos;</span>,<span class=\\"hljs-string\\">&apos;b&apos;</span>,<span class=\\"hljs-string\\">&apos;c&apos;</span>])),\\n    S.log()\\n)\\n\\n<span class=\\"hljs-comment\\">/*\\noutput:\\n\\n    [1,&apos;a&apos;]\\n    [2,&apos;a&apos;]\\n    [2,&apos;b&apos;]\\n    [3,&apos;b&apos;]\\n    [3,&apos;c&apos;]\\n\\n*/</span>\\n\\n\\n<span class=\\"hljs-comment\\">// new data is emitted as soon as it is received, so sync data will always</span>\\n<span class=\\"hljs-comment\\">// be emitted before async data</span>\\nS(\\n    combineLatest(S.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]), asyncValues([<span class=\\"hljs-string\\">&apos;a&apos;</span>,<span class=\\"hljs-string\\">&apos;b&apos;</span>,<span class=\\"hljs-string\\">&apos;c&apos;</span>])),\\n    S.log()\\n)\\n<span class=\\"hljs-comment\\">/*\\n    [1,&apos;a&apos;]\\n    [2,&apos;a&apos;]\\n    [3,&apos;a&apos;]\\n    [3,&apos;b&apos;]\\n    [3,&apos;c&apos;]\\n*/</span>\\n\\n\\n<span class=\\"hljs-comment\\">// object map</span>\\nS(\\n    combineLatest({\\n        <span class=\\"hljs-attr\\">a</span>: S.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]),\\n        <span class=\\"hljs-attr\\">b</span>: S.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>])\\n    }),\\n    S.log()\\n)\\n<span class=\\"hljs-comment\\">/*\\n    { a: 1, b: 1 }\\n    { a: 2, b: 1 }\\n    { a: 2, b: 2 }\\n    { a: 3, b: 2 }\\n    { a: 3, b: 3 }\\n*/</span></code></pre>\\n","contributors":[6,3],"version":"1.1.2","npmName":"pull-combine-latest","category":"combinators"},{"user":"nichoth","name":"pull-with-latest","path":"nichoth/pull-with-latest","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/nichoth/pull-with-latest\\">pull with latest</a><div class=\\"contrib\\"></div></h1>\\n<p>Take two streams, and return a new stream that emits every value from the first stream with the most recent value from the other stream. This operator is sometimes called &apos;sample&apos;.</p>\\n<h2>install</h2>\\n<pre><code>npm install pull-with-latest\\n</code></pre>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> test = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;tape&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> withLatest = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;../&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> S = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\ntest(<span class=\\"hljs-string\\">&apos;pass null for the default predicate&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n    t.plan(<span class=\\"hljs-number\\">2</span>)\\n    <span class=\\"hljs-keyword\\">var</span> predicate = <span class=\\"hljs-literal\\">null</span>\\n\\n    S(\\n        withLatest.apply(<span class=\\"hljs-literal\\">null</span>, [predicate].concat(sources())),\\n        S.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, res</span>) </span>{\\n            t.error(err)\\n            t.deepEqual(res, [\\n                [<span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-string\\">&apos;a&apos;</span>],\\n                [<span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-string\\">&apos;b&apos;</span>],\\n                [<span class=\\"hljs-number\\">6</span>, <span class=\\"hljs-string\\">&apos;c&apos;</span>]\\n            ], <span class=\\"hljs-string\\">&apos;should combine the streams ok&apos;</span>)\\n        })\\n    )\\n})\\n\\ntest(<span class=\\"hljs-string\\">&apos;use predicate function&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n    t.plan(<span class=\\"hljs-number\\">2</span>)\\n    <span class=\\"hljs-keyword\\">var</span> predicate = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">a, b</span>) </span>{\\n        <span class=\\"hljs-keyword\\">return</span> { <span class=\\"hljs-attr\\">a</span>: a, <span class=\\"hljs-attr\\">b</span>: b }\\n    }\\n\\n    S(\\n        withLatest.apply(<span class=\\"hljs-literal\\">null</span>, [predicate].concat(sources())),\\n        S.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, res</span>) </span>{\\n            t.error(err)\\n            t.deepEqual(res, [\\n                { <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-attr\\">b</span>:<span class=\\"hljs-string\\">&apos;a&apos;</span> },\\n                { <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-attr\\">b</span>:<span class=\\"hljs-string\\">&apos;b&apos;</span> },\\n                { <span class=\\"hljs-attr\\">a</span>:<span class=\\"hljs-number\\">6</span>, <span class=\\"hljs-attr\\">b</span>:<span class=\\"hljs-string\\">&apos;c&apos;</span> }\\n            ], <span class=\\"hljs-string\\">&apos;should combine the streams ok&apos;</span>)\\n        })\\n    )\\n})\\n\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">sources</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-keyword\\">var</span> sampler = S(\\n        S.values([<span class=\\"hljs-string\\">&apos;a&apos;</span>,<span class=\\"hljs-string\\">&apos;b&apos;</span>,<span class=\\"hljs-string\\">&apos;c&apos;</span>]),\\n        S.asyncMap(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">ev, cb</span>) </span>{\\n            setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n                cb(<span class=\\"hljs-literal\\">null</span>, ev)\\n            }, <span class=\\"hljs-number\\">210</span>)\\n        })\\n    )\\n\\n    <span class=\\"hljs-keyword\\">var</span> otherStream = S(\\n        S.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>,<span class=\\"hljs-number\\">4</span>,<span class=\\"hljs-number\\">5</span>,<span class=\\"hljs-number\\">6</span>]),\\n        S.asyncMap(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">ev, cb</span>) </span>{\\n            setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n                cb(<span class=\\"hljs-literal\\">null</span>, ev)\\n            }, <span class=\\"hljs-number\\">100</span>)\\n        })\\n    )\\n\\n    <span class=\\"hljs-keyword\\">return</span> [otherStream, sampler]\\n}</code></pre>\\n","contributors":[6],"version":"3.0.1","npmName":"pull-with-latest","category":"combinators"},{"user":"nichoth","name":"pull-scan","path":"nichoth/pull-scan","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/nichoth/pull-scan\\">pull scan </a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/scan.md\\">Scan algorithm</a> for pull streams. It&apos;s like reduce, but emits intermediate values. So it&apos;s more like map but with an accumulator argument.</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> test = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;tape&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> S = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> scan = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;../&apos;</span>)\\n\\ntest(<span class=\\"hljs-string\\">&apos;works given initial state&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n    t.plan(<span class=\\"hljs-number\\">1</span>)\\n    S(\\n        S.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]),\\n\\n        scan(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">acc, n</span>) </span>{\\n            <span class=\\"hljs-keyword\\">return</span> acc + n\\n        }, <span class=\\"hljs-number\\">10</span>),\\n\\n        S.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, data</span>) </span>{\\n            t.deepEqual(data, [<span class=\\"hljs-number\\">11</span>,<span class=\\"hljs-number\\">13</span>,<span class=\\"hljs-number\\">16</span>], <span class=\\"hljs-string\\">&apos;should use init state argument&apos;</span>)\\n        })\\n    )\\n})\\n\\ntest(<span class=\\"hljs-string\\">&apos;use default init state&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n    t.plan(<span class=\\"hljs-number\\">1</span>)\\n    S(\\n        S.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]),\\n\\n        scan(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">acc, n</span>) </span>{\\n            <span class=\\"hljs-keyword\\">return</span> acc + n\\n        }),\\n\\n        S.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, data</span>) </span>{\\n            t.deepEqual(data, [<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">3</span>,<span class=\\"hljs-number\\">6</span>],\\n                <span class=\\"hljs-string\\">&apos;should use first val as default state&apos;</span>)\\n        })\\n    )\\n})</code></pre>\\n","contributors":[6],"version":"1.0.0","npmName":"pull-scan","category":"combinators"},{"user":"dominictarr","name":"pull-cont","path":"dominictarr/pull-cont","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-cont\\">pull-cont</a><div class=\\"contrib\\"></div></h1>\\n<p>pull-streams and continuables make friends!</p>\\n<h2>continuables</h2>\\n<p>continuables are a like async callbacks, but more composable.\\ninstead of taking a series of arguments, then a callback,\\na continuable takes it&apos;s arguments, and returns a function\\nthat takes exactly one argument: the callback.</p>\\n<p>this makes it easy represent a single async operation,\\nyou can easily pass a continuable to another function.</p>\\n<p><a href=\\"https://github.com/raynos/continuable\\">continuable</a> repo, bundle of best <a href=\\"https://github.com/dominictarr/cont\\">cont</a>inuables.</p>\\n<h2>example</h2>\\n<p>pull-cont takes a continuable that returns a pull-stream, and makes it into a pull-stream.</p>\\n<p>It&apos;s like <a href=\\"https://github.com/pull-stream/pull-defer\\">pull-defer</a> but easier for simple cases.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> PullCont = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-cont&apos;</span>)\\n<span class=\\"hljs-comment\\">// or PullCont = requrie(&apos;pull-cont/source&apos;)</span>\\n\\n<span class=\\"hljs-comment\\">//create a pull-stream that reads a directory!</span>\\npull(\\n  PullCont(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">cb</span>) </span>{\\n    fs.readdir(directory, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, ls</span>) </span>{\\n      <span class=\\"hljs-keyword\\">if</span>(err) cb(err)\\n      <span class=\\"hljs-keyword\\">else</span> cb(<span class=\\"hljs-literal\\">null</span>, pull.values(ls))\\n    })\\n  }),\\n  ...\\n)</code></pre>\\n<p>for Source streams, if the continuable returns <em>another</em> continuable, <code>pull-cont</code> will also call that recursively\\nuntil it gets a <code>pull-stream</code> source. I don&apos;t know, this might be useful for something.</p>\\n<h2>Sink &amp; Duplex</h2>\\n<p>You can also use this to create sink and duplex streams.\\n(Unless you are designing a protocol you can probably ignore Duplex)</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Sink = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-cont/sink&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> Duplex = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-cont/duplex&apos;</span>)\\n\\n<span class=\\"hljs-comment\\">//and then complete the continuable with the correct type of stream</span>\\nSink(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">cb</span>) </span>{\\n  cb(<span class=\\"hljs-literal\\">null</span>, pull.drain())\\n})</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"0.1.1","npmName":"pull-cont","category":"combinators"},{"user":"nichoth","name":"pull-catch","path":"nichoth/pull-catch","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/nichoth/pull-catch\\">pull catch</a><div class=\\"contrib\\"></div></h1>\\n<p>Handle errors in pull streams</p>\\n<h2>install</h2>\\n<pre><code>$ npm install pull-catch\\n</code></pre>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> test = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;tape&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> S = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> Catch = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;../&apos;</span>)\\n\\ntest(<span class=\\"hljs-string\\">&apos;catch errors&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n    t.plan(<span class=\\"hljs-number\\">2</span>)\\n    S(\\n        S.error(<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(<span class=\\"hljs-string\\">&apos;test&apos;</span>)),\\n        Catch(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">onErr</span> (<span class=\\"hljs-params\\">err</span>) </span>{\\n            t.equal(err.message, <span class=\\"hljs-string\\">&apos;test&apos;</span>, <span class=\\"hljs-string\\">&apos;should callback with error&apos;</span>)\\n        }),\\n        S.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, resp</span>) </span>{\\n            t.error(err, <span class=\\"hljs-string\\">&apos;should end the stream without error&apos;</span>)\\n        })\\n    )\\n})\\n\\ntest(<span class=\\"hljs-string\\">&apos;return false to pass error&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n    t.plan(<span class=\\"hljs-number\\">1</span>)\\n    S(\\n        S.error(<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(<span class=\\"hljs-string\\">&apos;test&apos;</span>)),\\n        Catch(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err</span>) </span>{\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-literal\\">false</span>\\n        }),\\n        S.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, res</span>) </span>{\\n            t.equal(err.message, <span class=\\"hljs-string\\">&apos;test&apos;</span>, <span class=\\"hljs-string\\">&apos;should pass error in stream&apos;</span>)\\n        })\\n    )\\n})\\n\\ntest(<span class=\\"hljs-string\\">&apos;return truthy to emit one event then end&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n    t.plan(<span class=\\"hljs-number\\">2</span>)\\n    S(\\n        S.error(<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(<span class=\\"hljs-string\\">&apos;test&apos;</span>)),\\n        Catch(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err</span>) </span>{\\n            <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-string\\">&apos;test data&apos;</span>\\n        }),\\n        S.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, res</span>) </span>{\\n            t.error(err, <span class=\\"hljs-string\\">&apos;should not end with error&apos;</span>)\\n            t.deepEqual(res, [<span class=\\"hljs-string\\">&apos;test data&apos;</span>], <span class=\\"hljs-string\\">&apos;should emit one event&apos;</span>)\\n        })\\n    )\\n})\\n\\ntest(<span class=\\"hljs-string\\">&apos;callback is optional&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n    t.plan(<span class=\\"hljs-number\\">1</span>)\\n    S(\\n        S.error(<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(<span class=\\"hljs-string\\">&apos;test&apos;</span>)),\\n        Catch(),\\n        S.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, res</span>) </span>{\\n            t.error(err, <span class=\\"hljs-string\\">&apos;should end stream without error&apos;</span>)\\n        })\\n    )\\n})</code></pre>\\n","contributors":[6],"version":"1.0.0","npmName":"pull-catch","category":"combinators"},{"user":"elavoie","name":"pull-stream-function-to-object","path":"elavoie/pull-stream-function-to-object","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/elavoie/pull-stream-function-to-object\\">pull-stream-function-to-object</a><div class=\\"contrib\\"></div></h1>\\n<p>Converts a pull-stream function into an equivalent object form.</p>\\n<p>Additional methods on the function are also present on the object with their &apos;this&apos; parameter bound to the original function.</p>\\n<p>Useful when you want to access the source and/or the sink directly,\\nor when you do not want to deal with both object and function forms.</p>\\n<pre><code>var pull = require(&apos;pull-stream&apos;)\\nvar toObject = require(&apos;pull-stream-function-to-object&apos;)\\nvar drain = toObject(pull.drain())\\npull(\\n    pull.count(10),\\n    drain.sink,\\n)\\n</code></pre>\\n","contributors":[28],"version":"1.0.1","npmName":"pull-stream-function-to-object","category":"combinators"},{"user":"elavoie","name":"pull-eager-buffer","path":"elavoie/pull-eager-buffer","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/elavoie/pull-eager-buffer\\">pull-eager-buffer</a><div class=\\"contrib\\"></div></h1>\\n<p>Buffer that reads (enqueue) as much data as possible before draining\\n(dequeuing).  It still allows draining of buffered data when reads are delayed.</p>\\n<p>Useful for simulating the behaviour of unsynchronized transport channels, such as WebSockets when used in pull-ws.</p>\\n<h2>Quick Example</h2>\\n<pre><code> var buffer = require(&apos;pull-eager-buffer&apos;)\\n var pull = require(&apos;pull-stream&apos;)\\n \\n // Prints 0,1,2,0,1,2\\n pull(\\n   pull.count(2),\\n   pull.through(console.log),\\n   buffer,\\n   pull.through(console.log),\\n   pull.drain()\\n )\\n</code></pre>\\n","contributors":[28],"version":"1.0.3","npmName":"pull-eager-buffer","category":"combinators"},{"user":"amsross","name":"pull-fmap","path":"amsross/pull-fmap","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/amsross/pull-fmap\\">pull-fmap  </a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>fmap function for mapping over functors in a pull stream</p>\\n</blockquote>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull.values([ Just(<span class=\\"hljs-string\\">&apos;Hello&apos;</span>), Just(<span class=\\"hljs-string\\">&apos;World&apos;</span>), Nothing ])\\n  fmap(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span> =&gt;</span> x.toUpperCase()),\\n  pull.log()\\n)\\n\\n<span class=\\"hljs-comment\\">// Just(HELLO)</span>\\n<span class=\\"hljs-comment\\">// Just(WORLD)</span>\\n<span class=\\"hljs-comment\\">// Nothing</span></code></pre>\\n<h2>Installation</h2>\\n<pre><code class=\\"hljs language-sh\\">$ npm install --save pull-fmap</code></pre>\\n<h2>Usage</h2>\\n<h3><code>fmap = require(&apos;pull-fmap&apos;)</code></h3>\\n<h3><code>fmap((data) =&gt; data)</code></h3>\\n<p><code>fmap(fn)</code> returns a through stream that calls the given <code>fn</code> for each functor&apos;s value, in the same order as before. The type of the returned value should be a functor of the same type:</p>\\n<pre><code>fmap :: Functor f =&gt; f a ~&gt; (a -&gt; b) -&gt; f b\\n</code></pre>\\n<h2>Install</h2>\\n<p>With <a href=\\"https://npmjs.org/\\">npm</a> installed, run</p>\\n<pre><code class=\\"hljs language-sh\\">$ npm install pull-fmap</code></pre>\\n<h2>See Also</h2>\\n<ul>\\n<li><a href=\\"https://github.com/fantasyland/fantasy-land#functor\\"><code>fantasyland/fantasy-land#functor</code></a></li>\\n<li><a href=\\"https://github.com/pull-stream/pull-stream\\"><code>pull-stream/pull-stream</code></a></li>\\n</ul>\\n<h2>License</h2>\\n<p><a href=\\"https://tldrlegal.com/license/mit-license\\">MIT</a></p>\\n","contributors":[29],"version":"0.0.3","npmName":"pull-fmap","category":"combinators"},{"user":"amsross","name":"pull-monad","path":"amsross/pull-monad","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/amsross/pull-monad\\">pull-monad</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://greenkeeper.io/\\"><img src=\\"https://badges.greenkeeper.io/amsross/pull-monad.svg\\" alt=\\"Greenkeeper badge\\"></a></p>\\n<p>Monadic functions for pull-streams</p>\\n<p>These are the methods that make something &quot;monadic.&quot; These functions and their\\ninteractions with each other satisfy the laws laid out in\\n<a href=\\"https://github.com/fantasyland/fantasy-land\\">fantasy-land</a>.</p>\\n<p>Usually these methods exist on the protytpe and are used like so:</p>\\n<pre><code>const lift2 = (f, a, b) =&gt; b.ap(a.map(f))\\n</code></pre>\\n<p>Because these are simply <code>through</code>&apos;s, though, they must be used as such:</p>\\n<pre><code>const lift2 = (f, a, b) =&gt; pull(b, ap(pull(a, map(f))))\\n</code></pre>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">const</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">const</span> { map, <span class=\\"hljs-keyword\\">of</span>, ap, chain } = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-monad&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">const</span> plus1 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span> =&gt;</span> x + <span class=\\"hljs-number\\">1</span>                       <span class=\\"hljs-comment\\">// takes a number and returns a number</span>\\n<span class=\\"hljs-keyword\\">const</span> times7 = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span> =&gt;</span> x * <span class=\\"hljs-number\\">7</span>                      <span class=\\"hljs-comment\\">// takes a number and returns a number</span>\\n<span class=\\"hljs-keyword\\">const</span> triplicate = <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span> =&gt;</span> pull.values([x, x, x]) <span class=\\"hljs-comment\\">// takes a number and returns a stream</span>\\n\\npull(\\n  lift2(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">a</span> =&gt;</span> b =&gt; a + b, <span class=\\"hljs-keyword\\">of</span>(<span class=\\"hljs-number\\">1</span>), <span class=\\"hljs-keyword\\">of</span>(<span class=\\"hljs-number\\">2</span>)),\\n  map(times7),\\n  chain(triplicate),\\n  ap(<span class=\\"hljs-keyword\\">of</span>(plus1)),\\n  pull.collect(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">err, arr</span>) =&gt;</span> <span class=\\"hljs-built_in\\">console</span>.log(arr)))\\n\\n<span class=\\"hljs-comment\\">// =&gt; [22, 22, 22]</span></code></pre>\\n","contributors":[29,30],"version":"0.0.0-development","npmName":"pull-monad","category":"combinators"},{"user":"amsross","name":"pull-tap","path":"amsross/pull-tap","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/amsross/pull-tap\\">pull-tap</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://greenkeeper.io/\\"><img src=\\"https://badges.greenkeeper.io/amsross/pull-tap.svg\\" alt=\\"Greenkeeper badge\\"></a></p>\\n<p>Sync and async side-effectful functions.</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">const</span> { pull, map, values, collect, } = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">const</span> { tap, asyncTap } = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-tap&apos;</span>)\\n\\npull(\\n  values([<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>]),\\n  map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span> =&gt;</span> x + <span class=\\"hljs-number\\">1</span>),\\n  tap(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span> =&gt;</span> <span class=\\"hljs-built_in\\">console</span>.log(x * <span class=\\"hljs-number\\">2</span>)), <span class=\\"hljs-comment\\">// log some changed value, but return the source</span>\\n  asyncTap(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span> =&gt;</span> pull(           <span class=\\"hljs-comment\\">// do something async, but return the source value</span>\\n    someAsyncTask(x),\\n    map(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span> =&gt;</span> <span class=\\"hljs-built_in\\">console</span>.log(x)))), <span class=\\"hljs-comment\\">// log the async result value</span>\\n  collect(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">err, arr</span>) =&gt;</span> <span class=\\"hljs-built_in\\">console</span>.log(arr)))\\n\\n<span class=\\"hljs-comment\\">// =&gt; 4</span>\\n<span class=\\"hljs-comment\\">// =&gt; 2</span>\\n<span class=\\"hljs-comment\\">// =&gt; 6</span>\\n<span class=\\"hljs-comment\\">// =&gt; 3</span>\\n<span class=\\"hljs-comment\\">// =&gt; 8</span>\\n<span class=\\"hljs-comment\\">// =&gt; 4</span>\\n<span class=\\"hljs-comment\\">// =&gt; [2, 3, 4]</span></code></pre>\\n","contributors":[29,30],"version":"0.0.0-development","npmName":"pull-tap","category":"combinators"},{"user":"nichoth","name":"pull-flat-merge","path":"nichoth/pull-flat-merge","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/nichoth/pull-flat-merge\\">pull flat merge</a><div class=\\"contrib\\"></div></h1>\\n<p>A transform that takes a stream of streams and emits their values, in the order they arrive. This is in contrast to <code>.flatten</code>, which keeps the original order.</p>\\n<h2>example</h2>\\n<p>join:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> test = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;tape&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> S = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> join = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-flat-merge&apos;</span>)\\n\\ntest(<span class=\\"hljs-string\\">&apos;flat merge&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n    t.plan(<span class=\\"hljs-number\\">2</span>)\\n    <span class=\\"hljs-keyword\\">var</span> ss = S.values([\\n        S.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]),\\n        S.values([<span class=\\"hljs-string\\">&apos;a&apos;</span>, <span class=\\"hljs-string\\">&apos;b&apos;</span>, <span class=\\"hljs-string\\">&apos;c&apos;</span>])\\n    ])\\n\\n    S(\\n        ss,\\n        join(),\\n        S.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, evs</span>) </span>{\\n            t.error(err)\\n            t.deepEqual(evs, [<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-string\\">&apos;a&apos;</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-string\\">&apos;b&apos;</span>,<span class=\\"hljs-number\\">3</span>,<span class=\\"hljs-string\\">&apos;c&apos;</span>], <span class=\\"hljs-string\\">&apos;should emit the events&apos;</span>)\\n        })\\n    )\\n})</code></pre>\\n<p>chain:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-comment\\">// this is equivalent to `map` followed by `join` </span>\\n<span class=\\"hljs-keyword\\">var</span> S = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> chain = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-flat-merge/chain&apos;</span>)\\n\\nS(\\n    S.values([<span class=\\"hljs-number\\">1</span>,<span class=\\"hljs-number\\">2</span>,<span class=\\"hljs-number\\">3</span>]),\\n    chain(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">n</span>) </span>{\\n        <span class=\\"hljs-keyword\\">return</span> S.once(n)\\n    }),\\n    S.log()\\n)</code></pre>\\n","contributors":[6],"version":"2.0.2","npmName":"pull-flat-merge","category":"combinators"},{"user":"jdvorak","name":"pull-offset-limit","path":"jdvorak/pull-offset-limit","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/jdvorak/pull-offset-limit\\">pull-offset-limit</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://npmjs.org/package/pull-offset-limit\\"></a> <a href=\\"https://travis-ci.org/JDvorak/pull-offset-limit\\"></a> <a href=\\"https://codecov.io/github/JDvorak/pull-offset-limit\\"></a>\\n<a href=\\"https://npmjs.org/package/pull-offset-limit\\"></a> <a href=\\"https://github.com/feross/standard\\"></a></p>\\n<p>A pull-stream that filters until X elements, and stops streaming after Y elements. Useful for pagination purposes.</p>\\n<h2>Usage</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">const</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">const</span> split = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-split&apos;</span>)\\n<span class=\\"hljs-keyword\\">const</span> offsetLimit = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-offset-limit&apos;</span>)\\n \\npull(\\n  textStream, <span class=\\"hljs-comment\\">// some text stream</span>\\n  split(), <span class=\\"hljs-comment\\">// split on new lines</span>\\n  offsetLimit(<span class=\\"hljs-number\\">5</span>, <span class=\\"hljs-number\\">20</span>), <span class=\\"hljs-comment\\">// after 5 lines, take 20</span>\\n  output\\n)</code></pre>\\n<h2>API</h2>\\n<h3></h3>\\n<h3><code>offsetLimit = require(&apos;pull-offset-limit&apos;)(offset, limit, onLimit)</code></h3>\\n<p>Create a new offsetLimit through stream.</p>\\n<ul>\\n<li><strong>offset:</strong> if set, filters stream until offset is reached</li>\\n<li><strong>limit:</strong> if set, stops stream when limit is reached</li>\\n<li><strong>onLimit:</strong> if set, runs when limit is reached</li>\\n</ul>\\n<h2>Installation</h2>\\n<pre><code class=\\"hljs language-sh\\">$ npm install pull-offset-limit</code></pre>\\n<h2>License</h2>\\n<p><a href=\\"https://tldrlegal.com/license/mit-license\\">MIT</a></p>\\n","contributors":[31],"version":"1.1.1","npmName":"pull-offset-limit","category":"combinators"},{"user":"dominictarr","name":"pull-group","path":"dominictarr/pull-group","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-group\\">pull-group</a><div class=\\"contrib\\"></div></h1>\\n<p>pull-stream to group incoming data into arrays of max length <code>length</code>,\\n(the last item may be shorter than <code>length</code>)</p>\\n<p>Useful for data you can handle in batches.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Group = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-group&apos;</span>)\\npull(\\n  pull.count(<span class=\\"hljs-number\\">100</span>), <span class=\\"hljs-comment\\">//0, 1, 2, 3, 4, 5, ...</span>\\n  Group(<span class=\\"hljs-number\\">5</span>),\\n  pull.log() <span class=\\"hljs-comment\\">// [0, 1,2,3,4], [5, 6,7,8,9], ...</span>\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.0.1","npmName":"pull-group","category":"combinators"},{"user":"pull-stream","name":"pull-pushable","path":"pull-stream/pull-pushable","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-pushable\\">pull-pushable</a><div class=\\"contrib\\"></div></h1>\\n<p>A pull-stream with a pushable interface.</p>\\n<p>Use this when you really can&apos;t pull from your source.\\nFor example, often I like to have a &quot;live&quot; stream.\\nThis would read a series of data, first old data,\\nbut then stay open and read new data as it comes in.</p>\\n<p>In that case, the new data needs to be queued up while the old data is read,\\nand also, the rate things are pushed into the queue doesn&apos;t affect the rate of reads.</p>\\n<p>If there is no realtime aspect to this stream, it&apos;s likely that you don&apos;t need pushable.\\nInstead try just using <code>pull.values(array)</code>.</p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Pushable = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-pushable&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull     = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> p = Pushable()\\n\\npull(p, pull.drain(<span class=\\"hljs-built_in\\">console</span>.log))\\n\\np.push(<span class=\\"hljs-number\\">1</span>)\\np.end()</code></pre>\\n<p>Also, can provide a listener for when the stream is closed.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Pushable = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-pushable&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull     = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> p = Pushable(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err</span>) </span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;stream closed!&apos;</span>)\\n})\\n\\n<span class=\\"hljs-comment\\">//read 3 times then abort.</span>\\npull(p, pull.take(<span class=\\"hljs-number\\">3</span>), pull.drain(<span class=\\"hljs-built_in\\">console</span>.log))\\n\\np.push(<span class=\\"hljs-number\\">1</span>)\\np.push(<span class=\\"hljs-number\\">2</span>)\\np.push(<span class=\\"hljs-number\\">3</span>)\\np.push(<span class=\\"hljs-number\\">4</span>) <span class=\\"hljs-comment\\">//stream will be aborted before this is output</span></code></pre>\\n<p>When giving the stream away and you don&apos;t want the user to have the <code>push</code>/<code>end</code> functions,\\nyou can pass a <code>separated</code> option.  It returns <code>{ push, end, source }</code>.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">createStream</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n  <span class=\\"hljs-keyword\\">var</span> p = Pushable(<span class=\\"hljs-literal\\">true</span>) <span class=\\"hljs-comment\\">// optionally pass `onDone` after it</span>\\n\\n  somethingAsync(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">err, data</span>) =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">if</span> (err) <span class=\\"hljs-keyword\\">return</span> p.end(err)\\n    p.push(data)\\n  })\\n\\n  <span class=\\"hljs-keyword\\">return</span> p.source\\n}\\n\\n<span class=\\"hljs-keyword\\">var</span> stream = createStream()\\n<span class=\\"hljs-comment\\">// stream.push === undefined</span></code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,3,10,1],"version":"2.1.1","npmName":"pull-pushable","category":"real-time"},{"user":"pull-stream","name":"pull-notify","path":"pull-stream/pull-notify","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-notify\\">pull-notify</a><div class=\\"contrib\\"></div></h1>\\n<p>Notify many listeners via pull-streams.</p>\\n<p>you could use when you might otherwise use an event emitter.\\nWhy not just use an event emitter? EventEmitters have a weird\\nsecurity contract: anyone who can listen can also emit,\\nand they can emit or listen to any events!</p>\\n<p>Instead, events should travel down a single channel,\\nand the ability to emit an event should be separated from\\nthe ability to listen.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Notify = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-notify&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> notify = Notify()\\n\\n<span class=\\"hljs-comment\\">//create a pull stream that listens on events.</span>\\n<span class=\\"hljs-comment\\">//it will eventually get all events.</span>\\npull(notify.listen(), pull.drain(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">evt</span>) =&gt;</span> <span class=\\"hljs-built_in\\">console</span>.log(evt)))\\n\\nnotify(<span class=\\"hljs-string\\">&apos;hello&apos;</span>) <span class=\\"hljs-comment\\">//emit an event.</span>\\n\\nnotify.end() <span class=\\"hljs-comment\\">//tell all listeners it&apos;s over.</span></code></pre>\\n<p>listers can abort (using the normal pull-stream abort),\\nand that will remove them from the list.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,3,32],"version":"0.1.1","npmName":"pull-notify","category":"real-time"},{"user":"pull-stream","name":"pull-live","path":"pull-stream/pull-live","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-live\\">pull-live</a><div class=\\"contrib\\"></div></h1>\\n<p>construct a pull-stream for reading from a writable source,\\ncan read old records, new (live) records, or both.</p>\\n<p>to be used by <a href=\\"https://github.com/pull-stream/pull-level\\">pull-level</a>,\\n<a href=\\"https://github.com/dominictarr/multiblob\\">multiblobs</a>, and\\n<a href=\\"https://github.com/ssbc/secure-scuttlebutt\\">secure-scuttlebutt</a>.\\n<code>pull-live</code> is generic, and easy to adapt to a new case.</p>\\n<h2>api: createLive(createSource(opts), createLive(opts)) =&gt; createLiveStream(opts)</h2>\\n<p>createLive takes two functions, <code>createSource</code> (which returns a source\\nstream of the stored data) and <code>createLive</code> which returns a stream\\nof the live data. A function that takes <code>opts</code> and is returned.</p>\\n<p>if <code>opts.live</code> is set to true, the stream will only read the old data\\n(from <code>createSource</code>) and then the new data (from <code>createLive</code>) with\\none item <code>{sync: true}</code> to mark when the old data has finished.</p>\\n<p>If <code>opts.sync === false</code> then the sync item will dropped.</p>\\n<p>if <code>opts.live</code> is  true (default: <code>false</code>) the live data is included.\\nif <code>opts.old</code> is false (default: <code>true</code>) the output will not include\\nthe old data. If <code>live</code> and <code>old</code> are both false, an error is thrown.</p>\\n<p>the only valid options are <code>{live: true, old: false}</code> <code>{live: false, old: true}</code>\\nand <code>{live: true, old: true}</code></p>\\n<p>I recomment using <a href=\\"https://github.com/pull-stream/pull-notify\\">pull-notify</a>\\nto implement <code>createLive</code>.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> MyLiveStream = createLive(createSource, createLive)\\n\\npull(MyLiveStrea({<span class=\\"hljs-attr\\">live</span>:..., <span class=\\"hljs-attr\\">old</span>:...}),...)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.0.1","npmName":"pull-live","category":"real-time"},{"user":"dominictarr","name":"pull-throttle","path":"dominictarr/pull-throttle","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-throttle\\">pull-throttle</a><div class=\\"contrib\\"></div></h1>\\n<p>throttle a pull-stream. If things are coming in faster\\nthan a given timeout, only keep the latest, reducing\\nthe rate of the stream.</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  source,\\n  Throttle(<span class=\\"hljs-number\\">100</span>), <span class=\\"hljs-comment\\">//not more than one item per 100 ms!</span>\\n  sink\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,33],"version":"1.0.0","npmName":"pull-throttle","category":"real-time"},{"user":"pull-stream","name":"pull-glob","path":"pull-stream/pull-glob","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-glob\\">pull-glob</a><div class=\\"contrib\\"></div></h1>\\n<p>streaming extended glob.</p>\\n<p>use with <a href=\\"https://github.com/dominictarr/pull-stream\\">pull-stream</a></p>\\n<h2>examples</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> glob = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-glob&apos;</span>)\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">glob_log</span> (<span class=\\"hljs-params\\">name, pattern</span>) </span>{\\n  pull(glob(pattern), pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, ary</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">throw</span> err\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;name:&apos;</span>, name, <span class=\\"hljs-string\\">&apos;pattern:&apos;</span>, pattern)\\n    <span class=\\"hljs-built_in\\">console</span>.log(ary)\\n  })\\n}\\n\\n\\nglob_log(<span class=\\"hljs-string\\">&apos;current dir&apos;</span>, <span class=\\"hljs-string\\">&apos;.&apos;</span>)\\nglob_log(<span class=\\"hljs-string\\">&apos;js in current dir&apos;</span>, <span class=\\"hljs-string\\">&apos;*.js&apos;</span>)\\nglob_log(<span class=\\"hljs-string\\">&apos;everything under current dir&apos;</span>, <span class=\\"hljs-string\\">&apos;**&apos;</span>)\\nglob_log(<span class=\\"hljs-string\\">&apos;all js under current dir&apos;</span>, <span class=\\"hljs-string\\">&apos;**/*.js&apos;</span>)\\nglob_log(<span class=\\"hljs-string\\">&apos;parent directories&apos;</span>, <span class=\\"hljs-string\\">&apos;...&apos;</span>)\\nglob_log(<span class=\\"hljs-string\\">&apos;hidden files&apos;</span>, <span class=\\"hljs-string\\">&apos;.../.*&apos;</span>)\\nglob_log(<span class=\\"hljs-string\\">&apos;available modules&apos;</span>, <span class=\\"hljs-string\\">&apos;.../node_modules/*&apos;</span>)\\nglob_log(<span class=\\"hljs-string\\">&apos;local package files&apos;</span>, <span class=\\"hljs-string\\">&apos;.../{package,component}.json&apos;</span>)</code></pre>\\n<h2>stopping early</h2>\\n<p>because this module uses pull-streams, it&apos;s lazy,\\nso you can do queries like the following:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-comment\\">//find the first package.json in a parent directory.</span>\\npull(glob(<span class=\\"hljs-string\\">&apos;.../package.json&apos;</span>), pull.take(<span class=\\"hljs-number\\">1</span>), log())</code></pre>\\n<p>And you will retrive only the first item, and <em>will\\nnot do any extra IO</em>. This is hugely useful when\\ndoing a large traversal...</p>\\n<h2>collect node_module tree</h2>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  glob(<span class=\\"hljs-string\\">&apos;**/node_modules/*/package.json&apos;</span>),\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">e, arr</span>) </span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(arr)\\n  })\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,34],"version":"1.0.7","npmName":"pull-glob","category":"file system and databases"},{"user":"pull-stream","name":"pull-level","path":"pull-stream/pull-level","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-level\\">pull-level</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://github.com/dominictarr/pull-stream\\">pull-stream</a> interface to\\n<a href=\\"https://github.com/rvagg/node-levelup\\">levelup</a></p>\\n<h2>Example - reading</h2>\\n<p>read items in database.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pl = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-level&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> db = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;levelup&apos;</span>)(<span class=\\"hljs-string\\">&apos;/tmp/pull-level-example&apos;</span>)\\n\\npull(pl.read(db), pull.collect(<span class=\\"hljs-built_in\\">console</span>.log))</code></pre>\\n<p>read items in database, plus realtime changes</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pl.read(db, {<span class=\\"hljs-attr\\">live</span>: <span class=\\"hljs-literal\\">true</span>}),\\n  <span class=\\"hljs-comment\\">//log data as it comes,</span>\\n  <span class=\\"hljs-comment\\">//because tail will keep the connection open</span>\\n  <span class=\\"hljs-comment\\">//so we&apos;ll never see the end otherwise.</span>\\n  pull.through(<span class=\\"hljs-built_in\\">console</span>.log),\\n  <span class=\\"hljs-comment\\">//note, pull-streams will not drain unless something is</span>\\n  <span class=\\"hljs-comment\\">//pulling the data through, so we have to add drain</span>\\n  <span class=\\"hljs-comment\\">//even though the data we want is coming from pull.through()</span>\\n  pull.drain()\\n)</code></pre>\\n<p>If you just want the realtime inserts,\\nuse <code>live</code></p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pl.live(db, {<span class=\\"hljs-attr\\">live</span>: <span class=\\"hljs-literal\\">true</span>}),\\n  pull.through(<span class=\\"hljs-built_in\\">console</span>.log),\\n  pull.drain()\\n)</code></pre>\\n<h2>Example - writing</h2>\\n<p>To write, pipe batch changes into <code>write</code></p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull.values([\\n    {<span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-attr\\">value</span>: <span class=\\"hljs-string\\">&apos;zero&apos;</span>, <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">&apos;put&apos;</span>},\\n    {<span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-attr\\">value</span>: <span class=\\"hljs-string\\">&apos;one&apos;</span>,  <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">&apos;put&apos;</span>},\\n    {<span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-attr\\">value</span>: <span class=\\"hljs-string\\">&apos;two&apos;</span>,  <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">&apos;put&apos;</span>},\\n  ]),\\n  pl.write(db)\\n)</code></pre>\\n<p>If you are lazy/busy, you can leave off <code>type</code>.\\nIn that case, if <code>value</code> is non-null, the change\\nis considered a <code>put</code> else, a <code>del</code>.</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull.values([\\n    {<span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-attr\\">value</span>: <span class=\\"hljs-string\\">&apos;zero&apos;</span>},\\n    {<span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-attr\\">value</span>: <span class=\\"hljs-string\\">&apos;one&apos;</span>},\\n    {<span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-attr\\">value</span>: <span class=\\"hljs-string\\">&apos;two&apos;</span>},\\n  ]), \\n  pl.write(db)\\n)</code></pre>\\n<h2>Example - indexes!</h2>\\n<p>With pull-level it&apos;s easy to create indexes.\\njust save a pointer to the key.</p>\\n<p>like this:</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull.values([\\n    {<span class=\\"hljs-attr\\">key</span>: key, <span class=\\"hljs-attr\\">value</span>: VALUE, <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">&apos;put&apos;</span>},\\n    {<span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-string\\">&apos;~INDEX~&apos;</span> + VALUE.prop, <span class=\\"hljs-attr\\">value</span>: key,  <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">&apos;put&apos;</span>},\\n  ]),\\n  pl.write(db)\\n)</code></pre>\\n<p>then, when you want to do a <code>read</code>, use <code>asyncMap</code></p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pl.read(db, {<span class=\\"hljs-attr\\">min</span>: <span class=\\"hljs-string\\">&apos;~INDEX~&apos;</span>, <span class=\\"hljs-attr\\">max</span>: <span class=\\"hljs-string\\">&apos;~INDEX~~&apos;</span>})\\n  pull.asyncMap(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">e, cb</span>) </span>{\\n    db.get(e.value, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">value</span>) </span>{\\n      cb(<span class=\\"hljs-literal\\">null</span>, {<span class=\\"hljs-attr\\">key</span>: e.value, <span class=\\"hljs-attr\\">value</span>: value})\\n    })\\n  }),\\n  pull.collect(<span class=\\"hljs-built_in\\">console</span>.log)\\n)</code></pre>\\n<h2>Example realtime aggregation</h2>\\n<p>We want to keep a realtime count of everything in the database.\\nWhen ever something is inserted, we increment. But, we need\\nto check the records that are <em>currently</em> in the database.</p>\\n<p>Since it takes some time to scan the database, we need to make sure\\nwe have done that before giving an answer. We can read it all with\\none stream, using <code>{sync: true}</code> to be notified of when we have read out all the old records.</p>\\n<p>First all the old records are read from the non-live stream,\\nthen you get one <code>{sync: true}</code> element, then all the new item.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> sum = <span class=\\"hljs-number\\">0</span>, ready = <span class=\\"hljs-literal\\">false</span>, waiting = []\\n\\n<span class=\\"hljs-comment\\">//call get count to know s</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">getSum</span> (<span class=\\"hljs-params\\">cb</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(!ready) waiting.push(cb)\\n  <span class=\\"hljs-keyword\\">else</span> cb(<span class=\\"hljs-literal\\">null</span>, sum)\\n}\\n\\npull(\\n  pl.read(db, {<span class=\\"hljs-attr\\">sync</span>: <span class=\\"hljs-literal\\">true</span>}),\\n  pull.drain(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">op</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(op.sync) {\\n      <span class=\\"hljs-comment\\">//if we see a data element with this it means</span>\\n      ready = <span class=\\"hljs-literal\\">true</span>\\n      <span class=\\"hljs-keyword\\">while</span>(waiting.length) waiting.shift()(<span class=\\"hljs-literal\\">null</span>, count)\\n    }\\n    <span class=\\"hljs-comment\\">//increment our counter!</span>\\n    <span class=\\"hljs-keyword\\">if</span>(<span class=\\"hljs-built_in\\">Number</span>.isFinite(+op.value.amount)) <span class=\\"hljs-comment\\">//filter out non numbers &amp; NaN.</span>\\n      sum += op.value.amount\\n  })\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"2.0.4","npmName":"pull-level","category":"file system and databases"},{"user":"DamonOehlman","name":"pull-file","path":"DamonOehlman/pull-file","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/DamonOehlman/pull-file\\">pull-file</a><div class=\\"contrib\\"></div></h1>\\n<p>a pull-streaming file reader, build directly on the low level stream functions.\\nby passing node&apos;s fs streams.</p>\\n<p><a href=\\"https://nodei.co/npm/pull-file/\\"></a></p>\\n<p><a href=\\"https://travis-ci.org/pull-stream/pull-file\\"></a></p>\\n<h2>Example Usage</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> file = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-file&apos;</span>);\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>);\\n<span class=\\"hljs-keyword\\">var</span> path = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;path&apos;</span>);\\n<span class=\\"hljs-keyword\\">var</span> inputFile = path.resolve(__dirname, <span class=\\"hljs-string\\">&apos;../test/assets/ipsum.txt&apos;</span>);\\n\\npull(\\n  file(inputFile, { <span class=\\"hljs-attr\\">bufferSize</span>: <span class=\\"hljs-number\\">40</span> }),\\n  pull.take(<span class=\\"hljs-number\\">4</span>),\\n  pull.drain(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">buffer</span>) </span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(buffer.toString());\\n  })\\n);</code></pre>\\n<h2>options</h2>\\n<p>this supports all the options that node&apos;s <a href=\\"https://nodejs.org/dist/latest-v6.x/docs/api/fs.html#fs_fs_createreadstream_path_options\\">fs.createReadStream</a> supports,\\nand <em>also</em> this supports a <code>live: true</code> property which will keep the stream open and wait for appends\\nwhen it gets to the end.</p>\\n<h2>License(s)</h2>\\n<h3>MIT</h3>\\n<p>Copyright (c) 2014 Damon Oehlman <a href=\\"http://github.com/DamonOehlman/pull-file/blob/master/mailto:damon.oehlman@gmail.com\\">damon.oehlman@gmail.com</a></p>\\n<p>Permission is hereby granted, free of charge, to any person obtaining\\na copy of this software and associated documentation files (the\\n&apos;Software&apos;), to deal in the Software without restriction, including\\nwithout limitation the rights to use, copy, modify, merge, publish,\\ndistribute, sublicense, and/or sell copies of the Software, and to\\npermit persons to whom the Software is furnished to do so, subject to\\nthe following conditions:</p>\\n<p>The above copyright notice and this permission notice shall be\\nincluded in all copies or substantial portions of the Software.</p>\\n<p>THE SOFTWARE IS PROVIDED &apos;AS IS&apos;, WITHOUT WARRANTY OF ANY KIND,\\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>\\n","contributors":[35,0],"version":"1.0.0","npmName":"pull-file","category":"file system and databases"},{"user":"dominictarr","name":"pull-write","path":"dominictarr/pull-write","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-write\\">pull-write</a><div class=\\"contrib\\"></div></h1>\\n<p>base class for creating generic pull-sinks\\nthat write to some device via an async call.</p>\\n<h2>Write(asyncWrite, reduce, max, cb)</h2>\\n<h3>asyncWrite(ary, cb)</h3>\\n<p>async function called with an array of items to output.\\nThis function will only ever be called once at a time (per instance),\\nand while it is working <code>pull-write</code> will buffer any subsequent writes,\\nuntil the buffer has the length of at most <code>max</code>,\\nor <code>asyncWrite</code> has called back.</p>\\n<h3>reduce (queue, item)</h3>\\n<p><code>queue</code> is the current backlog of data the <code>pull-write</code> is getting ready to write.\\n<code>item</code> is the next incoming item. <code>reduce</code> must add <code>item</code> into <code>queue</code>\\nin whatever way is appropiate. If <code>queue</code> is empty, then it will be <code>null</code>.\\nYour <code>reduce</code> function must handle that case and set an initial value.</p>\\n<p>by default, <code>reduce</code> will be a function that initializes a buffer,\\nand then pushes the new items onto that buffer, this means <code>max</code> will be\\ncompared to the number of items in that buffer.</p>\\n<h3>max</h3>\\n<p>A number, when the <code>.length</code> property of the <code>queue</code> returned by <code>reduce</code>\\ngets this big <code>pull-write</code> will stop reading more, until asyncWrite\\ncalls back.</p>\\n<h2>example</h2>\\n<p>Suppose we want a to take a stream of values from one leveldb,\\nand write it to another. If we have the timestamp they where written\\nto the first, we can track that in the second, then it&apos;s easy to keep\\nthem both up to date. We just need to always output latest ts separately.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Write = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-write&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> LevelWrite = <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">db, cb</span>) </span>{\\n  <span class=\\"hljs-keyword\\">var</span> max = <span class=\\"hljs-number\\">100</span>\\n  <span class=\\"hljs-keyword\\">return</span> Write(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">ary, cb</span>) </span>{\\n    db.batch(ary, cb)\\n  }, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">queue, data</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(!queue)\\n      queue = [{<span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-string\\">&apos;~meta~ts&apos;</span>, <span class=\\"hljs-attr\\">value</span>: <span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">&apos;put&apos;</span>}]\\n    queue.push({<span class=\\"hljs-attr\\">key</span>:data.key, <span class=\\"hljs-attr\\">value</span>: data.value, <span class=\\"hljs-attr\\">type</span>: <span class=\\"hljs-string\\">&apos;put&apos;</span>})\\n    <span class=\\"hljs-comment\\">//the record of the current sequence is always the first value</span>\\n    <span class=\\"hljs-comment\\">//in the batch, so we can update it easily.</span>\\n    queue[<span class=\\"hljs-number\\">0</span>].value = data.ts\\n    <span class=\\"hljs-keyword\\">return</span> queue\\n  }, max, cb)\\n}</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.1.4","npmName":"pull-write","category":"file system and databases"},{"user":"dominictarr","name":"pull-write-file","path":"dominictarr/pull-write-file","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-write-file\\">pull-write-file</a><div class=\\"contrib\\"></div></h1>\\n<p>pull-stream version of fs.createWriteStream</p>\\n<p>currently really simple and does not yet support all fs.createWriteStream options yet.</p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Write = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-write-stream&apos;</span>)\\n\\npull(\\n  source, <span class=\\"hljs-comment\\">//must be buffers (sorry, strings not working yet!)</span>\\n  Write(pathToFile, {}, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err</span>) </span>{\\n    <span class=\\"hljs-comment\\">//callback is called once write is complete,</span>\\n    <span class=\\"hljs-comment\\">//and file descriptor is closed</span>\\n  })\\n)</code></pre>\\n<h2>Performance</h2>\\n<p>For large buffers this is currently as fast as node&apos;s streams,\\nbut for lots of small buffers it&apos;s a little less.\\nNode uses the fs binding&apos;s <code>writev</code> to pass many buffers to the kernel simutaniously.</p>\\n<p>TODO: benchmarks with graphs comparing node streams and pull streams.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,36,37],"version":"0.2.4","npmName":"pull-write-file","category":"file system and databases"},{"user":"pull-stream","name":"pull-watch","path":"pull-stream/pull-watch","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-watch\\">pull-watch</a><div class=\\"contrib\\"></div></h1>\\n<p>fs.watch with pull streams using <a href=\\"https://github.com/paulmillr/chokidar\\"><code>chokidar</code></a></p>\\n<pre><code class=\\"hljs language-shell\\">npm install --save pull-watch</code></pre>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> watch = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-watch&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> watcher = watch(<span class=\\"hljs-string\\">&apos;./&apos;</span>)\\n\\npull(\\n  watcher.listen(),\\n  pull.drain(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">event</span>) </span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;event&apos;</span>, event)\\n  }, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err</span>) </span>{\\n    watcher.end()\\n  })\\n)</code></pre>\\n<h2>usage</h2>\\n<h3><code>watch = require(&apos;pull-watch&apos;)</code></h3>\\n<h3><code>watcher = watch(paths,[ options,] onReady)</code></h3>\\n<p>where <code>paths</code> is a files, dirs to be watched recursively, or glob patterns.</p>\\n<p>optional options are for <a href=\\"https://github.com/paulmillr/chokidar#api\\"><code>chokidar</code></a>.</p>\\n<p>watch returns a <a href=\\"https://github.com/pull-stream/pull-notify\\"><code>pull-notify</code></a> stream with properties:</p>\\n<ul>\\n<li><code>listen()</code>: function to create a pull source stream of the file watcher events</li>\\n<li><code>abort(err)</code>: function to end the file watcher and signal an error to all respective streams</li>\\n<li><code>end()</code>: function to end the file watcher and signal completion to all respective streams</li>\\n<li><code>add(path)</code>: function to add file path to file watcher</li>\\n</ul>\\n<p><code>onReady(watcher)</code> is called on &quot;ready&quot; event.</p>\\n<h2>license</h2>\\n<p>The Apache License</p>\\n<p>Copyright &#xA9; 2016 Michael Williams</p>\\n<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\\nyou may not use this file except in compliance with the License.\\nYou may obtain a copy of the License at</p>\\n<pre><code>http://www.apache.org/licenses/LICENSE-2.0\\n</code></pre>\\n<p>Unless required by applicable law or agreed to in writing, software\\ndistributed under the License is distributed on an &quot;AS IS&quot; BASIS,\\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\nSee the License for the specific language governing permissions and\\nlimitations under the License.</p>\\n","contributors":[3],"version":"1.1.1","npmName":"pull-watch","category":"file system and databases"},{"user":"ipfs","name":"interface-pull-blob-store","path":"ipfs/interface-pull-blob-store","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/ipfs/interface-pull-blob-store\\">interface-pull-blob-store</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"http://ipn.io\\"></a>\\n<a href=\\"http://ipfs.io/\\"></a>\\n<a href=\\"http://webchat.freenode.net/?channels=%2523ipfs\\"></a>\\n<a href=\\"https://coveralls.io/github/ipfs/interface-pull-blob-store?branch=master\\"></a>\\n<a href=\\"https://travis-ci.org/ipfs/interface-pull-blob-store\\"></a>\\n<a href=\\"https://circleci.com/gh/ipfs/interface-pull-blob-store\\"></a>\\n<a href=\\"https://david-dm.org/ipfs/interface-pull-blob-store\\"></a> <a href=\\"https://github.com/feross/standard\\"></a></p>\\n<blockquote>\\n<p>Test suite for pull-blob-stores</p>\\n</blockquote>\\n<p>A test suite and interface that can be used to implement streaming file (<a href=\\"https://en.wikipedia.org/wiki/Binary_large_object\\">blob</a>) storage modules for various storage backends and platforms. All streaming happens through the use of  <a href=\\"https://pull-stream.github.io/\\">pull-stream</a>s.</p>\\n<h3>Modules that use this</h3>\\n<ul>\\n<li><a href=\\"https://github.com/ipfs/js-fs-pull-blob-store\\">fs-pull-blob-store</a></li>\\n<li><a href=\\"https://github.com/ipfs/js-idb-pull-blob-store\\">idb-pull-blob-store</a></li>\\n<li><a href=\\"https://github.com/ipfs/js-level-pull-blob-store\\">level-pull-blob-store</a></li>\\n</ul>\\n<h2>Table of Contents</h2>\\n<ul>\\n<li><a href=\\"#install\\">Install</a></li>\\n<li><a href=\\"#usage\\">Usage</a></li>\\n<li>\\n<p><a href=\\"#api\\">API</a></p>\\n<ul>\\n<li><a href=\\"#storewritekey-cb\\">store.write(key, cb)</a></li>\\n<li><a href=\\"#storereadkey\\">store.read(key)</a></li>\\n<li><a href=\\"#storeexistskey-cb\\">store.exists(key, cb)</a></li>\\n<li><a href=\\"#storeremovekey-cb\\">store.remove(key, cb)</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#contribute\\">Contribute</a></li>\\n<li><a href=\\"#license\\">License</a></li>\\n</ul>\\n<h2>Install</h2>\\n<p>TODO</p>\\n<h2>Usage</h2>\\n<p>TODO</p>\\n<h2>API</h2>\\n<p>A valid blob store should implement the following APIs. There is a reference in-memory implementation available at <code>src/index.js</code> in this repo.</p>\\n<h3>store.write(key, cb)</h3>\\n<p>This method should return a sink, which when written to writes the data to the blob store.</p>\\n<h3>store.read(key)</h3>\\n<p>This method should return a source that emits blob data from the underlying blob store or emits an error if the blob does not exist or if there was some other error during the read.</p>\\n<h3>store.exists(key, cb)</h3>\\n<p>This checks if a blob exists in the store.</p>\\n<h3>store.remove(key, cb)</h3>\\n<p>This method should remove a blob from the store.</p>\\n<h2>Contribute</h2>\\n<p><a href=\\"https://github.com/ipfs/community/blob/master/contributing.md\\"><img src=\\"https://cdn.rawgit.com/jbenet/contribute-ipfs-gif/master/img/contribute.gif\\" alt=\\"\\"></a></p>\\n<p>If you would like to contribute code to this repository, please dive in! Check out <a href=\\"http://github.com/ipfs/interface-pull-blob-store/blob/master///github.com/ipfs/interface-pull-blob-store/issues\\">the issues</a>. Clicking the banner above will lead you to the general <a href=\\"https://github.com/ipfs/community/blob/master/contributing.md\\">IPFS community contribute guidelines</a>, if you would like to contribute in other ways.</p>\\n<p>Small note: If editing the Readme, please conform to the <a href=\\"https://github.com/RichardLitt/standard-readme\\">standard-readme</a> specification.</p>\\n<h2>License</h2>\\n<p><a href=\\"http://github.com/ipfs/interface-pull-blob-store/blob/master/LICENSE\\">MIT</a></p>\\n","contributors":[12,38,39,40,41],"version":"0.6.0","npmName":"interface-pull-blob-store","category":"file system and databases"},{"user":"ipfs","name":"js-fs-pull-blob-store","path":"ipfs/js-fs-pull-blob-store","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/ipfs/js-fs-pull-blob-store\\">fs-pull-blob-store</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"http://ipn.io\\"></a>\\n<a href=\\"http://ipfs.io/\\"></a>\\n<a href=\\"http://webchat.freenode.net/?channels=%2523ipfs\\"></a>\\n<a href=\\"https://coveralls.io/github/ipfs/js-fs-pull-blob-store?branch=master\\"></a>\\n<a href=\\"https://travis-ci.org/ipfs/js-fs-pull-blob-store\\"></a>\\n<a href=\\"https://circleci.com/gh/ipfs/js-fs-pull-blob-store\\"></a>\\n<a href=\\"https://david-dm.org/ipfs/js-fs-pull-blob-store\\"></a> <a href=\\"https://github.com/feross/standard\\"></a></p>\\n<blockquote>\\n<p><a href=\\"https://github.com/ipfs/interface-pull-blob-store\\">pull-blob-store</a> implementation for the filesystem in node.js</p>\\n</blockquote>\\n<h2>Installation</h2>\\n<pre><code class=\\"hljs language-bash\\">$ npm install fs-pull-blob-store</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[12,38,40,42],"version":"0.4.2","npmName":"fs-pull-blob-store","category":"file system and databases"},{"user":"ipfs","name":"js-idb-pull-blob-store","path":"ipfs/js-idb-pull-blob-store","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/ipfs/js-idb-pull-blob-store\\">idb-pull-blob-store</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"http://ipn.io\\"></a>\\n<a href=\\"http://ipfs.io/\\"></a>\\n<a href=\\"http://webchat.freenode.net/?channels=%2523ipfs\\"></a>\\n<a href=\\"https://travis-ci.org/ipfs/js-idb-pull-blob-store\\"></a>\\n<a href=\\"https://circleci.com/gh/ipfs/js-idb-pull-blob-store\\"></a>\\n<a href=\\"https://david-dm.org/ipfs/js-idb-pull-blob-store\\"></a> <a href=\\"https://github.com/feross/standard\\"></a></p>\\n<blockquote>\\n<p><a href=\\"https://github.com/ipfs/interface-pull-blob-store\\">pull-blob-store</a> implementation for <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\\">IndexedDB</a>.</p>\\n</blockquote>\\n<h2>Installation</h2>\\n<pre><code class=\\"hljs language-bash\\">$ npm install idb-pull-blob-store</code></pre>\\n","contributors":[12,40,38,43,42],"version":"0.5.1","npmName":"idb-pull-blob-store","category":"file system and databases"},{"user":"jamen","name":"pull-vinyl","path":"jamen/pull-vinyl","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/jamen/pull-vinyl\\">pull-vinyl  </a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>Read and write <code>Vinyl</code> objects in the file system.</p>\\n</blockquote>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  <span class=\\"hljs-comment\\">// Read `Vinyl` files</span>\\n  vinyl.src(<span class=\\"hljs-string\\">&apos;foo/**/*.js&apos;</span>),\\n\\n  <span class=\\"hljs-comment\\">// Transform them somehow, i.e. with a compiler.</span>\\n  transformVinyl(),\\n\\n  <span class=\\"hljs-comment\\">// Write them</span>\\n  vinyl.dest(<span class=\\"hljs-string\\">&apos;output&apos;</span>)\\n)</code></pre>\\n<p>Reading and writing <a href=\\"https://github.com/gulpjs/vinyl\\"><code>Vinyl</code></a> objects to/from the file system with pull streams.  It is inspired from <a href=\\"https://github.com/gulpjs/vinyl-fs\\"><code>vinyl-fs</code></a> from gulp.</p>\\n<h2>Installation</h2>\\n<pre><code class=\\"hljs language-sh\\">$ npm install --save pull-vinyl</code></pre>\\n<h2>API</h2>\\n<h3><code>vinyl.src(pattern, [options])</code></h3>\\n<p>Read <code>Vinyl</code> objects from the file system with patterns from <a href=\\"https://npmjs.com/pull-glob\\"><code>pull-glob</code></a>.  You can use <code>vinyl.read</code> as an alias.</p>\\n<ul>\\n<li><code>pattern</code>: A glob pattern resolved by <code>pull-glob</code>.</li>\\n<li><code>options</code> (<code>Object</code>): Options for reading.</li>\\n</ul>\\n<p>It works as a <a href=\\"https://github.com/pull-stream/pull-stream#source-aka-readable\\">pull stream source</a>:</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  <span class=\\"hljs-comment\\">// Resolve glob into `Vinyl` objects.</span>\\n  vinyl.src(<span class=\\"hljs-string\\">&apos;foo/**/*.js&apos;</span>),\\n  <span class=\\"hljs-comment\\">// Transform `Vinyl` objects...</span>\\n  <span class=\\"hljs-comment\\">// Then write them:</span>\\n  vinyl.dest(<span class=\\"hljs-string\\">&apos;bar&apos;</span>)\\n)</code></pre>\\n<h3><code>vinyl.dest([base]])</code></h3>\\n<p>Write <code>Vinyl</code> objects at the <code>directory</code> base.  You can use <code>vinyl.write</code> as an alias.</p>\\n<ul>\\n<li><code>base</code> (<code>String</code>): The base directory for the <code>Vinyl</code> objects.  Defaults to <code>file.base</code>.</li>\\n</ul>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  <span class=\\"hljs-comment\\">// Obtain `Vinyl` objects somehow, probably through reading:</span>\\n  vinyl.src(<span class=\\"hljs-string\\">&apos;foo/**/*.js&apos;</span>),\\n\\n  <span class=\\"hljs-comment\\">// Transform them before you write them:</span>\\n  babel(), <span class=\\"hljs-comment\\">// Example stream.</span>\\n\\n  <span class=\\"hljs-comment\\">// Write them to the given directory</span>\\n  vinyl.dest(<span class=\\"hljs-string\\">&apos;out&apos;</span>)\\n)</code></pre>\\n<h3><code>vinyl.map(name, [base])</code></h3>\\n<p>Maps data into vinyl files.  Essentially <a href=\\"https://npmjs.com/vinyl-source-stream\\"><code>vinyl-source-stream</code></a> as a pull-stream.</p>\\n<ul>\\n<li><code>name</code> (<code>String</code>|<code>Function</code>): String of file&apos;s name, or a function to handle per item.</li>\\n<li><code>base</code> (<code>String</code>|<code>Function</code>): Optional base directory string, or a function to handle per item.</li>\\n</ul>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  <span class=\\"hljs-comment\\">// Pipe some data:</span>\\n  pull.values([ Buffer.from(<span class=\\"hljs-string\\">&apos;hello world&apos;</span>) ]),\\n\\n  <span class=\\"hljs-comment\\">// Map it to a file:</span>\\n  vinyl.map(<span class=\\"hljs-string\\">&apos;bar.js&apos;</span>, <span class=\\"hljs-string\\">&apos;/foo&apos;</span>),\\n\\n  <span class=\\"hljs-comment\\">// Use it</span>\\n  pull.drain(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">file</span>) </span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(file)\\n  })\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT &#xA9; <a href=\\"https://github.com/jamen\\">Jamen Marz</a></p>\\n","contributors":[10],"version":"1.2.0","npmName":"pull-vinyl","category":"file system and databases"},{"user":"jamen","name":"pull-files","path":"jamen/pull-files","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/jamen/pull-files\\">pull-files</a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>Read and write directories of files with pull-stream</p>\\n</blockquote>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> { read, write } = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-files&apos;</span>)\\n\\npull(\\n  <span class=\\"hljs-comment\\">// Read js files out of `node_modules`</span>\\n  read(<span class=\\"hljs-string\\">&apos;node_modules/**/*.js&apos;</span>),\\n\\n  <span class=\\"hljs-comment\\">// Compile files&apos; contents</span>\\n  pull.through(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">file</span> =&gt;</span> {\\n    file.data = compile(file.data)\\n  }),\\n\\n  <span class=\\"hljs-comment\\">// Write them to `out` directory</span>\\n  write(<span class=\\"hljs-string\\">&apos;out&apos;</span>, err =&gt; {\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;finished&apos;</span>)\\n  })\\n)</code></pre>\\n<p>The file objects are a minimal take on <a href=\\"https://github.com/gulpjs/vinyl\\"><code>Vinyl</code></a> containing only properties that are necessary:</p>\\n<pre><code>{ base: &apos;/home/jamen/jamen/pull-files/test&apos;,\\n  path: &apos;bar/pluto.txt&apos;,\\n  data: &lt;Buffer 68 65 6c 6c 6f 20 69 20 61 6d 20 70 6c 75 74 6f 0a&gt; }\\n</code></pre>\\n<p>This lets you create them without any dependencies, and you may also add custom properties not concerned with this module</p>\\n<h2>Installation</h2>\\n<pre><code class=\\"hljs language-shell\\">npm install --save pull-files</code></pre>\\n<h2>Usage</h2>\\n<h3><code>read(glob, options?)</code></h3>\\n<p>Read files from a glob or path (or arrays of either) using <a href=\\"https://github.com/micromatch/micromatch\\"><code>micromatch</code></a> patterns.  Supply <code>cwd</code> if your paths are relative and will change depending on where you execute <code>node</code> (most likely want <code>__dirname</code>)</p>\\n<p>Options can contain:</p>\\n<ul>\\n<li><code>cwd</code>: Used to resolve relative paths (commonly set as <code>__dirname</code>)</li>\\n<li><code>stream</code>: Enable stream mode, where <code>file.data</code> is a source stream</li>\\n</ul>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  <span class=\\"hljs-comment\\">// Read js files from node_modules, excluding pull-files directory</span>\\n  read([ <span class=\\"hljs-string\\">&apos;node_modules/**/*.js&apos;</span>, <span class=\\"hljs-string\\">&apos;!node_modules/pull-files&apos;</span> ], { <span class=\\"hljs-attr\\">cwd</span>: __dirname }),\\n  drain(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">file</span> =&gt;</span> <span class=\\"hljs-built_in\\">console</span>.log(file))\\n)</code></pre>\\n<h3><code>write(dest, done?)</code></h3>\\n<p>Write files to <code>dest</code> and calls <code>done(err?)</code> when finished</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  values([\\n    { <span class=\\"hljs-attr\\">path</span>: <span class=\\"hljs-string\\">&apos;earth.js&apos;</span>, <span class=\\"hljs-attr\\">data</span>: <span class=\\"hljs-string\\">&apos;hello earth&apos;</span> },\\n    { <span class=\\"hljs-attr\\">path</span>: <span class=\\"hljs-string\\">&apos;mars.js&apos;</span>, <span class=\\"hljs-attr\\">data</span>: <span class=\\"hljs-string\\">&apos;hello mars&apos;</span> },\\n    { <span class=\\"hljs-attr\\">path</span>: <span class=\\"hljs-string\\">&apos;pluto.js&apos;</span>, <span class=\\"hljs-attr\\">data</span>: <span class=\\"hljs-string\\">&apos;hello pluto&apos;</span> },\\n  ]),\\n\\n  write(<span class=\\"hljs-string\\">&apos;example&apos;</span>, err =&gt; {\\n    <span class=\\"hljs-comment\\">// wrote all 3 files to `example/...`</span>\\n  })\\n)</code></pre>\\n<p>Here you can see that files don&apos;t have to be created from <code>read</code> either, but can be from anywhere.  Nor do you have to provide <code>base</code> for unglobbed files.</p>\\n<h3><code>{ base, path, data }</code></h3>\\n<p>These Represent files, where:</p>\\n<ul>\\n<li><code>base</code> is an optional property present if <code>path</code> is relative.  It allows you to retain directory structure and move the base (e.g. to an <code>out/</code> folder if you&apos;re compiling)</li>\\n<li><code>path</code>: The path of the data.  Either absolute or relative.  If absolute, <code>base</code> will be <code>null</code>.</li>\\n<li><code>data</code>: A buffer or stream of the file&apos;s data.</li>\\n</ul>\\n<p>For a simple way to get a file&apos;s full path, regardless of relativity, do:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> full = base ? join(base, path) : path</code></pre>\\n<hr>\\n<p><em>Maintained by <a href=\\"https://git.io/jamen\\">Jamen Marz</a> (See on <a href=\\"https://twitter.com/jamenmarz\\">Twitter</a> and <a href=\\"https://github.com/jamen\\">GitHub</a> for questions &amp; updates)</em></p>\\n","contributors":[10],"version":"1.1.0","npmName":"pull-files","category":"file system and databases"},{"user":"dominictarr","name":"multiblob","path":"dominictarr/multiblob","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/multiblob\\">multiblob</a><div class=\\"contrib\\"></div></h1>\\n<p>A content-addressable-store that supports multiple hashing algorithms,\\nand pull-streams.</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Blobs = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;multiblob&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> blobs = Blobs({<span class=\\"hljs-attr\\">dir</span>:dir, <span class=\\"hljs-attr\\">alg</span>: <span class=\\"hljs-string\\">&apos;sha256&apos;</span>}) <span class=\\"hljs-comment\\">//pass in the basedir &amp; hash alg</span>\\n\\npull(source, blobs.add(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, hash</span>) </span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;added source to blobs:&apos;</span>, hash)\\n})</code></pre>\\n<h2>api: Blobs(config)</h2>\\n<h3>add (hash?, cb?) =&gt; Sink</h3>\\n<p>create a sink stream for writing a blob.\\nIf <code>hash</code> was given, then it will error if the file turned out to be different.\\nIf a <code>cb</code> is not given and there was an error, this function will throw.</p>\\n<h3>get (hash || opts) =&gt; Source</h3>\\n<p>create a source stream that reads from a given blob.\\nIf the file does not exist this stream will error.</p>\\n<p>If the argument is a <code>hash</code> string, then return the stream.\\nIf the argument is an <code>opts</code> object, with the <code>key: hash</code> property,\\nretrive that blob, but error if the size does not exactly match the\\n<code>size</code> property, or is over <code>max</code> property (in bytes)</p>\\n<h3>getSlice (opts) =&gt; Source</h3>\\n<p>create a source stream that reads a slice of a given blob,\\nfrom the <code>start</code> property to the <code>end</code> property, in bytes.\\nError if the file does not exist or if\\nthe size of the whole blob does not exactly match the\\n<code>size</code> property, or is over <code>max</code> property (in bytes).</p>\\n<h3>has(hash, cb)</h3>\\n<p>check if the given hash is in the store.\\nIf <code>hash</code> is an array of hashes,\\n<code>size</code> will callback with an array of booleans.</p>\\n<h3>size(hash, cb)</h3>\\n<p>get the size of this blob. If <code>hash</code> is an array of hashes,\\n<code>size</code> will callback with an array of sizes.\\nIf the hash does not exist in the store, <code>size</code> will callback <code>null</code>.</p>\\n<h3>ls() =&gt; Source</h3>\\n<p>source stream that reads the list of hashes available in the store.</p>\\n<h3>rm(hash, cb)</h3>\\n<p>remove a hash from the store.</p>\\n<h3>isEmptyHash(hash)</h3>\\n<p>Check if a given hash is actually the empty hash. If something has the empty hash,\\nthat is probably a bug. The above methods will act like the empty file is already in the store.</p>\\n<h2>todo</h2>\\n<p>maybe emit events when blobs are stored?</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,19],"version":"1.13.0","npmName":"multiblob","category":"file system and databases"},{"user":"tableflip","name":"pull-file-reader","path":"tableflip/pull-file-reader","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/tableflip/pull-file-reader\\">pull-file-reader </a><div class=\\"contrib\\"></div></h1>\\n<p>Given an HTML5 File object (from e.g. HTML5 drag and drops), turn it into a pull stream source.</p>\\n<p>Heavily based on <a href=\\"https://github.com/maxogden/filereader-stream\\">filereader-stream</a> by <a href=\\"https://github.com/maxogden\\">@maxogden</a>.</p>\\n<h2>install</h2>\\n<p>Use it with npm &amp; <a href=\\"https://github.com/substack/node-browserify\\">browserify</a></p>\\n<pre><code class=\\"hljs language-bash\\">npm install pull-file-reader</code></pre>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> drop = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;drag-and-drop-files&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> fileReader = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-file-reader&apos;</span>)\\n\\ndrop(<span class=\\"hljs-built_in\\">document</span>.body, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">files</span>) </span>{\\n  <span class=\\"hljs-keyword\\">var</span> first = files[<span class=\\"hljs-number\\">0</span>]\\n  pull(\\n    fileReader(first),\\n    pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, buffs</span>) </span>{\\n      <span class=\\"hljs-keyword\\">var</span> contents = Buffer.concat(buffs)\\n      <span class=\\"hljs-comment\\">// contents is the contents of the entire file</span>\\n    })\\n  )\\n})</code></pre>\\n<h2>usage</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> fileReader = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-file-reader&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> source = fileReader(file, [options])</code></pre>\\n<p><code>fileReader</code> is a <a href=\\"https://github.com/pull-stream/pull-stream\\">pull stream</a> <a href=\\"https://github.com/pull-stream/pull-stream#source-aka-readable\\">source</a>.</p>\\n<p><code>options</code>:</p>\\n<ul>\\n<li><code>chunkSize</code> - default <code>1024 * 1024</code> (1MB) - How many bytes will be read at a time</li>\\n<li><code>offset</code> - default <code>0</code> - Where in the file to start reading</li>\\n</ul>\\n<h2>run the tests</h2>\\n<pre><code>npm install\\nnpm test\\n</code></pre>\\n<p>then open your browser to the address provided, open your JS console, and drag and drop files onto the page until the test suite passes/fails</p>\\n<hr>\\n<p>A <a href=\\"https://tableflip.io\\">(&#x256F;&#xB0;&#x25A1;&#xB0;&#xFF09;&#x256F;&#xFE35;TABLEFLIP</a> side project.</p>\\n<p><a href=\\"https://github.com/feross/standard\\"><img src=\\"https://cdn.rawgit.com/feross/standard/master/badge.svg\\" alt=\\"js-standard-style\\"></a></p>\\n","contributors":[44],"version":"1.0.2","npmName":"pull-file-reader","category":"file system and databases"},{"user":"pull-stream","name":"pull-split","path":"pull-stream/pull-split","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-split\\">pull-split</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://github.com/dominictarr/split\\">split</a> ported to\\n<a href=\\"https://github.com/dominictarr/pull-stream\\">pull-stream</a> style.</p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> split = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-split&apos;</span>)\\n\\npull(\\n  textStream\\n  split(),\\n  output\\n)</code></pre>\\n<p>if the textStream is buffers, and contain UTF8\\n(it probably will if you have german or chinese friends, etc)\\nthen you MUST use this with <code>pull-utf8-decoder</code></p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> split = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-split&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> utf8 = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-utf8-decoder&apos;</span>)\\n\\npull(\\n  textStream\\n  utf8(),\\n  split(),\\n  output\\n)</code></pre>\\n<h2>split(matcher, mapper, reverse, skipLast)</h2>\\n<h3>matcher - string or regexp.</h3>\\n<p>unit to split by, defaults to <code>\\\\n</code></p>\\n<h3>mapper - function</h3>\\n<p>function to apply to each line matched.</p>\\n<h3>reverse - boolean</h3>\\n<p>if true, emit lines in reverse. use this if the input is a file\\nyou are reading backwards.</p>\\n<h3>skipLast - boolean</h3>\\n<p>use this to skip the last value if it is and empty string <code>&apos;&apos;</code>\\nif this is not set then the behavior is the same as <code>String#split</code></p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,4],"version":"0.2.0","npmName":"pull-split","category":"text"},{"user":"pull-stream","name":"pull-stringify","path":"pull-stream/pull-stringify","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stringify\\">pull-stringify</a><div class=\\"contrib\\"></div></h1>\\n<p>JSON.stringify as pull stream</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> stringify = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stringify&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> toPull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;stream-to-pull-stream&apos;</span>)\\n\\npull(\\n  pull.values([A, B, C]),\\n  stringify(),\\n  toPull(process.stdout)\\n)</code></pre>\\n<h2>usage</h2>\\n<h3><code>stringify = require(&apos;pull-stringify&apos;)</code></h3>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull.values([A, B, C]),\\n  stringify.lines(),\\n  toPull(process.stdout)\\n)</code></pre>\\n<h3><code>stringify(options)</code></h3>\\n<p><code>options</code> is an object with the following optional keys:</p>\\n<ul>\\n<li><code>open</code>: string to be prepended to first output string</li>\\n<li><code>prefix</code>: string to be prepended to every non-first output string</li>\\n<li><code>suffix</code>: string to be appended to every output string</li>\\n<li><code>close</code>: string to be appended after stream is complete</li>\\n<li><code>indent</code>: passed as third argument to <code>JSON.stringify</code></li>\\n<li><code>stringify</code>: custom function to use instead of <code>JSON.stringify</code></li>\\n</ul>\\n<p><code>stringify(options)</code> returns a through <a href=\\"https://pull-stream.github.io\\"><code>pull-stream</code></a>.</p>\\n<p>defaults options are for <a href=\\"https://github.com/dominictarr/pull-json-doubleline/blob/master/index.js\\">double newline delimited json</a>. double newline delimiting means you can use indented json as the stream format, which is more human readable.</p>\\n<pre><code class=\\"hljs language-js\\">{\\n  <span class=\\"hljs-attr\\">open</span>: <span class=\\"hljs-string\\">&apos;&apos;</span>,\\n  <span class=\\"hljs-attr\\">prefix</span>: <span class=\\"hljs-string\\">&apos;&apos;</span>,\\n  <span class=\\"hljs-attr\\">suffix</span>: <span class=\\"hljs-string\\">&apos;\\\\n\\\\n&apos;</span>,\\n  <span class=\\"hljs-attr\\">close</span>: <span class=\\"hljs-string\\">&apos;&apos;</span>,\\n  <span class=\\"hljs-attr\\">indent</span>: <span class=\\"hljs-number\\">2</span>,\\n  <span class=\\"hljs-attr\\">stringify</span>: <span class=\\"hljs-built_in\\">JSON</span>.stringify\\n}</code></pre>\\n<h3><code>stringify.ldjson(stringify)</code></h3>\\n<h3><code>stringify.lines(stringify)</code></h3>\\n<p>for single newline delimited json use <code>stringify.ldjson()</code> or <code>stringify.lines()</code>:</p>\\n<pre><code class=\\"hljs language-js\\">{\\n  <span class=\\"hljs-attr\\">suffix</span>: <span class=\\"hljs-string\\">&apos;\\\\n&apos;</span>,\\n  <span class=\\"hljs-attr\\">indent</span>: <span class=\\"hljs-number\\">0</span>\\n}</code></pre>\\n<p>you can pass a custom stringify as an argument.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-comment\\">// compatible with JSON but supports buffers.</span>\\n<span class=\\"hljs-keyword\\">var</span> JSONB = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;json-buffer&apos;</span>)\\n\\n<span class=\\"hljs-comment\\">// use defaults</span>\\nstringify({ <span class=\\"hljs-attr\\">stringify</span>: JSONB.stringify })\\n\\n<span class=\\"hljs-comment\\">// or</span>\\nstringify.lines(JSONB.stringify)</code></pre>\\n<h3><code>stringify.array(stringify)</code></h3>\\n<p>for a single json array use <code>stringify.array()</code></p>\\n<pre><code class=\\"hljs language-js\\">{\\n  <span class=\\"hljs-attr\\">open</span>: <span class=\\"hljs-string\\">&apos;[&apos;</span>,\\n  <span class=\\"hljs-attr\\">separator</span>: <span class=\\"hljs-string\\">&apos;,\\\\n&apos;</span>,\\n  <span class=\\"hljs-attr\\">close</span>: <span class=\\"hljs-string\\">&apos;]\\\\n&apos;</span>,\\n  <span class=\\"hljs-attr\\">indent</span>: <span class=\\"hljs-number\\">2</span>\\n}</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,3,38],"version":"2.0.0","npmName":"pull-stringify","category":"text"},{"user":"dominictarr","name":"pull-json-doubleline","path":"dominictarr/pull-json-doubleline","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-json-doubleline\\">pull-json-doubleline</a><div class=\\"contrib\\"></div></h1>\\n<p>stream json stringify and parser into double newline delimited json.\\ndouble newline delimiting means you can use indented json as the stream format,\\nwhich is more human readable.</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pullJson = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-json-doubleline&apos;</span>)\\n\\npull(\\n  source,\\n  pullJson.stringify(),\\n  pullJson.parse(),\\n  sink\\n)</code></pre>\\n<h2>api</h2>\\n<h3><code>pullJson = require(&apos;pull-json-doubleline&apos;)</code></h3>\\n<h3><code>pullJson.stringify() =&gt; through</code></h3>\\n<p>stringify a stream of objects into double newline delimited json strings.</p>\\n<h3><code>pullJson.parse() =&gt; through</code></h3>\\n<p>transform a stream of double newline delimited json strings into objects.</p>\\n<h3><code>pullJson(source) =&gt; decodedSource</code></h3>\\n<p>decode a source stream of json buffers, return a source stream of objects.</p>\\n<h3><code>pullJson(sink) =&gt; encodedSink</code></h3>\\n<p>encode a sink stream for json buffers, return a sink stream for objects.</p>\\n<h3><code>pullJson(objectDuplex) =&gt; serializedDuplex</code></h3>\\n<p>encode/decode around a duplex stream of json buffers,\\nreturn a stream that can be piped to a io steam.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,3],"version":"2.0.0","npmName":"pull-json-doubleline","category":"text"},{"user":"pull-stream","name":"pull-utf8-decoder","path":"pull-stream/pull-utf8-decoder","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-utf8-decoder\\">pull-decode</a><div class=\\"contrib\\"></div></h1>\\n<p>Take a stream of buffers and output a stream of valid strings,</p>\\n<p>If you have utf8 characters this is absolutely necessary!</p>\\n<p><a href=\\"https://travis-ci.org/dominictarr/pull-utf8-decoder\\">\\n</a></p>\\n<p><a href=\\"http://ci.testling.com/dominictarr/pull-utf8-decoder\\">\\n</a></p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.0.2","npmName":"pull-utf8-decoder","category":"text"},{"user":"diasdavid","name":"pull-ndjson","path":"diasdavid/pull-ndjson","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/diasdavid/pull-ndjson\\">pull-ndjson</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"http://ipn.io\\"></a>\\n<a href=\\"http://libp2p.io/\\"></a>\\n<a href=\\"http://webchat.freenode.net/?channels=%2523ipfs\\"></a></p>\\n<blockquote>\\n<p>A pull-streams ndjson parser and serializer, inspired by and compatible with <a href=\\"https://www.npmjs.com/package/ndjson\\">ndjson</a>. Note: This module ends up being a very tiny wrapper around pull-strinfigy and pull-split, exposing the same API as <code>ndjson</code>.</p>\\n</blockquote>\\n<h2>Table of Contents</h2>\\n<ul>\\n<li><a href=\\"#install\\">Install</a></li>\\n<li><a href=\\"#usage\\">Usage</a></li>\\n<li><a href=\\"#api\\">API</a></li>\\n<li><a href=\\"#contribute\\">Contribute</a></li>\\n<li><a href=\\"#license\\">License</a></li>\\n</ul>\\n<h2>Install</h2>\\n<pre><code>&gt; npm install pull-ndjson\\n</code></pre>\\n<h2>Examples</h2>\\n<h4>Serialize and Deserialize</h4>\\n<pre><code class=\\"hljs language-JavaScript\\"><span class=\\"hljs-keyword\\">const</span> ndjson = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;ndjson&apos;</span>)\\n\\npull(\\n  pull.values([{ <span class=\\"hljs-attr\\">a</span>: <span class=\\"hljs-number\\">1</span> }]),\\n  ndjson.serialize(),\\n  ndjson.parse(),\\n  pull.collect(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">err, values</span>) =&gt;</span> {\\n    <span class=\\"hljs-keyword\\">if</span> (err) {\\n      <span class=\\"hljs-keyword\\">throw</span> err\\n    }\\n    <span class=\\"hljs-built_in\\">console</span>.log(values)\\n    <span class=\\"hljs-comment\\">// [{ a: 1}]</span>\\n  })\\n)</code></pre>\\n<h2>Contribute</h2>\\n<p>PRs are welcome!</p>\\n<p>Small note: If editing the Readme, please conform to the <a href=\\"https://github.com/RichardLitt/standard-readme\\">standard-readme</a> specification.</p>\\n<h2>License</h2>\\n<p>MIT &#xA9; David Dias</p>\\n","contributors":[38,12],"version":"0.1.1","npmName":"pull-ndjson","category":"text"},{"user":"pull-stream","name":"pull-handshake","path":"pull-stream/pull-handshake","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-handshake\\">pull-handshake</a><div class=\\"contrib\\"></div></h1>\\n<p>Create handshakes for binary protocols with pull streams.</p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> stream = handshake()\\n<span class=\\"hljs-keyword\\">var</span> shake = stream.handshake\\n\\n<span class=\\"hljs-comment\\">// Pull some amount of data out of the stream</span>\\nshake.read(<span class=\\"hljs-number\\">32</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, data</span>) </span>{\\n\\n  <span class=\\"hljs-comment\\">// Write a response...</span>\\n  shake.write(<span class=\\"hljs-keyword\\">new</span> Buffer(<span class=\\"hljs-string\\">&apos;hello there&apos;</span>))\\n\\n  shake.read(<span class=\\"hljs-number\\">32</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, data</span>) </span>{\\n    <span class=\\"hljs-comment\\">// Get a confirmation,</span>\\n    <span class=\\"hljs-comment\\">// and then attach the application</span>\\n    <span class=\\"hljs-keyword\\">var</span> stream = createApplicationStream()\\n\\n    pull(stream, shake.rest(), stream)\\n    <span class=\\"hljs-comment\\">// shake.rest() returns a duplex binary stream.</span>\\n  })\\n})\\n\\n\\n<span class=\\"hljs-comment\\">// shake is itself a duplex pull-stream.</span>\\npull(shake, stream, shake)</code></pre>\\n<h2>API</h2>\\n<h3><code>handshake([opts], [callback])</code></h3>\\n<h4>opts</h4>\\n<p>Type: <code>Object</code><br>\\nDefault: <code>{timeout: 5e3}</code></p>\\n<p>The allowed duration for the handshake to take place.</p>\\n<h4>callback</h4>\\n<p>Type: <code>Function</code><br>\\nDefault: <code>function noop () {}</code></p>\\n<p>This will be called when the handshake completes, or fails. In the case of failure it is called with an <code>error</code>.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,12,19],"version":"1.1.4","npmName":"pull-handshake","category":"binary"},{"user":"dominictarr","name":"pull-randomly-split","path":"dominictarr/pull-randomly-split","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-randomly-split\\">pull-randomly-split</a><div class=\\"contrib\\"></div></h1>\\n<p>randomly split incoming buffers, to test that parsing works correctly.</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull.values(crypto.randomBytes(<span class=\\"hljs-number\\">1024</span>*<span class=\\"hljs-number\\">1024</span>)),\\n  randomSplit(<span class=\\"hljs-number\\">1024</span>, <span class=\\"hljs-number\\">2096</span>),\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n\\n\\n  })\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.0.4","npmName":"pull-randomly-split","category":"binary"},{"user":"dominictarr","name":"pull-reader","path":"dominictarr/pull-reader","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-reader\\">pull-reader</a><div class=\\"contrib\\"></div></h1>\\n<p>read bytes from a binary pull-stream</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Reader = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-reader&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> File = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-file&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> reader = Reader(<span class=\\"hljs-number\\">1000</span>) <span class=\\"hljs-comment\\">//1 second timeout, abort upstream if read takes longer than this.</span>\\n\\n\\npull(\\n  File(<span class=\\"hljs-string\\">&apos;./package.json&apos;</span>),\\n  reader\\n)\\n\\n<span class=\\"hljs-comment\\">//read the first byte of a file</span>\\nreader.read(<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, data</span>) </span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(data.toString()) <span class=\\"hljs-comment\\">// =&gt; {</span>\\n})</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0],"version":"1.2.9","npmName":"pull-reader","category":"binary"},{"user":"dignifiedquire","name":"pull-length-prefixed","path":"dignifiedquire/pull-length-prefixed","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dignifiedquire/pull-length-prefixed\\">pull-length-prefixed</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"http://ipn.io\\"></a>\\n<a href=\\"http://ipfs.io/\\"></a>\\n<a href=\\"http://webchat.freenode.net/?channels=%2523ipfs\\"></a>\\n<a href=\\"https://coveralls.io/github/dignifiedquire/pull-length-prefixed?branch=master\\"></a>\\n<a href=\\"https://travis-ci.org/dignifiedquire/pull-length-prefixed\\"></a>\\n<a href=\\"https://circleci.com/gh/dignifiedquire/pull-length-prefixed\\"></a>\\n<a href=\\"https://david-dm.org/dignifiedquire/pull-length-prefixed\\"></a> <a href=\\"https://github.com/feross/standard\\"></a>\\n<a href=\\"https://github.com/RichardLitt/standard-readme\\"></a></p>\\n<blockquote>\\n<p>Streaming length prefixed buffers with pull-streams</p>\\n</blockquote>\\n<h2>Table of Contents</h2>\\n<ul>\\n<li><a href=\\"#installation\\">Installation</a></li>\\n<li><a href=\\"#usage\\">Usage</a></li>\\n<li><a href=\\"#contribute\\">Contribute</a></li>\\n<li><a href=\\"#license\\">License</a></li>\\n</ul>\\n<h2>Installation</h2>\\n<pre><code class=\\"hljs language-bash\\">$ npm install --save pull-length-prefixed</code></pre>\\n<h2>Usage</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> lp = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-length-prefixed&apos;</span>)\\n\\n<span class=\\"hljs-comment\\">// encode</span>\\npull(\\n  pull.values([Buffer.from(<span class=\\"hljs-string\\">&apos;hello world&apos;</span>)]),\\n  lp.encode(),\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, encode</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span> (err) <span class=\\"hljs-keyword\\">throw</span> err\\n    <span class=\\"hljs-built_in\\">console</span>.log(encoded)\\n    <span class=\\"hljs-comment\\">// =&gt; [Buffer &lt;0b 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;]</span>\\n  })\\n)\\n\\n<span class=\\"hljs-comment\\">// decode</span>\\npull(\\n  pull.values(encoded), <span class=\\"hljs-comment\\">// e.g. from above</span>\\n  lp.decode(),\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, decoded</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span> (err) <span class=\\"hljs-keyword\\">throw</span> err\\n    <span class=\\"hljs-built_in\\">console</span>.log(decoded)\\n    <span class=\\"hljs-comment\\">// =&gt; [Buffer &lt;68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;]</span>\\n  })\\n)</code></pre>\\n<h2>API</h2>\\n<h3><code>encode([opts])</code></h3>\\n<ul>\\n<li>\\n<p><code>opts: Object</code>, optional</p>\\n<ul>\\n<li><code>fixed: false</code>: If true uses a fixed 4 byte Int32BE prefix instead of varint</li>\\n</ul>\\n</li>\\n</ul>\\n<p>By default all messages will be prefixed with a varint. If you want to use a fixed length prefix you can specify this through the <code>opts</code>.</p>\\n<p>Returns a pull-stream through.</p>\\n<h3><code>decode([opts])</code></h3>\\n<ul>\\n<li>\\n<p><code>opts: Object</code>, optional</p>\\n<ul>\\n<li><code>fixed: false</code>: If true uses a fixed 4 byte Int32BE prefix instead of varint</li>\\n<li><code>maxLength</code>: If provided, will not decode messages longer than the size specified, if omitted will use the current default of 4MB.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>By default all messages will be prefixed with a varint. If you want to use a fixed length prefix you can specify this through the <code>opts</code>.</p>\\n<p>Returns a pull-stream through.</p>\\n<h3><code>decodeFromReader(reader, [opts], cb)</code></h3>\\n<ul>\\n<li><code>reader: [pull-reader](https://github.com/dominictarr/pull-reader)</code></li>\\n<li><code>opts: Object</code>, optional. Same as for <code>decode</code>.</li>\\n<li><code>cb: Function</code>: Callback called with <code>(err, message)</code>.</li>\\n</ul>\\n<p>This uses a <a href=\\"https://github.com/dominictarr/pull-reader\\">pull-reader</a> instance to reade and decode a single message. Useful when using <a href=\\"https://github.com/pull-stream/pull-handshake\\">pull-handshake</a> with length prefixed messages.</p>\\n<h2>Contribute</h2>\\n<p>PRs and issues gladly accepted! Check out the <a href=\\"http://github.com/dignifiedquire/pull-length-prefixed/blob/master///github.com/dignifiedquire/pull-length-prefixed/issues\\">issues</a>.</p>\\n<h2>License</h2>\\n<p>MIT &#xA9; 2016 Friedel Ziegelmayer</p>\\n","contributors":[12,43,45,39],"version":"1.3.0","npmName":"pull-length-prefixed","category":"binary"},{"user":"dignifiedquire","name":"pull-block","path":"dignifiedquire/pull-block","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dignifiedquire/pull-block\\">pull-block</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"http://travis-ci.org/dignifiedquire/pull-block\\"></a><a href=\\"https://david-dm.org/dignifiedquire/pull-stream\\"></a> <a href=\\"https://github.com/feross/standard\\"></a></p>\\n<blockquote>\\n<p>transform input into equally-sized chunks as output</p>\\n</blockquote>\\n<p><a href=\\"https://pull-stream.github.io/\\">pull-stream</a> version of <a href=\\"https://npmjs.org/package/block-stream\\">block-stream</a>.</p>\\n<h2>Installation</h2>\\n<p>With <a href=\\"https://npmjs.org\\">npm</a> do:</p>\\n<pre><code class=\\"hljs language-bash\\">&gt; npm install pull-block</code></pre>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> block = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-block&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> toPull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;stream-to-pull-stream&apos;</span>)\\n\\npull(\\n  toPull.source(process.stdin),\\n  block({ <span class=\\"hljs-attr\\">size</span>: <span class=\\"hljs-number\\">16</span>, <span class=\\"hljs-attr\\">zeroPadding</span>: <span class=\\"hljs-literal\\">true</span> }),\\n  pull.through(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">buf</span>) </span>{\\n    <span class=\\"hljs-keyword\\">var</span> str = buf.toString().replace(<span class=\\"hljs-regexp\\">/[\\\\x00-\\\\x1f]/g</span>, chr)\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;buf[&apos;</span> + buf.length + <span class=\\"hljs-string\\">&apos;]=&apos;</span> + str)\\n  }),\\n  pull.drain()\\n)\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">chr</span> (<span class=\\"hljs-params\\">s</span>) </span>{ <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-string\\">&apos;\\\\\\\\x&apos;</span> + pad(s.charCodeAt(<span class=\\"hljs-number\\">0</span>).toString(<span class=\\"hljs-number\\">16</span>), <span class=\\"hljs-number\\">2</span>) }\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">pad</span> (<span class=\\"hljs-params\\">s, n</span>) </span>{ <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">Array</span>(n - s.length + <span class=\\"hljs-number\\">1</span>).join(<span class=\\"hljs-string\\">&apos;0&apos;</span>) + s }</code></pre>\\n<pre><code>$ echo {c,d,f}{a,e,i,o,u}{t,g,r} | node example/stream.js\\nbuf[16]=cat cag car cet\\nbuf[16]=ceg cer cit cig\\nbuf[16]=cir cot cog cor\\nbuf[16]=cut cug cur dat\\nbuf[16]=dag dar det deg\\nbuf[16]=der dit dig dir\\nbuf[16]=dot dog dor dut\\nbuf[16]=dug dur fat fag\\nbuf[16]=far fet feg fer\\nbuf[16]=fit fig fir fot\\nbuf[16]=fog for fut fug\\nbuf[16]=fur\\\\x0a\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\n</code></pre>\\n<h2>Methods</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> block = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-block&apos;</span>)</code></pre>\\n<h2>var b = block(opts)</h2>\\n<h2>var b = block(size, opts)</h2>\\n<p>Create a new through stream <code>b</code> that outputs chunks of length <code>size</code> or\\n<code>opts.size</code>.</p>\\n<p>When <code>opts.zeroPadding</code> is false, do not zero-pad the last chunk.</p>\\n<p>When <code>opts.emitEmpty</code> is true (default is <code>false</code>), emit a zero-sized buffer when the source is empty or only feeds in zero-length buffers.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[12,46,38,47],"version":"1.4.0","npmName":"pull-block","category":"binary"},{"user":"jamen","name":"pull-stdio","path":"jamen/pull-stdio","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/jamen/pull-stdio\\">pull-stdio  </a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>Stdio functions for pull streams.</p>\\n</blockquote>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> { stdin, stdout, stderr } = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stdio&apos;</span>)\\n\\npull(\\n  <span class=\\"hljs-comment\\">// Source stream for stdin</span>\\n  stdin(),\\n  <span class=\\"hljs-comment\\">// Sink stream for stdout</span>\\n  stdout()\\n)\\n\\n<span class=\\"hljs-comment\\">// Also a sink stream for stderr</span>\\npull(\\n  pull.values([<span class=\\"hljs-string\\">&apos;Error&apos;</span>, <span class=\\"hljs-string\\">&apos;blahlbah&apos;</span>]),\\n  stderr()\\n)</code></pre>\\n<p>This module is a simple wrapper around <a href=\\"https://npmjs.com/stream-to-pull-stream\\"><code>stream-to-pull-stream</code></a> on the native <code>process.stdio</code> streams.  If you have any further ideas for this module feel free to open an issue.</p>\\n<h2>Installation</h2>\\n<pre><code class=\\"hljs language-sh\\">$ npm install --save pull-stdio</code></pre>\\n<h2>Usage</h2>\\n<h3><code>stdio.{method}</code></h3>\\n<p>The object which contains the stdio functions <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> for pull streams.</p>\\n<h4>Example</h4>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> stdio = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stdio&apos;</span>)\\n\\npull(\\n  stdio.stdin()\\n  <span class=\\"hljs-comment\\">// ...</span>\\n)</code></pre>\\n<h3><code>stdin([options])</code></h3>\\n<p>A <a href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/glossary.md#source\\">source pull stream</a> for Node&apos;s <code>process.stdin</code>.</p>\\n<h4>Options</h4>\\n<ul>\\n<li><code>encoding</code> (<code>String</code>|<code>false</code>): Set the <code>process.stdin</code> encoding, or to <code>false</code>.  Defaults to <code>&apos;utf8&apos;</code>.</li>\\n</ul>\\n<h4>Example</h4>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  stdin({ <span class=\\"hljs-attr\\">encoding</span>: <span class=\\"hljs-literal\\">false</span> }),\\n  <span class=\\"hljs-comment\\">// ...</span>\\n)</code></pre>\\n<h3><code>stdout()</code></h3>\\n<p>A <a href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/glossary.md#sink\\">sink stream</a> for Node&apos;s <code>process.stdout</code>.</p>\\n<h4>Example</h4>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  <span class=\\"hljs-comment\\">// Source data somewhere</span>\\n  <span class=\\"hljs-comment\\">// Output to stdout:</span>\\n  stdout()\\n)</code></pre>\\n<h3><code>stderr()</code></h3>\\n<p>A <a href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/glossary.md#sink\\">sink stream</a> for Node&apos;s <code>process.stderr</code>.</p>\\n<h4>Example</h4>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  <span class=\\"hljs-comment\\">// Source data somewhere</span>\\n  <span class=\\"hljs-comment\\">// Output to stderr:</span>\\n  stderr()\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT &#xA9; <a href=\\"https://github.com/jamen\\">Jamen Marz</a></p>\\n","contributors":[10,0],"version":"1.0.0","npmName":"pull-stdio","category":"binary"},{"user":"dominictarr","name":"pull-net","path":"dominictarr/pull-net","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-net\\">pull-net</a><div class=\\"contrib\\"></div></h1>\\n<p>pull-stream directly to node&apos;s libuv bindings.</p>\\n<p>echo server works, don&apos;t handle all the edge cases yet,\\nor nice error messages etc.</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> createServer = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-net/server&apos;</span>)\\n\\ncreateServer(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{\\n  pull(stream.source, stream.sink) <span class=\\"hljs-comment\\">//ECHO</span>\\n}).listen(<span class=\\"hljs-number\\">9999</span>, <span class=\\"hljs-string\\">&apos;127.0.0.1&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> connect = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-net/client&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> stream = connect(<span class=\\"hljs-number\\">9999</span>, <span class=\\"hljs-string\\">&apos;127.0.0.1&apos;</span>)\\n\\npull(\\n  pull.once(<span class=\\"hljs-keyword\\">new</span> Buffer(<span class=\\"hljs-string\\">&apos;hello tcp&apos;</span>)),\\n  stream,\\n  pull.collect(<span class=\\"hljs-built_in\\">console</span>.log)\\n)</code></pre>\\n<h2>Questions</h2>\\n<p>node does some things that turn out to be unnecessary,\\nlike, take a callback for <code>server.listen</code>.</p>\\n<p>Maybe these cause problem when trying to use other stream types though,\\n(such as like unix pipes, which are also handled in\\n<a href=\\"https://github.com/nodejs/node/blob/master/lib/net.js\\">node/lib/net.js</a>)</p>\\n<p>This is probably mainly to handle some errors... maybe those errors\\ncould just throw?</p>\\n<p>Also, there are often client type connections which may error\\nbefore receiving data (at least in their context, such as authentication errors)\\noften, this can&apos;t be a sync error. So that would suggest an api\\nthat was <code>connect(function (err, stream) {...})</code></p>\\n<p>what if a server was a stream of clients? does that really help?</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,12,48],"version":"1.0.2","npmName":"pull-net","category":"networks"},{"user":"DamonOehlman","name":"pull-ws","path":"DamonOehlman/pull-ws","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/DamonOehlman/pull-ws\\">pull-ws</a><div class=\\"contrib\\"></div></h1>\\n<p>Use websockets via pull-stream interface. both client and server.</p>\\n<p><a href=\\"https://nodei.co/npm/pull-ws/\\"></a></p>\\n<p><a href=\\"https://github.com/dominictarr/stability#unstable\\"></a> <a href=\\"https://travis-ci.org/DamonOehlman/pull-ws\\"></a></p>\\n<h2>example - client</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> connect = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-ws/client&apos;</span>)\\n<span class=\\"hljs-comment\\">// OR: require(&apos;pull-ws&apos;).connect</span>\\n\\nconnect(WS_URL, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, stream</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">throw</span> err <span class=\\"hljs-comment\\">//handle err</span>\\n  pull(source, stream, sink)\\n})</code></pre>\\n<h2>example - server</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> createServer = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-ws/server&apos;</span>)\\ncreateServer(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{\\n  <span class=\\"hljs-comment\\">//pipe the stream somewhere.</span>\\n  <span class=\\"hljs-comment\\">//eg, echo server</span>\\n  pull(stream, stream)\\n}).listen(PORT)</code></pre>\\n<h2>api</h2>\\n<h3><code>connect = require(&apos;pull-ws/client&apos;)</code></h3>\\n<p><code>connect(url, cb | {binary: boolean, onConnect: cb})</code></p>\\n<p>Create a websocket client connection. set binary: true\\nto get a stream of arrayBuffers (on the browser).\\ndefaults to true on node, but to strings on the browser.\\nthis may cause a problems if your application assumes binary.</p>\\n<p>else, just provide the callback.</p>\\n<pre><code class=\\"hljs language-js\\">connect(url, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, stream</span>) </span>{\\n  ...\\n})</code></pre>\\n<h3><code>createServer = require(&apos;pull-ws/server&apos;)</code></h3>\\n<p>create pull stream websocket servers.\\nthe servers take a lot more options than clients.</p>\\n<p><code>createServer(opts?, onConnection)</code></p>\\n<p><code>onConnect(stream)</code> is called every time a connection is received.</p>\\n<p><code>opts</code> takes the same server options as <a href=\\"https://github.com/websockets/ws/blob/master/doc/ws.md#new-wsserveroptions-callback\\">ws module</a></p>\\n<h4>example</h4>\\n<p>one duplex service you may want to use this with is <a href=\\"https://github.com/dominictarr/muxrpc\\">muxrpc</a></p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> ws = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-ws-server&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\nws.createServer(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{\\n  <span class=\\"hljs-comment\\">//pipe duplex style to your service.</span>\\n  pull(stream, service.createStream(), stream)\\n})\\n.listen(<span class=\\"hljs-number\\">9999</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> stream = ws.connect(<span class=\\"hljs-string\\">&apos;ws://localhost:9999&apos;</span>)\\n\\npull(stream, client.createStream(), stream)</code></pre>\\n<p>if the connection fails, the first read from the stream will be an error,\\notherwise, to get a handle of stream end/error pass a callback to connect.</p>\\n<pre><code class=\\"hljs language-js\\">ws.connect(<span class=\\"hljs-string\\">&apos;ws://localhost:9999&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, stream</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">return</span> handleError(err)\\n  <span class=\\"hljs-comment\\">//stream is now ready</span>\\n})</code></pre>\\n<p>To run the server over TLS:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> tlsOpts = {\\n  <span class=\\"hljs-attr\\">key</span>: fs.readFileSync(<span class=\\"hljs-string\\">&apos;test/fixtures/keys/agent2-key.pem&apos;</span>),\\n  <span class=\\"hljs-attr\\">cert</span>: fs.readFileSync(<span class=\\"hljs-string\\">&apos;test/fixtures/keys/agent2-cert.pem&apos;</span>)\\n};\\nws.createServer(tlsOpts, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{\\n  <span class=\\"hljs-comment\\">//pipe duplex style to your service.</span>\\n  pull(stream, service.createStream(), stream)\\n})\\n.listen(<span class=\\"hljs-number\\">9999</span>)</code></pre>\\n<p>To add client-authentication to the server, you can set <code>verifyClient</code>.\\n<a href=\\"https://github.com/websockets/ws/blob/master/doc/ws.md#optionsverifyclient\\">Documentation here</a>.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">verifyClient</span> (<span class=\\"hljs-params\\">info</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> info.secure == <span class=\\"hljs-literal\\">true</span>\\n}\\nws.createServer({ <span class=\\"hljs-attr\\">verifyClient</span>: verifyClient }, onStream)</code></pre>\\n<h2>use with an http server</h2>\\n<p>if you have an http server that you also need to serve stuff\\nover, and want to use a single port, use the <code>server</code> option.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> http = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;http&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> server = http.createServer(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">req, res</span>)</span>{...}).listen(....)\\nws.createServer({<span class=\\"hljs-attr\\">server</span>: server}, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{ ... })</code></pre>\\n<h3>core, websocket wrapping functions</h3>\\n<p>these modules are used internally, to wrap a websocket.\\nyou probably won&apos;t need to touch these,\\nbut they are documented anyway.</p>\\n<h3><code>require(&apos;pull-ws/duplex&apos;)(socket, opts?)</code></h3>\\n<p>turn a websocket into a duplex pull stream.\\nIf provided, <code>opts</code> is passed to <code>pws.sink(socket, opts)</code>.</p>\\n<p>Websockets do not support half open mode.\\n<a href=\\"http://nodejs.org/api/net.html#net_net_createserver_options_connectionlistener\\">see allowHalfOpen option in net module</a></p>\\n<p>If you have a protocol that assumes halfOpen connections, but are using\\na networking protocol like websockets that does not support it, I suggest\\nusing <a href=\\"https://github.com/dominictarr/pull-goodbye\\">pull-goodbye</a> with your\\nprotocol.</p>\\n<p>The duplex stream will also contain a copy of the properties from\\nthe http request that became the websocket. they are <code>method</code>, <code>url</code>,\\n<code>headers</code> and <code>upgrade</code>.</p>\\n<p>also exposed at: <code>var duplex = require(&apos;pull-ws&apos;)</code></p>\\n<h3><code>require(&apos;pull-ws/sink&apos;)(socket, opts?)</code></h3>\\n<p>Create a pull-stream <code>Sink</code> that will write data to the <code>socket</code>.\\n<code>opts</code> may be <code>{closeOnEnd: true, onClose: onClose}</code>.\\n<code>onClose</code> will be called when the sink ends. If <code>closeOnEnd=false</code>\\nthe stream will not close, it will just stop emitting data.\\n(by default <code>closeOnEnd</code> is true)</p>\\n<p>If <code>opts</code> is a function, then <code>onClose = opts; opts.closeOnEnd = true</code>.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>);\\n<span class=\\"hljs-keyword\\">var</span> wsSink = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-ws&apos;</span>);\\n\\n<span class=\\"hljs-comment\\">// connect to the echo endpoint for test/server.js</span>\\n<span class=\\"hljs-keyword\\">var</span> socket = <span class=\\"hljs-keyword\\">new</span> WebSocket(<span class=\\"hljs-string\\">&apos;wss://echo.websocket.org&apos;</span>);\\n\\n<span class=\\"hljs-comment\\">// write values to the socket</span>\\npull(\\n  pull.infinite(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-string\\">&apos;hello @ &apos;</span> + <span class=\\"hljs-built_in\\">Date</span>.now()\\n  }),\\n  <span class=\\"hljs-comment\\">// throttle so it doesn&apos;t go nuts</span>\\n  pull.asyncMap(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">value, cb</span>) </span>{\\n    setTimeout(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>) </span>{\\n      cb(<span class=\\"hljs-literal\\">null</span>, value);\\n    }, <span class=\\"hljs-number\\">100</span>);\\n  }),\\n  wsSink(socket)\\n);\\n\\nsocket.addEventListener(<span class=\\"hljs-string\\">&apos;message&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">evt</span>) </span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;received: &apos;</span> + evt.data);\\n});</code></pre>\\n<p>also exposed at <code>require(&apos;pull-ws&apos;).sink</code></p>\\n<h3><code>require(&apos;pull-ws/source&apos;)(socket)</code></h3>\\n<p>Create a pull-stream <code>Source</code> that will read data from the <code>socket</code>.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>);\\n\\n<span class=\\"hljs-comment\\">// we just need the source, so cherrypick</span>\\n<span class=\\"hljs-keyword\\">var</span> wsSource = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-ws/source&apos;</span>);\\n\\npull(\\n  <span class=\\"hljs-comment\\">// connect to the test/server.js endpoint</span>\\n  wsSource(<span class=\\"hljs-keyword\\">new</span> WebSocket(<span class=\\"hljs-string\\">&apos;ws://localhost:3000/read&apos;</span>)),\\n  pull.log()\\n);</code></pre>\\n<p>also exposed at <code>require(&apos;pull-ws&apos;).source</code></p>\\n<h2>LICENSE</h2>\\n<p>MIT</p>\\n","contributors":[0,35,19,12,49,3,24,6],"version":"3.2.9","npmName":"pull-ws","category":"networks"},{"user":"pull-stream","name":"pull-ws-server","path":"pull-stream/pull-ws-server","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-ws-server\\">pull-ws-server</a><div class=\\"contrib\\"></div></h1>\\n<p>use <a href=\\"https://github.com/pull-stream/pull-ws\\">pull-ws</a> instead.</p>\\n<p>create pull stream websockets, servers, and clients.</p>\\n<h2>example</h2>\\n<p>one duplex service you may want to use this with is <a href=\\"https://github.com/dominictarr/muxrpc\\">muxrpc</a></p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> ws = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-ws-server&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\nws.createServer(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{\\n  <span class=\\"hljs-comment\\">//pipe duplex style to your service.</span>\\n  pull(stream, service.createStream(), stream)\\n})\\n.listen(<span class=\\"hljs-number\\">9999</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> stream = ws.connect(<span class=\\"hljs-string\\">&apos;ws://localhost:9999&apos;</span>)\\n\\npull(stream, client.createStream(), stream)</code></pre>\\n<p>if the connection fails, the first read from the stream will be an error,\\notherwise, to get a handle of stream end/error pass a callback to connect.</p>\\n<pre><code class=\\"hljs language-js\\">ws.connect(<span class=\\"hljs-string\\">&apos;ws://localhost:9999&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, stream</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">return</span> handleError(err)\\n  <span class=\\"hljs-comment\\">//stream is now ready</span>\\n})</code></pre>\\n<p>To run the server over TLS:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> tlsOpts = {\\n  <span class=\\"hljs-attr\\">key</span>: fs.readFileSync(<span class=\\"hljs-string\\">&apos;test/fixtures/keys/agent2-key.pem&apos;</span>),\\n  <span class=\\"hljs-attr\\">cert</span>: fs.readFileSync(<span class=\\"hljs-string\\">&apos;test/fixtures/keys/agent2-cert.pem&apos;</span>)\\n};\\nws.createServer(tlsOpts, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{\\n  <span class=\\"hljs-comment\\">//pipe duplex style to your service.</span>\\n  pull(stream, service.createStream(), stream)\\n})\\n.listen(<span class=\\"hljs-number\\">9999</span>)</code></pre>\\n<p>To add client-authentication to the server, you can set <code>verifyClient</code>.\\n<a href=\\"https://github.com/websockets/ws/blob/master/doc/ws.md#optionsverifyclient\\">Documentation here</a>.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">verifyClient</span> (<span class=\\"hljs-params\\">info</span>) </span>{\\n  <span class=\\"hljs-keyword\\">return</span> info.secure == <span class=\\"hljs-literal\\">true</span>\\n}\\nws.createServer({ <span class=\\"hljs-attr\\">verifyClient</span>: verifyClient }, onStream)</code></pre>\\n<h2>use with an http server</h2>\\n<p>if you have an http server that you also need to serve stuff\\nover, and want to use a single port, use the <code>server</code> option.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> http = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;http&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> server = http.createServer(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">req, res</span>)</span>{...}).listen(....)\\nws.createServer({<span class=\\"hljs-attr\\">server</span>: server}, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{ ... })</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,19,24,50],"version":"1.9.7","npmName":"pull-ws-server","category":"networks"},{"user":"ssbc","name":"muxrpc","path":"ssbc/muxrpc","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/ssbc/muxrpc\\">muxrpc</a><div class=\\"contrib\\"></div></h1>\\n<p>combined rpc and multiplexing, with pull-streams.</p>\\n<p><a href=\\"http://travis-ci.org/ssbc/muxrpc\\"></a></p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> MRPC = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;muxrpc&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\n<span class=\\"hljs-comment\\">//we need a manifest of methods we wish to expose.</span>\\n<span class=\\"hljs-keyword\\">var</span> api = {\\n  <span class=\\"hljs-comment\\">//async is a normal async function</span>\\n  hello: <span class=\\"hljs-string\\">&apos;async&apos;</span>,\\n\\n  <span class=\\"hljs-comment\\">//source is a pull-stream (readable)</span>\\n  stuff: <span class=\\"hljs-string\\">&apos;source&apos;</span>\\n\\n  <span class=\\"hljs-comment\\">//<span class=\\"hljs-doctag\\">TODO:</span> sink and duplex pull-streams</span>\\n}\\n\\n<span class=\\"hljs-comment\\">//pass the api into the constructor, and then pass the object you are wrapping</span>\\n<span class=\\"hljs-comment\\">//(if there is a local api)</span>\\n<span class=\\"hljs-keyword\\">var</span> client = MRPC(api, <span class=\\"hljs-literal\\">null</span>) () <span class=\\"hljs-comment\\">//remoteApi, localApi</span>\\n<span class=\\"hljs-keyword\\">var</span> server = MRPC(<span class=\\"hljs-literal\\">null</span>, api) ({\\n  <span class=\\"hljs-attr\\">hello</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">name, cb</span>) </span>{\\n    cb(<span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-string\\">&apos;hello, &apos;</span> + name + <span class=\\"hljs-string\\">&apos;!&apos;</span>)\\n  },\\n  <span class=\\"hljs-attr\\">stuff</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\"></span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> pull.values([<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-number\\">5</span>])\\n  }\\n})\\n\\n<span class=\\"hljs-comment\\">// pass in a cb for the stream end event</span>\\n<span class=\\"hljs-keyword\\">var</span> a = client.createStream(<span class=\\"hljs-built_in\\">console</span>.log.bind(<span class=\\"hljs-built_in\\">console</span>, <span class=\\"hljs-string\\">&apos;stream is closed&apos;</span>))\\n<span class=\\"hljs-keyword\\">var</span> b = server.createStream()\\n<span class=\\"hljs-comment\\">// or subscribe to the &apos;closed&apos; event</span>\\nb.once(<span class=\\"hljs-string\\">&apos;closed&apos;</span>, <span class=\\"hljs-built_in\\">console</span>.log.bind(<span class=\\"hljs-built_in\\">console</span>, <span class=\\"hljs-string\\">&apos;stream is closed&apos;</span>))\\n\\npull(a, b, a) <span class=\\"hljs-comment\\">//pipe together</span>\\n\\nclient.hello(<span class=\\"hljs-string\\">&apos;world&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, value</span>) </span>{\\n  <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">throw</span> err\\n  <span class=\\"hljs-built_in\\">console</span>.log(value)\\n  <span class=\\"hljs-comment\\">// hello, world!</span>\\n})\\n\\npull(client.stuff(), pull.drain(<span class=\\"hljs-built_in\\">console</span>.log))\\n<span class=\\"hljs-comment\\">// 1</span>\\n<span class=\\"hljs-comment\\">// 2</span>\\n<span class=\\"hljs-comment\\">// 3</span>\\n<span class=\\"hljs-comment\\">// 4</span>\\n<span class=\\"hljs-comment\\">// 5</span></code></pre>\\n<h2>Manifest</h2>\\n<p>like multilevel, a <a href=\\"https://github.com/juliangruber/multilevel#plugins\\">manifest is required</a>\\nexcept it works a little differently, and since muxrpc works with any api,\\nnot assuming leveldb then you must write the manifest yourself.</p>\\n<p>The manifest is simply an object mapping to strings, or nested objects.</p>\\n<pre><code class=\\"hljs language-js\\">{\\n  <span class=\\"hljs-attr\\">foo</span>: <span class=\\"hljs-string\\">&apos;async&apos;</span>,        <span class=\\"hljs-comment\\">//a function with a callback.</span>\\n  bar: <span class=\\"hljs-string\\">&apos;sync&apos;</span>,         <span class=\\"hljs-comment\\">//a function that returns a value</span>\\n                       <span class=\\"hljs-comment\\">//(note this is converted to an async function for the client)</span>\\n  allTheFoos: <span class=\\"hljs-string\\">&apos;source&apos;</span> <span class=\\"hljs-comment\\">//a source pull-stream (aka, readable)</span>\\n  writeFoos: <span class=\\"hljs-string\\">&apos;sink&apos;</span>,   <span class=\\"hljs-comment\\">//a sink pull-stream (aka, writable)</span>\\n  fooPhone: <span class=\\"hljs-string\\">&apos;duplex&apos;</span>,  <span class=\\"hljs-comment\\">//a duplex pull-stream</span>\\n\\n  <span class=\\"hljs-comment\\">//create nested objects like this:</span>\\n  bar: {\\n    ...\\n  }\\n}</code></pre>\\n<h2>Permissions</h2>\\n<p>If you are exposing an api over a network connection,\\nthen you probably want some sort of authorization system.\\n<code>muxrpc@4</code> and earlier had a <code>rpc.permissions()</code> method on\\nthe rpc object, but this has been removed.\\nNow you must pass a permissions function, which is called with\\nthe <code>name</code> (a path) and <code>args</code>, if this function does not throw\\nan error, then the call is allowed.</p>\\n<p>In some cases, a simple allow/deny list is sufficient.\\nA helper function, is provided, which was a part of muxrpc@4</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> Permissions = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;muxrpc/permissions&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> api = {\\n  <span class=\\"hljs-attr\\">foo</span>: <span class=\\"hljs-string\\">&apos;async&apos;</span>,\\n  <span class=\\"hljs-attr\\">bar</span>: <span class=\\"hljs-string\\">&apos;async&apos;</span>,\\n  <span class=\\"hljs-attr\\">auth</span>: <span class=\\"hljs-string\\">&apos;async&apos;</span>\\n}\\n\\n<span class=\\"hljs-comment\\">//set initial settings</span>\\n<span class=\\"hljs-keyword\\">var</span> perms = Perms({<span class=\\"hljs-attr\\">allow</span>: [<span class=\\"hljs-string\\">&apos;auth&apos;</span>]})\\n\\n<span class=\\"hljs-keyword\\">var</span> rpc = muxrpc(<span class=\\"hljs-literal\\">null</span>, api, serializer)({\\n  <span class=\\"hljs-attr\\">foo</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">val, cb</span>) </span>{\\n    cb(<span class=\\"hljs-literal\\">null</span>, {<span class=\\"hljs-attr\\">okay</span>: <span class=\\"hljs-string\\">&apos;foo&apos;</span>})\\n  },\\n  <span class=\\"hljs-attr\\">bar</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">val, cb</span>) </span>{\\n    cb(<span class=\\"hljs-literal\\">null</span>, {<span class=\\"hljs-attr\\">okay</span>: <span class=\\"hljs-string\\">&apos;bar&apos;</span>})\\n  },\\n  <span class=\\"hljs-attr\\">auth</span>: <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">pass</span>) </span>{\\n    <span class=\\"hljs-comment\\">//implement an auth function that sets the permissions,</span>\\n    <span class=\\"hljs-comment\\">//using allow or deny lists.</span>\\n\\n    <span class=\\"hljs-keyword\\">if</span>(pass === <span class=\\"hljs-string\\">&apos;whatever&apos;</span>)\\n      perms({<span class=\\"hljs-attr\\">deny</span>: [<span class=\\"hljs-string\\">&apos;bar&apos;</span>]}) <span class=\\"hljs-comment\\">//allow everything except &quot;bar&quot;</span>\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span>(pass === <span class=\\"hljs-string\\">&apos;s3cr3tz&apos;</span>)\\n      perms({}) <span class=\\"hljs-comment\\">//allow everything!!!</span>\\n    <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">return</span> cb(<span class=\\"hljs-keyword\\">new</span> <span class=\\"hljs-built_in\\">Error</span>(<span class=\\"hljs-string\\">&apos;ACCESS DENIED&apos;</span>))\\n\\n    <span class=\\"hljs-comment\\">//else we ARE authorized.</span>\\n    cb(<span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-string\\">&apos;ACCESS GRANTED&apos;</span>)\\n  }\\n}, perms)\\n\\n<span class=\\"hljs-comment\\">//Get a stream to connect to the remote. As in the above example!</span>\\n<span class=\\"hljs-keyword\\">var</span> ss = rpc.createStream()</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,19,51,9,6],"version":"6.3.3","npmName":"muxrpc","category":"networks"},{"user":"ssbc","name":"multiserver","path":"ssbc/multiserver","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/ssbc/multiserver\\">multiserver</a><div class=\\"contrib\\"></div></h1>\\n<p>A single interface that can work with multiple protocols,\\nand multiple transforms of those protocols (eg, security layer)</p>\\n<h2>address format</h2>\\n<p>Addresses describe everything needed to connect to a peer.\\neach address is divided into protocol sections separated by <code>~</code>.\\nEach protocol section is divided itself by <code>:</code>. A protocol section\\nstarts with a name for that protocol, and then whatever arguments\\nthat protocol needs.</p>\\n<p>For example, the address for my ssb pubserver is:</p>\\n<pre><code>net:wx.larpa.net:8008~shs:DTNmX+4SjsgZ7xyDh5xxmNtFqa6pWi5Qtw7cE8aR9TQ=\\n</code></pre>\\n<p>That says use the <code>net</code> protocol (TCP) to connect to the domain <code>wx.larpa.net</code>\\non port <code>8008</code>, and then encrypt the session using <code>shs</code> (<a href=\\"https://github.com/auditdrivencrypto/secret-handshake\\">secret-handshake</a>)\\nto the public key <code>DTNmX+4SjsgZ7xyDh5xxmNtFqa6pWi5Qtw7cE8aR9TQ=</code>.</p>\\n<p>Usually, the first section is a network protocol, and the rest are transforms,\\nsuch as encryption or compression.</p>\\n<p>Multiserver makes it easy to use multiple protocols at once. For example,\\nmy pub server <em>also</em> supports <code>shs</code> over websockets.</p>\\n<p>So, this is another way to connect:</p>\\n<pre><code>wss://wx.larpa.net~shs:DTNmX+4SjsgZ7xyDh5xxmNtFqa6pWi5Qtw7cE8aR9TQ=\\n</code></pre>\\n<h3>net</h3>\\n<p>TCP is <code>net:{host}:{port}</code> port is not optional.</p>\\n<h3>ws</h3>\\n<p>WebSockets is <code>ws://{host}:{port}?</code> port defaults to 80 if not provided.</p>\\n<p>WebSockets over https is <code>wss://{host}:{port}?</code> where port is\\n443 if not provided.</p>\\n<h3>onion</h3>\\n<p>Connect over tor using local proxy (9050). Onion is <code>onion:{host}:{port}</code> port is not optional.</p>\\n<h3>shs</h3>\\n<p>Secret-handshake is <code>shs:{public_key}:{seed}?</code>. <code>seed</code> is used to create\\na one-time shared private key, that may enable a special access.\\nFor example, you&apos;ll see that ssb invite codes have shs with two sections\\nfollowing. Normally, only a single argument (the remote public key) is necessary.</p>\\n<h3>TODO</h3>\\n<p>A short list of other protocols which could be implemented:</p>\\n<ul>\\n<li>cjdns</li>\\n<li>other encryption protocols...</li>\\n</ul>\\n<h2>motivation</h2>\\n<p>Developing a p2p system is hard. especially hard is upgrading protocol layers.\\nThe contemporary approach is to <a href=\\"https://whispersystems.org/blog/the-ecosystem-is-moving/\\">update code via a backdoor</a>,\\nbut as easily as security can be added, it can be taken away. We need an approach\\nto upgrading that is itself decentralized, and also does not accumulate legacy baggage.\\nafter upgrading past a version of the protocol, the system should be able to discard that\\nwithout a trace.</p>\\n<p>Traditionally, protocol versions are upgraded by negioating the version used in a handshake.\\nBut, how do you upgrade the handshake? You can&apos;t. This also tends to accumulate legacy, because\\nyou never know if you&apos;ll meet an old peer.</p>\\n<p>Some HTTP APIs provide upgradability a better, simpler way.\\nBy putting a version number within the url. A new version of\\nthe API can then be used without touching the old one at all.</p>\\n<p>I propose to adapt this approach to lower level protocols.\\nDo not negioate versions/ciphersuits in the handshake.\\nInstead, run multiple protocols at once, and &quot;lookup&quot; which\\nversions a peer supports currently. Most p2p systems have\\nsome sort of lookup system to find peers <em>anyway</em>\\n(might be DHT, a tracker server, or gossip),\\njust put version information in there.</p>\\n<p>There are two main situations where I expect this to be useful:\\nupgrading ciphers and bridging across enviroments that are\\notherwise cannot talk to each other (web browser to desktop)</p>\\n<h3>upgrade</h3>\\n<p>If a peer wants to upgrade from <em>weak</em> protocol\\nto a <em>strong</em> one, they simply start serving <em>strong</em> via another port,\\nand advertise that in the lookup system.\\nNow peers that have support for <em>strong</em> can connect via that protocol.</p>\\n<p>Once most peers have upgraded to strong, support for <em>weak</em> can be discontinued.</p>\\n<h3>bridging</h3>\\n<p>Regular servers can do TCP. Desktop clients can speak TCP,\\nbut can&apos;t create TCP servers reliably. Browsers can\\nuse WebSockets and WebRTC. WebRTC gives you p2p, but</p>\\n<p>needs an introducer. Another option is <a href=\\"https://github.com/mafintosh/utp-native\\">utp</a></p>\\n<ul>\\n<li>probably the most convienent, because it doesn&apos;t need an introducer\\non <em>every connection</em> (but it does require some bootstrapping),\\nbut that doesn&apos;t work in the browser either.</li>\\n</ul>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> MultiServer = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;multiserver&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> ms = MultiServer([\\n  <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;multiserver/plugins/net&apos;</span>)({<span class=\\"hljs-attr\\">port</span>: <span class=\\"hljs-number\\">1234</span>}),\\n  <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;multiserver/plugins/ws&apos;</span>)({<span class=\\"hljs-attr\\">port</span>: <span class=\\"hljs-number\\">2345</span>})\\n])\\n\\n<span class=\\"hljs-comment\\">//start a server (for both protocols!)</span>\\n<span class=\\"hljs-comment\\">//returns function to close the server.</span>\\n<span class=\\"hljs-keyword\\">var</span> close = ms.server(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{\\n  <span class=\\"hljs-comment\\">//handle incoming connection</span>\\n})\\n\\n<span class=\\"hljs-comment\\">//connect to a protocol. uses whichever</span>\\n<span class=\\"hljs-comment\\">//handler understands the address (in this case, websockets)</span>\\n<span class=\\"hljs-keyword\\">var</span> abort = ms.client(<span class=\\"hljs-string\\">&apos;ws://localhost:1234&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, stream</span>) </span>{\\n  <span class=\\"hljs-comment\\">//...</span>\\n})\\n\\n<span class=\\"hljs-comment\\">//at any time abort() can be called to cancel the connection attempt.</span>\\n<span class=\\"hljs-comment\\">//if it&apos;s called after the connection is established, it will</span>\\n<span class=\\"hljs-comment\\">//abort the stream.</span></code></pre>\\n<h3>example - server with two security protocols</h3>\\n<p>This is just how some services (eg, github) have an API version\\nin their URL scheme. It is now easy to use two different\\nversions in parallel. later, they can close down the old API.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> MultiServer = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;multiserver&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> ms = MultiServer([\\n  [ <span class=\\"hljs-comment\\">//net + secret-handshake</span>\\n    <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;multiserver/plugins/net&apos;</span>)({<span class=\\"hljs-attr\\">port</span>: <span class=\\"hljs-number\\">3333</span>}),\\n    <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;secret-handshake-multiserver&apos;</span>)({\\n      <span class=\\"hljs-attr\\">keys</span>: <span class=\\"hljs-comment\\">//keypair</span>\\n      appKey: <span class=\\"hljs-comment\\">//application key</span>\\n      auth: <span class=\\"hljs-comment\\">//auth function (only needed for server)</span>\\n    }),\\n  ],\\n  [ <span class=\\"hljs-comment\\">//net + secret-handshake2</span>\\n    <span class=\\"hljs-comment\\">//(not implemented yet, but incompatible with shs)</span>\\n    <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;multiserver/plugins/net&apos;</span>)({<span class=\\"hljs-attr\\">port</span>: <span class=\\"hljs-number\\">4444</span>}),\\n    <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;secret-handshake2-multiserver&apos;</span>)({\\n      <span class=\\"hljs-attr\\">keys</span>: <span class=\\"hljs-comment\\">//keypair</span>\\n      appKey: <span class=\\"hljs-comment\\">//application key</span>\\n      auth: <span class=\\"hljs-comment\\">//auth function (only needed for server)</span>\\n    }),\\n  ]\\n]\\n\\n<span class=\\"hljs-built_in\\">console</span>.log(ms.stringify())\\n\\n<span class=\\"hljs-comment\\">//=&gt; net:&lt;host&gt;:3333~shs:&lt;key&gt;;net:&lt;host&gt;:4444~shs2:&lt;key&gt;</span>\\n\\n<span class=\\"hljs-comment\\">//run two servers on two ports.</span>\\n<span class=\\"hljs-comment\\">//newer peers can connect directly to 4444 and use shs2.</span>\\n<span class=\\"hljs-comment\\">//this means the protocol can be _completely_ upgraded.</span>\\nms.server(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{\\n\\n})\\n\\n<span class=\\"hljs-comment\\">//connect to legacy protocol</span>\\nms.client(<span class=\\"hljs-string\\">&apos;net:&lt;host&gt;:3333~shs:&lt;key&gt;&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, stream</span>) </span>{\\n  <span class=\\"hljs-comment\\">//...</span>\\n})\\n\\n<span class=\\"hljs-comment\\">//connect to modern protocol</span>\\nms.client(<span class=\\"hljs-string\\">&apos;net:&lt;host&gt;:4444~shs2:&lt;key&gt;&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, stream</span>) </span>{\\n  <span class=\\"hljs-comment\\">//...</span>\\n})</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,52,53,54],"version":"1.11.0","npmName":"multiserver","category":"networks"},{"user":"pull-stream","name":"pull-http-server","path":"pull-stream/pull-http-server","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-http-server\\">pull-http-server</a><div class=\\"contrib\\"></div></h1>\\n<p>create http servers in pull streamy ways</p>\\n<pre><code class=\\"hljs language-shell\\">npm install --save pull-http-server</code></pre>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-javascript\\"><span class=\\"hljs-keyword\\">var</span> summary = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;server-summary&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> createServer = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-http-server&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> server = createServer(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">stream</span>) </span>{\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;method&apos;</span>, stream.source.method)\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;url&apos;</span>, stream.source.url)\\n  <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;headers&apos;</span>, stream.source.headers)\\n\\n  pull(\\n    stream,\\n    pull.map(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">buffer</span>) </span>{\\n      <span class=\\"hljs-keyword\\">var</span> string = buffer.toString()\\n      <span class=\\"hljs-keyword\\">var</span> upper = string.toUpperCase()\\n      <span class=\\"hljs-keyword\\">return</span> Buffer(upper)\\n    }),\\n    stream\\n  )\\n})\\n\\nserver.listen(<span class=\\"hljs-number\\">5000</span>, summary(server))</code></pre>\\n<pre><code class=\\"hljs language-shell\\">curl -d &quot;asdfjkl&quot; http://localhost:5000</code></pre>\\n<h2>usage</h2>\\n<h3><code>createServer = require(&apos;pull-http-server&apos;)</code></h3>\\n<h3><code>server = createServer(requestHandler)</code></h3>\\n<p><code>requestHandler</code> receives <code>duplex</code> pull stream (with <code>source</code> and <code>sink</code> properties).</p>\\n<ul>\\n<li><code>source</code> has same properties as <a href=\\"https://nodejs.org/api/http.html#http_class_http_incomingmessage\\"><code>http.IncomingMessage</code></a></li>\\n<li><code>sink</code> has same properties as <a href=\\"https://nodejs.org/api/http.html#http_class_http_serverresponse\\"><code>http.ServerResponse</code></a></li>\\n</ul>\\n<p>returns node <a href=\\"https://nodejs.org/api/http.html#http_class_http_server\\"><code>http.Server</code></a>.</p>\\n<h2>license</h2>\\n<p>The Apache License</p>\\n<p>Copyright &#xA9; 2016 Michael Williams</p>\\n<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\\nyou may not use this file except in compliance with the License.\\nYou may obtain a copy of the License at</p>\\n<pre><code>http://www.apache.org/licenses/LICENSE-2.0\\n</code></pre>\\n<p>Unless required by applicable law or agreed to in writing, software\\ndistributed under the License is distributed on an &quot;AS IS&quot; BASIS,\\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\nSee the License for the specific language governing permissions and\\nlimitations under the License.</p>\\n","contributors":[3],"version":"1.0.0","npmName":"pull-http-server","category":"networks"},{"user":"regular","name":"pull-paginated-api-request","path":"regular/pull-paginated-api-request","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/regular/pull-paginated-api-request\\">pull-paginated-api-request</a><div class=\\"contrib\\"></div></h1>\\n<p>Use this pull-stream to lazily traverse a paginated (REST) API\\n</p>\\n<h2>Simple Usage</h2>\\n<pre><code class=\\"hljs language-js\\">    <span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>);\\n    <span class=\\"hljs-keyword\\">var</span> paginated = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-paginated-api-request&apos;</span>);\\n    ver querystring = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;querystring&apos;</span>);\\n    <span class=\\"hljs-keyword\\">var</span> extend = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;xtend&apos;</span>);\\n    <span class=\\"hljs-keyword\\">var</span> hyperquest = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;hyperquest&apos;</span>)\\n\\n    <span class=\\"hljs-keyword\\">var</span> request = paginated(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\">o, pageToken</span>) </span>{\\n        <span class=\\"hljs-keyword\\">return</span> hyperquest(o.endpoint + <span class=\\"hljs-string\\">&apos;?&apos;</span> + querystring.stringify(\\n            extend({o.query, pageToken ? {<span class=\\"hljs-attr\\">pageToken</span>: pageToken} : {})\\n        ));\\n    });\\n\\n    pull(\\n        request({\\n            <span class=\\"hljs-attr\\">endpoint</span>: <span class=\\"hljs-string\\">&apos;https://api.whatever.com/playlistItems&apos;</span>,\\n            <span class=\\"hljs-attr\\">query</span>: {\\n                <span class=\\"hljs-attr\\">playlistId</span>: id,\\n                <span class=\\"hljs-attr\\">maxResults</span>: <span class=\\"hljs-number\\">50</span>\\n            }\\n        },\\n        [\\n            [<span class=\\"hljs-string\\">&apos;items&apos;</span>, <span class=\\"hljs-literal\\">true</span>], \\n            [<span class=\\"hljs-string\\">&apos;nextPageToken&apos;</span>]\\n        ]),\\n        pull.log()\\n    );\\n\\n    <span class=\\"hljs-comment\\">// outputs all playlist items until a REST API response</span>\\n    <span class=\\"hljs-comment\\">// does not contain a nextPageToken proerty</span></code></pre>\\n<p>See <a href=\\"https://github.com/regular/liked-on-youtube\\">regular/liked-on-youtube</a> for a real-life example.</p>\\n<h2>API</h2>\\n<h3>paginated(makeResponseStream)</h3>\\n<p>Returns a request function that can be used to query the API.\\nTakes a factory function that provides the response of an API server as a Node-style ReadableStream. The arguments of the factory-function are:</p>\\n<ul>\\n<li>\\n<p>makeResponseStream(obj, pageToken)</p>\\n<ul>\\n<li>obj - an ojbect (opaque to pull-paginated-api-request) (see below)</li>\\n<li>pageToken: the token of the result page to request (see below)</li>\\n<li>please return a Node-style ReadStream. (Hint: use hyperquest, it works in Node and in the browser)</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>request(obj, [itemPathway, nextPageTokenPathway])</h2>\\n<p>This is the function retruned by <code>paginated</code> (see above). The first argument <code>obj</code> will simply be forwarded to <code>makeResponseStream</code>. The second argument is an array of <code>pathways</code>. They describe where to find the items (the stuff that we are interessted in) and the token of the next page of API results. The pathways themselves are arrays. They describe the location of those two properties within the JSON-formatted response of the API server. See <a href=\\"https://github.com/substack/node-pathway\\">pathway</a> for details.</p>\\n<p><code>request</code> returns a pull-stream source. It generates output only when that output is consumed. This means that only those result pages get requested from the server that actually are needed. See <a href=\\"https://github.com/dominictarr/pull-stream\\">Dominic Tarr&apos;s pull-stream</a> to learn more about pull-streams and the power of laziness.</p>\\n<h2>Advanced Usage</h2>\\n<p>Instead of specifying an array of pathways, you can provide your own function to extract properties from the server response. This is also how you extract a pageToken from the HTTP headers (used by GitHub for example). See <a href=\\"https://github.com/regular/pull-paginated-api-request/blob/master/test.js#L89\\">test.js</a> for details.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[1],"version":"1.1.0","npmName":"pull-paginated-api-request","category":"networks"},{"user":"jamen","name":"pull-fetch","path":"jamen/pull-fetch","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/jamen/pull-fetch\\">pull-fetch</a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>A pull-stream HTTP client for Node.js</p>\\n</blockquote>\\n<h2>Install</h2>\\n<pre><code>npm i pull-fetch\\n</code></pre>\\n<h2>Usage</h2>\\n<h3><code>fetch(options)</code></h3>\\n<p>Make an HTTP request.  Options are the same as <a href=\\"https://nodejs.org/api/http.html\\"><code>http.request</code></a>.  If it HTTPS it will switch the function.</p>\\n<p>Returns a <a href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/spec.md#sink-streams\\"><code>pull-stream</code> sink</a> that reads data for the request.  If the request has not body (e.g. a GET request) then function returned can be called with nothing to proceed with the response.</p>\\n<p>Then the stream returns a promise that resolves into a response object.  It contains any property <a href=\\"https://nodejs.org/api/http.html#http_class_http_incomingmessage\\"><code>http.IncomingMessage</code></a> has, plus <code>source</code> for streaming the response data as a <a href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/spec.md#pull-streams\\"><code>pull-stream</code> source</a></p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">const</span> response = <span class=\\"hljs-keyword\\">await</span> fetch({\\n  <span class=\\"hljs-attr\\">host</span>: <span class=\\"hljs-string\\">&apos;api.example.com&apos;</span>,\\n  <span class=\\"hljs-attr\\">path</span>: <span class=\\"hljs-string\\">&apos;/foobar&apos;</span>,\\n  <span class=\\"hljs-attr\\">method</span>: <span class=\\"hljs-string\\">&apos;POST&apos;</span>\\n})(\\n  values([ <span class=\\"hljs-string\\">&apos;hello&apos;</span>, <span class=\\"hljs-string\\">&apos;world&apos;</span> ])\\n)\\n\\n<span class=\\"hljs-built_in\\">console</span>.log(response.headers)\\n\\ncollect(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">err, data</span>) =&gt;</span> {\\n  data = Buffer.join(data).toString()\\n  consle.log(data)\\n})(response.source)</code></pre>\\n<p>Or with no body:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">const</span> response = <span class=\\"hljs-keyword\\">await</span> fetch(<span class=\\"hljs-string\\">&apos;https://api.example.com/foobar&apos;</span>)()\\n\\n<span class=\\"hljs-built_in\\">console</span>.log(response.headers)\\n\\ndrain(<span class=\\"hljs-function\\"><span class=\\"hljs-params\\">x</span> =&gt;</span> process.stdout.write(x))(response.source)</code></pre>\\n<p>Combining pull-streams and promises give an intuitive way to handle the requests.  There is little to no overhead with Node&apos;s APIs.</p>\\n","contributors":[10,1,29],"version":"1.0.1","npmName":"pull-fetch","category":"networks"},{"user":"ahdinosaur","name":"pull-xhr","path":"ahdinosaur/pull-xhr","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/ahdinosaur/pull-xhr\\">pull-xhr</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\\"><code>window.XMLHttpRequest</code></a> as a (pseudo) <a href=\\"https://pull-stream.github.io\\"><code>pull-stream</code></a></p>\\n<pre><code class=\\"hljs language-shell\\">npm install --save pull-xhr</code></pre>\\n<p>only supports modern browsers and IE 10+</p>\\n<h2>api</h2>\\n<h3><code>Xhr = require(&apos;pull-xhr&apos;)</code></h3>\\n<p><code>request</code> (<code>req</code>) is an object with:</p>\\n<ul>\\n<li><code>url</code>: default <code>&apos;&apos;</code> - string to remote location to <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open\\">open</a></li>\\n<li><code>method</code>: default <code>&apos;GET&apos;</code> - string of http method to <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open\\">open</a></li>\\n<li><code>responseType</code>: default <code>&apos;text&apos;</code> - string of <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText\\">response type</a></li>\\n<li><code>headers</code>: default <code>{}</code> - object to <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\\">set request header names to values</a></li>\\n<li><code>body</code>: default <code>null</code> - object to <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send\\">send as request</a></li>\\n<li><code>json</code>: object to be stringified as json request body</li>\\n<li><code>beforeOpen</code>: function <code>(xhr) =&gt; {}</code> called before <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open\\">open</a></li>\\n<li><code>beforeSend</code>: function <code>(xhr) =&gt; {}</code> called before <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send\\">send</a></li>\\n</ul>\\n<p><code>response</code> (<code>res</code>) is an object with:</p>\\n<ul>\\n<li><code>headers</code>: object from <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders\\">received response header names to values</a></li>\\n<li><code>body</code>: object from <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/response\\">response body</a></li>\\n<li><code>statusCode</code>: number from <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status\\">response status code</a></li>\\n<li><code>statusMessage</code>: string from <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/statusText\\">response status</a></li>\\n<li><code>url</code>: string to remote location to <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open\\">open</a></li>\\n<li><code>method</code>: string of http method to <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open\\">open</a></li>\\n<li><code>xhr</code>: <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\\">raw XMLHttpRequest instance</a></li>\\n</ul>\\n<h3><code>Xhr.async(req, cb(err, res.body, res))</code></h3>\\n<p>don&apos;t use streams at all. just ask a question and get an answer.</p>\\n<h3><code>Xhr.source(req, cb (err, res)) =&gt; source</code></h3>\\n<p>use for downloads. the source is the res</p>\\n<p>if <code>req.responseType === &apos;json&apos;</code> the source will be parsed from <a href=\\"https://github.com/dominictarr/pull-json-doubleline\\">double newline delimited json</a>.</p>\\n<h3><code>Xhr.sink(req, cb(err, res.body, res)) =&gt; sink</code></h3>\\n<p>use for uploads. the sink is the req.</p>\\n<p>if the first chunk in the source to the sink is not a <a href=\\"https://github.com/feross/buffer\\">Buffer</a>, the source will be stringified to <a href=\\"https://github.com/dominictarr/pull-json-doubleline\\">double newline delimited json</a>.</p>\\n<p>then everything is <a href=\\"https://nodejs.org/api/buffer.html#buffer_class_method_buffer_concat_list_totallength\\">concat</a> and sent as an <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/ArrayBuffer\\">ArrayBuffer</a>.</p>\\n<h2>license</h2>\\n<p>The Apache License</p>\\n<p>Copyright &#xA9; 2016 Michael Williams</p>\\n<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\\nyou may not use this file except in compliance with the License.\\nYou may obtain a copy of the License at</p>\\n<pre><code>http://www.apache.org/licenses/LICENSE-2.0\\n</code></pre>\\n<p>Unless required by applicable law or agreed to in writing, software\\ndistributed under the License is distributed on an &quot;AS IS&quot; BASIS,\\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\nSee the License for the specific language governing permissions and\\nlimitations under the License.</p>\\n","contributors":[3],"version":"1.0.6","npmName":"pull-xhr","category":"networks"},{"user":"elavoie","name":"pull-sync","path":"elavoie/pull-sync","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/elavoie/pull-sync\\">pull-sync</a><div class=\\"contrib\\"></div></h1>\\n<p>Synchronizes pull-streams that are connected by an unsynchronized transport, one\\nvalue at a time.</p>\\n<ul>\\n<li>Provides transparent back-pressure even if the transport does not provide it. </li>\\n<li>Works with WebSockets when used with pull-ws.</li>\\n</ul>\\n<p>Useful for working with infinite streams and for transparently splitting the\\nprocessing of a stream between server and client.</p>\\n<p>Both the client and the server need to be synchronized. Otherwise, if only one\\nend is synchronized, the other end will receive messages it does not\\nunderstand.</p>\\n<p>For a different solution that may provide better throughput, see\\n<a href=\\"https://github.com/dominictarr/pull-credit\\">pull-credit</a>.</p>\\n<h2>Quick Example</h2>\\n<pre><code>var ws = require(&apos;pull-ws&apos;)\\nvar pull = require(&apos;pull-stream&apos;)\\nvar sync = require(&apos;../src/&apos;)\\n\\nfunction delay (ms) {\\n    return pull.asyncMap(function (data, cb) {\\n        setTimeout(function () { cb(null, data) }, ms)\\n    })\\n}\\n\\nvar server = ws.createServer(function (stream) {\\nstream = sync(stream)\\npull(\\n    stream,\\n    pull.map(function (x) {\\n    return Number.parseInt(x) * 2\\n    }),\\n    pull.map(String),\\n    stream\\n)\\n}).listen(5000)\\n.on(&apos;listening&apos;, function () {\\n    ws.connect(&apos;ws://localhost:5000&apos;, function (err, stream) {\\n    if (err) throw err\\n\\n    stream = sync(stream)\\n\\n    // Prints 0,0,1,2,2,4,3,6 regardless of the relative\\n    // speed of client and server and the transportation delay\\n    pull(\\n        pull.count(3),\\n        pull.map(String),\\n        pull.through(console.log),\\n        stream,\\n        pull.through(console.log),\\n        delay(500),\\n        pull.drain(null, function () { server.close() })\\n    )\\n    })\\n})\\n</code></pre>\\n<h2>Signature</h2>\\n<p>The following signature follows the <a href=\\"https://github.com/elavoie/js-module-signature-syntax\\">js module signature\\nsyntax</a> and conventions.\\nAll callbacks (&apos;cb&apos;) have the &apos;(err, value)&apos; signature.</p>\\n<pre><code>sync: (stream: {\\n    source: (abort, cb),\\n    sink: (read: (abort, cb)),\\n    ?...\\n}) =&gt;\\nsyncStream: {\\n    sink: (read: (abort, cb)),\\n    source: (abort, cb),\\n    ?...\\n}\\n</code></pre>\\n<h2>Properties</h2>\\n<ol>\\n<li>If <em>stream.source</em> or <em>stream.sink:read</em> aborts, <em>syncStream.sink</em> aborts and <em>syncStream.source:cb</em> always returns closed (err === true).</li>\\n<li>Extra methods on <em>stream</em> are also on <em>syncStream</em>.</li>\\n<li>Every event on syncStream has an equivalent message that will eventually be sent on <em>stream.sink</em> (see below in Approach).</li>\\n<li>Every message received from <em>stream.source</em> will eventually be converted into an event on <em>syncStream</em>.</li>\\n<li>No action on <em>syncStream</em> is initiated before receiving the corresponding message.</li>\\n</ol>\\n<h2>Approach</h2>\\n<p>Events on <em>syncStream</em> are sinked in the <em>stream</em> as one of these messages.\\nEvents are named with the &apos;object.property&apos; and &apos;function:argument&apos; syntax,\\nwith the &apos;object.property&apos; having higher precedence. Names refer to the\\nsignature above.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>SyncStream event</th>\\n<th>Message sent</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>syncStream.sink:read:cb:value</td>\\n<td>&apos;0&apos; + JSON.stringify(value)</td>\\n</tr>\\n<tr>\\n<td>syncStream.sink:read:cb:err</td>\\n<td>&apos;1&apos; + (err.message \\n|\\n|\\n true)</td>\\n</tr>\\n<tr>\\n<td>syncStream.source:null (value asked)</td>\\n<td>&apos;2&apos;</td>\\n</tr>\\n<tr>\\n<td>syncStream.source:abort</td>\\n<td>&apos;3&apos;</td>\\n</tr>\\n<tr>\\n<td>syncStream.sink:read assigned</td>\\n<td>&apos;4&apos;</td>\\n</tr>\\n<tr>\\n<td>initialization</td>\\n<td>&apos;5 pull-sync: missing sync&apos;</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>When receiving one of the messages, the following actions are invoked. The\\n&apos;function(argument)&apos; syntax is used for denoting the function being called with\\nwhat argument. Names refer to the signature above.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Message received</th>\\n<th>Action</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>&apos;0&apos; + value</td>\\n<td>syncStream.source:cb(null, JSON.parse(value))</td>\\n</tr>\\n<tr>\\n<td>&apos;1&apos; + (err.message \\n|\\n|\\n true)</td>\\n<td>syncStream.source:cb(err)</td>\\n</tr>\\n<tr>\\n<td>&apos;2&apos;</td>\\n<td>syncStream.sink:read(null, ...)</td>\\n</tr>\\n<tr>\\n<td>&apos;3&apos;</td>\\n<td>syncStream.sink:read(abort)</td>\\n</tr>\\n<tr>\\n<td>&apos;4&apos;</td>\\n<td>internally set remote status to ready</td>\\n</tr>\\n<tr>\\n<td>&apos;5 pull-sync: missing sync&apos;</td>\\n<td>internally set remote status to connected</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>In addition to establishing the connection, the &apos;5...&apos; message helps detecting a\\nmissing sync because it won&apos;t be consumed if the other end does not use sync().</p>\\n<p>The behavior when two syncStreams are connected through a duplex stream, such\\nas a WebSocket, is equivalent to:</p>\\n<pre><code>// Machine 1\\nvar syncStream1 = {\\n  sink: function (read) {\\n    syncStream1.read = read\\n  },\\n  source: function (abort, cb) {\\n    syncStream2.read(abort, cb)\\n  }\\n}\\n\\n// duplex stream (ex: WebSocket)\\n\\n// Machine 2\\nvar syncStream2 = {\\n  sink: function (read) {\\n    syncStream2.read = read\\n  },\\n  source: function (abort, cb) {\\n    syncStream1.read(abort, cb)\\n  }\\n}\\n</code></pre>\\n<p>Therefore values are flowing from <em>syncStream1.read</em> to <em>syncStream2.source</em>,\\nand from <em>syncStream2.read</em> to <em>syncStream1.source</em>.</p>\\n<p>A stream may flow transparently between two differents computers by inverting\\nthe order of the sink and the source on one end:</p>\\n<pre><code>// Machine 1\\npull(\\n  pull.count(),\\n  syncStream1,\\n  pull.drain()\\n)\\n\\n// duplex stream (ex: WebSocket)\\n\\n// Machine 2\\npull(\\n  syncStream2.source,\\n  pull.through(),\\n  syncStream2.sink \\n)\\n</code></pre>\\n","contributors":[28],"version":"2.0.2","npmName":"pull-sync","category":"networks"},{"user":"elavoie","name":"pull-limit","path":"elavoie/pull-limit","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/elavoie/pull-limit\\">pull-limit</a><div class=\\"contrib\\"></div></h1>\\n<p>Limits the total number of items inside a through pull-stream.</p>\\n<p>Defaults to 1. Once the limit has been reached, a newer item will be read only\\nafter a previous item has been drained.</p>\\n<p>Useful for limiting the rate of eager processing pipelines or for waiting for\\nanswers before sending more elements on a duplex transport, such as WebSockets.</p>\\n<h2>Quick Examples</h2>\\n<p>With a through pull-stream:</p>\\n<pre><code>var pull = require(&apos;pull-stream&apos;)\\nvar buffer = require(&apos;pull-eager-buffer&apos;)\\nvar limit = require(&apos;pull-limit&apos;)\\n\\n// Prints 0,0,1,1,2,2\\npull(\\n  pull.count(2),\\n  pull.through(console.log),\\n  limit(buffer()),\\n  pull.through(console.log),\\n  pull.drain()\\n)\\n</code></pre>\\n<p>With a WebSocket, so that only one value is in transit and processed at a time.\\nThe next value is only sent when the result has been received. Otherwise, the\\nsocket would eagerly pull all the values:</p>\\n<pre><code>var pull = require(&apos;pull-stream&apos;)\\nvar ws = require(&apos;pull-ws&apos;)\\nvar limit = require(&apos;pull-limit&apos;)\\n\\nvar server = ws.createServer(function (stream) {\\n  pull(\\n    stream, \\n    pull.map(function (x) { return x.toLowerCase() }), \\n    stream\\n)\\n}).listen(5000)\\n\\nws.connect(&apos;ws://localhost:5000&apos;, function (err, stream) {\\n  if (err) throw err\\n    \\n  // Prints &apos;A&apos;, &apos;a&apos;, &apos;B&apos;, &apos;b&apos;, &apos;C&apos;, &apos;c&apos;\\n  pull(\\n    pull.values([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]),\\n    pull.through(console.log),\\n    limit(stream),\\n    pull.through(console.log),\\n    pull.drain()      \\n  )\\n}) \\n</code></pre>\\n<h2>Signature</h2>\\n<p>The following signature follows the <a href=\\"https://github.com/elavoie/js-module-signature-syntax\\">js module signature\\nsyntax</a> and conventions.\\nAll callbacks (parameters ending with &apos;cb&apos;) have the &apos;(err, data)&apos; signature.\\n<br>\\nlimit: (stream: {\\nsink: (streamRead: (abort, streamSinkCb)),\\nsource: (abort, cb)\\n}, ?n: number) =&gt;\\n{\\nsink: (read (abort, sinkCb)),\\nupdateLimit: (l: number),\\non(&apos;flow-rate&apos;, cb(rate, elapsedTimeInSec, n),\\nsource: (abort, cb)\\n}</p>\\n<h2>Properties</h2>\\n<ol>\\n<li><em>read</em> is called once iff <em>streamRead</em> has been called.</li>\\n<li>The first time <em>streamRead</em> is called, <em>streamSinkCb</em> will complete with the\\nvalue coming from <em>sinkCb</em> as soon as it is available.</li>\\n<li>For every subsequent <em>streamRead</em> call, <em>streamSinkCb</em> will only complete\\neither after the stream closes or the number of elements sinked into\\n<em>stream.sink</em> but not sourced by <em>stream.source</em> is below n, with n having a\\ndefault value of 1.</li>\\n<li>After <em>updateLimit</em> has been called, the n now has the l value.</li>\\n<li>After <em>n</em> values have been processed, the &apos;flow-rate&apos; event with the rate at which values have been trhrough, is emited.</li>\\n</ol>\\n","contributors":[28],"version":"1.2.2","npmName":"pull-limit","category":"networks"},{"user":"elavoie","name":"pull-lend","path":"elavoie/pull-lend","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/elavoie/pull-lend\\">pull-lend</a><div class=\\"contrib\\"></div></h1>\\n<p>Lends one value at a time from a stream. Re-lends in case of errors.</p>\\n<p>A client borrows a value, processes it, and returns the result to the stream\\nlater.</p>\\n<ul>\\n<li>Supports multiple concurrent borrowers</li>\\n<li>Produces results in the order in which the sink reads the values</li>\\n<li>If a borrower returns an error rather than a result, the value is transparently lent to another borrower, continuing until a result is returned</li>\\n</ul>\\n<p>Useful for delegating processing to a dynamic number of concurrent,\\ncooperative, but unreliable clients.</p>\\n<h2>Quick Example</h2>\\n<pre><code>var pull = require(&apos;pull-stream&apos;)\\nvar lend = require(&apos;pull-lend&apos;)\\n\\nvar lender = lend()\\n\\nfunction minus (err, x, cb) {\\n  if (err) throw err\\n  setTimeout(function () {\\n    cb(null, -x)\\n  }, 500)\\n}\\n\\nfunction square (err, x, cb) {\\n  if (err) throw err\\n  cb(null, x * x)\\n}\\n\\nfunction crash (err, x, cb) {\\n  if (err) throw err\\n  cb(true)\\n}\\n\\n// Prints 0,1,2,-0,-1,4\\npull(\\n  pull.count(2),\\n  pull.through(console.log),\\n  lender,\\n  pull.through(console.log),\\n  pull.drain()\\n)\\n\\nlender.lend(minus)\\nlender.lend(crash)\\nlender.lend(minus)\\nlender.lend(square)\\n\\n// Prints &apos;closed with: true&apos;\\nlender.lend(function (err) {\\n  if (err) console.log(&apos;closed with: &apos; + err)\\n})\\n</code></pre>\\n<h2>Signature</h2>\\n<p>The following signature follows the <a href=\\"https://github.com/elavoie/js-module-signature-syntax\\">js module signature\\nsyntax</a> and conventions.\\nAll callbacks (&apos;cb&apos;) have the &apos;(err, value)&apos; signature.</p>\\n<pre><code>lend: () =&gt;\\nlender: {\\n    sink: (read: (abort, cb)),\\n    lend: (borrower: (err, value, cb)),\\n    source: (abort, cb)\\n}\\n</code></pre>\\n<h2>Properties</h2>\\n<ol>\\n<li>Each read is first initiated by a lend (but each lend does not necessarily\\nimply a read).</li>\\n<li>Multiple values may be lent concurrently by calling lend multiple times.</li>\\n<li>Once lend has been called:<br>\\n3.1 the borrower will eventually be called either with a value or an err;<br>\\n3.2 all borrowers will be called before the stream closes.</li>\\n<li>The source produces results in the order in which the values were read by\\nthe sink.</li>\\n<li>If a borrower returns an error, its input value will be given to another\\nborrower later.</li>\\n<li>When the borrower is called, err is truthy iff:<br>\\n6.1 the lender is not connected yet;<br>\\n6.2 the lender was closed by the source;<br>\\n6.3 all available values have been borrowed and  all results have been sourced.</li>\\n<li>For N values available for borrowing, it takes N successful borrowers and 1\\nextra lend call to close the lender.</li>\\n<li>If a borrower calls its <code>cb</code> multiple times, all subsequent calls after the first will be ignored.</li>\\n</ol>\\n<h2>Debugging</h2>\\n<p>You can obtain a trace of the internal events of the module by activating the logging using the <code>DEBUG=pull-lend</code> environment variable (see <a href=\\"http://npmjs.org/debug\\">debug</a>).</p>\\n<p>You can also obtain the internal state of the module at a specific point in time by calling the <code>_state()</code> method. It returns an object with the following properties:</p>\\n<pre><code>    {\\n      reading: Boolean,    // Currently reading a value from upstream\\n      aborted: Boolean,    // Aborted from downstream\\n      ended: Boolean,      // Upstream ended\\n      last: Number,        // Last index of the stream (0 until ended = true)\\n      readNb: Number,      // Number of values read from upstream\\n      sourcedNb: Number,   // Number of values sourced downstream\\n      lentNb: Number,      // Number of values lent that have not returned yet\\n      pendingNb: Number,   // Number of values returned not yet sourced\\n      delegatedNb: Number, // Number of values returned because of an error,\\n                           // awaiting to be lent again\\n      deferredNb: Number   // Number of borrowers waiting for a value\\n    }\\n</code></pre>\\n<p>The module maintains the following invariant:</p>\\n<pre><code>    readNb - sourcedNb = lentNb + pendingNb + delegatedNb\\n</code></pre>\\n<p>The output of the <code>_state()</code> method should not be relied on for regular operations because it depends on the implementation of the module and may change in the future.</p>\\n","contributors":[28],"version":"2.1.3","npmName":"pull-lend","category":"networks"},{"user":"elavoie","name":"pull-lend-stream","path":"elavoie/pull-lend-stream","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/elavoie/pull-lend-stream\\">pull-lend-stream</a><div class=\\"contrib\\"></div></h1>\\n<p>A refinement of the <a href=\\"https://github.com/pull-stream/pull-paramap\\">paramap</a> module for dynamic, unbounded, and fault-tolerant parallel processing.</p>\\n<p>Continuously lends values to concurrent sub-streams. Transparent re-lending in case of failure of sub-streams.</p>\\n<p>Each sub-stream continuously borrows (different) values from a lender and returns results back after processing.</p>\\n<ul>\\n<li>Supports multiple concurrent sub-streams.</li>\\n<li>Produces results in the order in which the lender reads the values.</li>\\n<li>If a sub-stream closes before producing all its results, the original source\\nvalues for missing results are lent transparently to other sub-streams.</li>\\n<li>Each sub-stream obtains values as fast as they read them.</li>\\n</ul>\\n<p>Useful for delegating processing to a dynamic number of concurrent,\\ncooperative, connected, but unreliable clients.</p>\\n<h2>Quick Example</h2>\\n<pre><code>var pull = require(&apos;pull-stream&apos;)\\nvar lendStream = require(&apos;pull-lend-stream&apos;)\\n\\nvar lender = lendStream()\\n\\nfunction minus (x, cb) {\\n  setTimeout(function () {\\n    cb(null, -x)\\n  }, 201)\\n}\\n\\n// Twice faster\\nfunction addTen (x, cb) {\\n  setTimeout(function () {\\n    cb(null, 10 + x)\\n  }, 100)\\n}\\n\\nfunction borrower (mapper) {\\n  return function (err, stream) {\\n    if (err) return console.log(err.message)\\n\\n    pull(\\n      stream,\\n      pull.asyncMap(mapper),\\n      stream\\n    )\\n  }\\n}\\n\\n// Prints -0,11,12,-3,14,15,-6,17,18,-9,20\\npull(\\n  pull.count(10),\\n  lender,\\n  pull.collect(function (err, results) {\\n    if (err) throw err\\n    console.log(results)\\n  })\\n)\\n\\nlender.lendStream(borrower(minus))\\nlender.lendStream(borrower(addTen))\\n</code></pre>\\n<h2>Signature</h2>\\n<p>The following signature follows the <a href=\\"https://github.com/elavoie/js-module-signature-syntax\\">js module signature\\nsyntax</a> and conventions.\\nAll callbacks (&apos;cb&apos;) have the &apos;(err, value)&apos; signature.</p>\\n<pre><code>lendStream: () =&gt;\\nlender: {\\n    sink: (read: (abort, cb)),\\n    lendStream: (borrower: (\\n        err,\\n        subStream: {\\n            source: (abort, cb),\\n            sink: (read: (abort, resultCb)),\\n            close: (?err)\\n        })),\\n    source: (abort, resultCb)\\n}\\n</code></pre>\\n<h2>Properties</h2>\\n<p><em>Italic</em> names refer to the function signature above.</p>\\n<ol>\\n<li>If no <em>subStream</em> is read then read is never called.</li>\\n<li>Multiple <em>subStreams</em> can be created by calling <em>lendStream</em> multiple times.</li>\\n<li>Once <em>lendStream</em> has been called,<br>\\n3.1 the borrower will eventually be called either with a <em>subStream</em> or\\nan <em>err</em>;<br>\\n3.2 if there is no <em>err</em> and values are read by calling <em>subStream.source</em>,\\n<em>subStream.source</em> will eventually abort.</li>\\n<li><em>lender.source</em> closes after <em>lender.sink</em> has received an abort and all\\n<em>subStreams</em> have closed.</li>\\n<li><em>lender.source</em> produces results in the order in which the values were\\nread by the <em>lender.sink</em>.</li>\\n<li>If a <em>subStream</em> ends before successfully sinking results computed for all\\nvalues read, then the values for missing results are transparently\\nmigrated to other <em>subStreams</em>.</li>\\n<li>Unfair: if a <em>subStream</em> reads values faster than other <em>subStreams</em>, it\\nwill obtain more values.</li>\\n<li>When a <em>borrower</em> is called, <em>err</em> is truthy if and only if:<br>\\n8.1 <em>lender.sink</em> has not been called yet (lender is not connected to an\\nupstream source);<br>\\n8.2 <em>lender.source</em> was aborted;<br>\\n8.3 all available values have been borrowed and all results have been sourced.</li>\\n<li><em>subStream.close(?err)</em> ends the corresponding <em>subStream</em> with the error <em>err</em> if present, or with <em>true</em> otherwise.</li>\\n</ol>\\n<h2>Expectations on the sub-streams</h2>\\n<ol>\\n<li>Sub-streams should correctly close when <em>subStream.source</em> aborts and the\\nevent should propagate to their sink. Otherwise it will indefinitely prevent\\nthe lender from closing (Prop. 4).</li>\\n</ol>\\n<h2>Debugging</h2>\\n<p>You can obtain a trace of the internal events of the module by activating the logging using the <code>DEBUG=pull-lend-stream</code> environment variable (see <a href=\\"http://npmjs.org/debug\\">debug</a>).</p>\\n<p>You can also obtain the internal state of the module at a specific point in time by calling the <code>_state()</code> method. It returns an object with the following properties:</p>\\n<pre><code>    return {\\n      connected: Boolean, // The lender is connecter to an upstream source\\n      ended: Boolean, // Upstream is closed\\n      closed: Boolean, // lender is closed\\n      openedNb: Number, // Number of sub-streams opened\\n      lendState: Object // State of the internal pull-lend module\\n    }\\n</code></pre>\\n<p>The output of the <code>_state()</code> method should not be relied on for regular operations because it depends on the implementation of the module and may change in the future.</p>\\n","contributors":[28],"version":"1.1.9","npmName":"pull-lend-stream","category":"networks"},{"user":"reqshark","name":"pull-recvfrom","path":"reqshark/pull-recvfrom","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/reqshark/pull-recvfrom\\">pull-recvfrom</a><div class=\\"contrib\\"></div></h1>\\n<p>a <a href=\\"https://github.com/pull-stream/pull-stream\\"><code>pull-stream</code></a> for <a href=\\"https://github.com/reqshark/recvfrom\\"><code>recvfrom</code></a></p>\\n<p>this module provides a source stream interface to recvfrom</p>\\n<pre><code class=\\"hljs language-bash\\">npm i pull-recvfrom</code></pre>\\n<h3>pullfrom(<em>string</em>, <em>number</em>, <em>recvfrom</em>)</h3>\\n<p>parameter signature, <code>pullfrom(str, n, fn)</code>:</p>\\n<ul>\\n<li>\\n<p><code>string</code>, a unix datagram socket path</p>\\n</li>\\n<li>\\n<p><code>number</code>, buffer recv size</p>\\n</li>\\n<li>\\n<p><code>recvfrom</code>, a reference to <a href=\\"https://github.com/reqshark/recvfrom\\"><code>recvfrom</code></a></p>\\n</li>\\n</ul>\\n<p>for example:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">const</span> pullfrom = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-recvfrom&apos;</span>)\\n<span class=\\"hljs-keyword\\">const</span> recvfrom = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;recvfrom&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">const</span> sockpath = <span class=\\"hljs-string\\">`/tmp/mysocketpath`</span>\\n<span class=\\"hljs-keyword\\">const</span> sz = <span class=\\"hljs-number\\">99999</span>\\n\\n<span class=\\"hljs-keyword\\">const</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\npull(\\n  pullfrom(sockpath, sz, recvfrom), <span class=\\"hljs-comment\\">// pass address and recvfrom to pullfrom()</span>\\n  pull.drain(<span class=\\"hljs-built_in\\">console</span>.log)\\n)</code></pre>\\n<p>the buffer limit configuration <code>sz</code> is an optional parameter</p>\\n<p>you can pass a reference to <code>recvfrom</code>, after the unix socket path:</p>\\n<pre><code class=\\"hljs language-js\\">pullfrom(<span class=\\"hljs-string\\">&apos;/tmp/mysocketpath&apos;</span>, <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;recvfrom&apos;</span>))</code></pre>\\n<h3>MIT</h3>\\n","contributors":[51],"version":"0.0.2","npmName":"pull-recvfrom","category":"networks"},{"user":"pull-stream","name":"stream-to-pull-stream","path":"pull-stream/stream-to-pull-stream","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/stream-to-pull-stream\\">stream-to-pull-stream</a><div class=\\"contrib\\"></div></h1>\\n<p>Convert a classic-stream, or a new-stream into a\\n<a href=\\"https://github.com/dominictarr/pull-stream\\">pull-stream</a></p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> toPull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;stream-to-pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\npull(\\n  toPull.source(fs.createReadStream(__filename)),\\n  pull.map(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">e</span>) </span>{ <span class=\\"hljs-keyword\\">return</span> e.toString().toUpperCase() }),\\n  toPull.sink(process.stdout, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span>(err) <span class=\\"hljs-keyword\\">throw</span> err\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;done&apos;</span>)\\n  })\\n)</code></pre>\\n<p>if the node steam is a duplex (i.e. net, ws) then use <code>toPull.duplex(stream, cb?)</code>\\n<code>duplex</code> takes an optional callback in the same way that <code>sink</code> does.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,55],"version":"1.7.2","npmName":"stream-to-pull-stream","category":"interop"},{"user":"pull-stream","name":"pull-stream-to-stream","path":"pull-stream/pull-stream-to-stream","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream-to-stream\\">pull-stream-to-stream</a><div class=\\"contrib\\"></div></h1>\\n<p>turn a pull-stream into a regular node stream.</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> toStream = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream-to-stream&apos;</span>)\\n\\n<span class=\\"hljs-comment\\">//if the pull-stream is duplex (an object with two streams: {source, sink})</span>\\n\\nstream = toStream(pullDuplex)\\n\\n<span class=\\"hljs-comment\\">//if the stream is a sink (&quot;writable&quot;)</span>\\nstream = toStream.sink(pullSink)\\n\\n<span class=\\"hljs-comment\\">//if the stream is a source (&quot;readable&quot;)</span>\\n\\nstream = toStream.source(pullSource)</code></pre>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,12,53],"version":"1.3.4","npmName":"pull-stream-to-stream","category":"interop"},{"user":"queckezz","name":"pull-promise","path":"queckezz/pull-promise","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/queckezz/pull-promise\\">pull-promise</a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>Pull the value from a promise using <a href=\\"https://pull-stream.github.io/\\">pull-streams</a></p>\\n</blockquote>\\n<p><a href=\\"https://travis-ci.org/queckezz/pull-promise\\"></a>\\n<a href=\\"https://npmjs.org/package/pull-promise\\"></a>\\n<a href=\\"https://david-dm.org/queckezz/pull-promise\\"></a>\\n<a href=\\"http://github.com/queckezz/pull-promise/blob/master/./license\\"></a>\\n<a href=\\"https://github.com/feross/standard\\"></a></p>\\n<h2>Installation</h2>\\n<pre><code class=\\"hljs language-bash\\">$ npm install pull-promise</code></pre>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">const</span> toPull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-promise&apos;</span>)\\n<span class=\\"hljs-keyword\\">const</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">const</span> axios = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;axios&apos;</span>)\\n\\npull(\\n  toPull.source(axios.get(<span class=\\"hljs-string\\">&apos;http://example.org/posts/1&apos;</span>)),\\n  pull.map(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">response</span>) =&gt;</span> response.body),\\n  pull.log()\\n)\\n<span class=\\"hljs-comment\\">// -&gt; &quot;quia et suscipit\\\\nsuscipit recusandae...&quot;</span></code></pre>\\n<h2>API</h2>\\n<h3><code>.source(Promise)</code></h3>\\n<blockquote>\\n<p>Also available as <code>require(&apos;pull-promise/source&apos;)</code></p>\\n</blockquote>\\n<p>Creates a <a href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sources/index.md\\">source stream</a> with the resolved promise value.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">const</span> toPull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-promise&apos;</span>)\\n\\npull(\\n  toPull.source(<span class=\\"hljs-built_in\\">Promise</span>.resolve(<span class=\\"hljs-number\\">5</span>)),\\n  pull.log()\\n)\\n<span class=\\"hljs-comment\\">// -&gt; 5</span></code></pre>\\n<h3><code>.through((v) =&gt; Promise)</code></h3>\\n<blockquote>\\n<p>Also available as <code>require(&apos;pull-promise/through&apos;)</code></p>\\n</blockquote>\\n<p>Creates a <a href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/index.md\\">through stream</a> with the resolved promise value as output. <code>fn</code> is a function accepting the incoming value and returning a <code>Promise</code>.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">const</span> toPull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-promise&apos;</span>)\\n\\npull(\\n  pull.values([<span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-number\\">8</span>]),\\n  toPull.through(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">v</span>) =&gt;</span> <span class=\\"hljs-built_in\\">Promise</span>.resolve(v * v)),\\n  pull.log()\\n)\\n<span class=\\"hljs-comment\\">// -&gt; 4, 16, 64</span></code></pre>\\n<h2>Run tests</h2>\\n<pre><code class=\\"hljs language-bash\\">$ npm <span class=\\"hljs-built_in\\">test</span> </code></pre>\\n<h2>License</h2>\\n<p><a href=\\"http://github.com/queckezz/pull-promise/blob/master/./license\\">MIT</a></p>\\n","contributors":[56,3],"version":"2.0.0","npmName":"pull-promise","category":"interop"},{"user":"rjmk","name":"static-land-pull-stream","path":"rjmk/static-land-pull-stream","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/rjmk/static-land-pull-stream\\">Static Pull Stream</a><div class=\\"contrib\\"></div></h1>\\n<p>Definitions of common algebras for <a href=\\"https://github.com/pull-stream\\">pull-streams</a>\\nusing the <a href=\\"https://github.com/rpominov/static-land\\">static-land</a> spec.</p>\\n<h2>Installation</h2>\\n<p><code>npm install static-land-pull-stream</code></p>\\n<h2>Usage</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> sourceType = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;static-pull&apos;</span>).source</code></pre>\\n<h2>Source Streams</h2>\\n<p>Algebras implemented:</p>\\n<ul>\\n<li>Semigroup</li>\\n<li>Monoid</li>\\n<li>Functor</li>\\n<li>Apply</li>\\n<li>Applicative</li>\\n<li>Chain</li>\\n</ul>\\n<h2>Vibe</h2>\\n<p>I have tried to avoid using abstractions internally\\n(at the cost of (hidden) mutation and stuff),\\nbecause pull streams are low level and this is providing the functional wrappers.</p>\\n<h2>Of some interest</h2>\\n<p>With regards to <a href=\\"https://github.com/fantasyland/fantasy-land\\">fantasy-land</a>\\nwe would have had to\\na) mutate the global function prototype, or\\nb) made an object that &apos;newtype&apos;d the function like <code>{ runStream: ... }</code>.</p>\\n<h2>TODO</h2>\\n<ul>\\n<li>Sink streams</li>\\n<li>Through streams</li>\\n</ul>\\n","contributors":[57,58],"version":"0.0.0","npmName":"static-land-pull-stream","category":"interop"},{"user":"jamen","name":"pull-spawn-process","path":"jamen/pull-spawn-process","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/jamen/pull-spawn-process\\">pull-spawn-process</a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>Use pull-streams with <code>child_process.spawn</code> stdio</p>\\n</blockquote>\\n<p>A convenient wrapper around <a href=\\"http://github.com/jamen/pull-spawn-process/blob/master/\\"><code>child_process.spawn</code></a> for use with <a href=\\"https://github.com/pull-stream/pull-stream\\"><code>pull-stream</code></a></p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> cat = spawn(<span class=\\"hljs-string\\">&apos;cat&apos;</span>, [<span class=\\"hljs-string\\">&apos;somefile.txt&apos;</span>])\\n\\n<span class=\\"hljs-comment\\">// Read the process&apos;s stdout</span>\\npull(cat, drain(<span class=\\"hljs-built_in\\">console</span>.log))\\n\\n<span class=\\"hljs-comment\\">// Write process stdin</span>\\npull(values([<span class=\\"hljs-string\\">&apos;foo&apos;</span>, <span class=\\"hljs-string\\">&apos;bar&apos;</span>]), cat)</code></pre>\\n<p>Returns a duplex stream with an additional <code>error</code> prop to handle <code>proc.stderr</code>.  The other child_process methods are available too.</p>\\n<h2>Install</h2>\\n<pre><code class=\\"hljs language-sh\\">npm install --save pull-spawn-process\\n\\n<span class=\\"hljs-comment\\"># with yarn</span>\\nyarn add pull-spawn-process</code></pre>\\n<h2>Usage</h2>\\n<h3><code>spawn(command, args?, options?)</code></h3>\\n<p>The signature is the same as <a href=\\"https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options\\"><code>child_process.spawn</code></a>, except returns a duplex pull-stream.</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> cat = spawn(<span class=\\"hljs-string\\">&apos;cat&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> echo = spawn(<span class=\\"hljs-string\\">&apos;echo&apos;</span>, [<span class=\\"hljs-string\\">&apos;foo&apos;</span>, <span class=\\"hljs-string\\">&apos;bar&apos;</span>])\\n<span class=\\"hljs-keyword\\">var</span> eslint = spawn(<span class=\\"hljs-string\\">&apos;eslint&apos;</span>, files, { <span class=\\"hljs-attr\\">stdio</span>: <span class=\\"hljs-string\\">&apos;inherit&apos;</span> })</code></pre>\\n<p>The rest of the <code>ChildProcess</code> methods are exposed on the object</p>\\n<hr>\\n<p>Maintained by <a href=\\"https://git.io/jamen\\">Jamen Marz</a> (See on <a href=\\"https://twitter.com/jamenmarz\\">Twitter</a> and <a href=\\"https://github.com/jamen\\">GitHub</a> for questions &amp; updates)</p>\\n","contributors":[10],"version":"0.3.0","npmName":"pull-spawn-process","category":"interop"},{"user":"nrkn","name":"pull-iterable","path":"nrkn/pull-iterable","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/nrkn/pull-iterable\\">pull-iterable</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"https://github.com/pull-stream/pull-stream\\">pull-stream</a> source for <a href=\\"https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Iterators_and_Generators\\">ES6 iterables</a></p>\\n<p><code>npm install pull-iterable</code></p>\\n<pre><code class=\\"hljs language-javascript\\"><span class=\\"hljs-keyword\\">const</span> pull = <span class=\\"hljs-built_in\\">require</span>( <span class=\\"hljs-string\\">&apos;pull-stream&apos;</span> )\\n<span class=\\"hljs-keyword\\">const</span> iterable = <span class=\\"hljs-built_in\\">require</span>( <span class=\\"hljs-string\\">&apos;pull-iterable&apos;</span> )\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>* <span class=\\"hljs-title\\">range</span>(<span class=\\"hljs-params\\"> start, end </span>)</span>{\\n  <span class=\\"hljs-keyword\\">for</span>( <span class=\\"hljs-keyword\\">var</span> i = start; i &lt; end; i++ )\\n    <span class=\\"hljs-keyword\\">yield</span> i\\n}\\n\\npull(\\n  iterable( range( <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">5</span> ) ),\\n  pull.collect( <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\"> err, result </span>) =&gt;</span> {\\n    <span class=\\"hljs-built_in\\">console</span>.log( result )\\n  })\\n)\\n\\npull(\\n  iterable( [ <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">4</span> ] ),\\n  pull.collect( <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\"> err, result </span>) =&gt;</span> {\\n    <span class=\\"hljs-built_in\\">console</span>.log( result )\\n  })\\n)\\n\\npull(\\n  iterable( <span class=\\"hljs-string\\">&apos;hello world&apos;</span> ),\\n  pull.collect( <span class=\\"hljs-function\\">(<span class=\\"hljs-params\\"> err, result </span>) =&gt;</span> {\\n    <span class=\\"hljs-built_in\\">console</span>.log( result )\\n  })\\n)</code></pre>\\n","contributors":[59],"version":"0.1.0","npmName":"pull-iterable","category":"interop"},{"user":"maackle","name":"pull2chan","path":"maackle/pull2chan","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/maackle/pull2chan\\">pull2chan</a><div class=\\"contrib\\"></div></h1>\\n<p>Seamlessly convert between <a href=\\"https://github.com/pull-stream/pull-stream\\">pull-stream</a> sources and ClojureScript core.async channels, preserving backpressure</p>\\n<h2>Installation</h2>\\n<p>Add <code>[maackle/pull2chan &quot;0.1.0&quot;]</code> to your project.clj <code>:dependencies</code></p>\\n<h2>Examples</h2>\\n<p>Imports at top of file:</p>\\n<pre><code class=\\"hljs language-cljs\\">(ns example\\n  (:require [cljs.core.async :refer (chan &lt;! &gt;! close!)]\\n            [pull2chan.core :refer (pull-&gt;chan chan-&gt;pull)])\\n  (:require-macros [cljs.core.async.macros :refer [go]]))\\n\\n(def pull (js/require &quot;pull-stream&quot;))</code></pre>\\n<h3>pull-stream -&gt; channel</h3>\\n<pre><code class=\\"hljs language-cljs\\">(let [source (. pull (values #js [1 2 3]))\\n      ch (pull-&gt;chan source)]\\n  (go (println (&lt;! ch)) ; output: 1\\n      (println (&lt;! ch)) ; output: 2\\n      (println (&lt;! ch)) ; output: 3\\n      (println (&lt;! ch)) ; output: nil (channel is closed after source is depleted)\\n      (println (&lt;! ch)) ; output: nil (still closed...)\\n      ))</code></pre>\\n<h3>channel -&gt; pull-stream</h3>\\n<pre><code class=\\"hljs language-cljs\\">(let [ch (chan)\\n      source (chan-&gt;pull ch)\\n      sink (. pull (drain\\n                    #(println %)\\n                    #(println &quot;done&quot;)))]\\n  (pull source sink)\\n  (go (&gt;! ch 1)\\n      (&gt;! ch 2)\\n      (&gt;! ch 3)\\n      (close! ch))\\n  )\\n\\n; output:\\n; 1\\n; 2\\n; 3\\n; done</code></pre>\\n<h3>channel -&gt; pull-stream -&gt; channel -&gt; pull-stream -&gt; channel</h3>\\n<p>Yes, you can go back and forth as much as you want!</p>\\n<p>See the <a href=\\"http://github.com/maackle/pull2chan/blob/master/./test/pull2chan/tests.cljs\\">tests</a> for a few more examples</p>\\n<h2>Development</h2>\\n<ol>\\n<li>Run <code>[rlwrap] lein figwheel devserver</code> in one session</li>\\n<li>Run <code>node target/devserver.js</code> in another</li>\\n</ol>\\n<p>To run tests with hot reloading: <code>lein doo node test</code></p>\\n","contributors":[60],"version":false,"npmName":false,"category":"interop"},{"user":"dominictarr","name":"pull-box-stream","path":"dominictarr/pull-box-stream","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/dominictarr/pull-box-stream\\">pull-box-stream</a><div class=\\"contrib\\"></div></h1>\\n<p>stream <em>one way</em> encryption based on <a href=\\"https://github.com/paixaop/node-sodium\\">libsodium</a>&apos;s secretbox primitive.</p>\\n<p></p>\\n<p>This protocol should not be used to encrypt a tcp connection\\nunless it was combined with a handshake protocol\\nthat was used to derive a forward secure shared key.</p>\\n<p>It may be used to encrypt a file.</p>\\n<h2>Claims</h2>\\n<h3>All bytes are authenticated &amp; encrypted.</h3>\\n<ul>\\n<li>The reciever never reads an unauthenticated number of bytes.</li>\\n</ul>\\n<p>This protects against attackers causing deadlocks on certain application protocols protected with box-stream.\\n(description of this attack on\\n<a href=\\"https://github.com/calvinmetcalf/hmac-stream/issues/5\\">old version of hmac-stream</a>)</p>\\n<ul>\\n<li>The end of the stream is authenticated.</li>\\n</ul>\\n<p>This detects if an attacker cut off the end of the stream.\\nfor example:</p>\\n<p>Alice: hey bob, just calling to say that I think TLS is really great,\\nreally elegant protocol, and that I love everything about it.</p>\\n<p>Mallory (man in the middle): (SNIP! ...terminates connection...)</p>\\n<p>Alice: NOT!!!!! (Bob never receives this!)</p>\\n<p>Bob... WTF, I thought Alice had taste!</p>\\n<p>Bob never gets the punchline, so thinks that Alice&apos;s childish humor was\\nactually her sincere belief.</p>\\n<p>With box-stream this would result in an error and Bob would know\\nthat there was some additional content he missed which hopefully\\nexplained Alice&apos;s absurd statement.</p>\\n<h2>Disclaims</h2>\\n<ul>\\n<li>This protocol does not obscure packet boundries or packet timing.</li>\\n<li>This protocol is not a substitute for TLS, it must be used with another handshake protocol to derive a shared key.</li>\\n</ul>\\n<h2>Protocol</h2>\\n<p>This protocol has no malleable bytes.\\nEven the framing is authenticated, and since the framing is\\nauthenticated separately to the packet content, an attacker cannot\\nflip any bits without being immediately detected.</p>\\n<p>The design follows on from that used in\\n<a href=\\"https://github.com/dominictarr/pull-mac\\">pull-mac</a>,\\nwhere both the framing and the framed packet are authenticated.</p>\\n<p>In <code>pull-mac</code>, the packet is hashed, and then the header hmac&apos;d.\\nSince the header contains the packet hash and the packet length,\\nthen changing a bit in the packet will produce a different hash\\nand thus an invalid packet. Flipping a bit in the header will\\ninvalidate the hmac.</p>\\n<p>In <code>pull-boxes</code> a similar approach is used, but via nacl&apos;s authenticated\\nencryption primitive: <code>secretbox</code>. salsa20 encryption + poly1305 mac.\\nThe packet is boxed, then the header is constructed from the packet\\nlength + packet mac, then the header is boxed.</p>\\n<p>This protocol uses a 56 byte key (448 bits). The first 32 bytes\\nare the salsa20 key, and the last 24 bytes are the nonce. Previous\\nverisons of this protocol generated a nonce and transmitted it,\\nbut it could be simplified by considering it part of the key.</p>\\n<p>Since every header and packet body are encrypted,\\nthen every byte in the stream appears random.</p>\\n<p>The only information an evesdropper can extract is\\npacket timing and to guess at packet boundries\\n(although, sometimes packets will be appended, obscuring the true boundries)</p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> boxes = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-box-stream&apos;</span>)\\n<span class=\\"hljs-comment\\">//generate a random secret, 56 bytes long.</span>\\n\\n<span class=\\"hljs-keyword\\">var</span> key = createRandomSecret(<span class=\\"hljs-number\\">56</span>)\\n\\npull(\\n  plaintext_input,\\n\\n  <span class=\\"hljs-comment\\">//encrypt every byte</span>\\n  boxes.createBoxStream(key),\\n\\n  <span class=\\"hljs-comment\\">//the encrypted stream</span>\\n  pull.through(<span class=\\"hljs-built_in\\">console</span>.log),\\n\\n  <span class=\\"hljs-comment\\">//decrypt every byte</span>\\n  boxes.createUnboxStream(key),\\n\\n  plaintext_output\\n)</code></pre>\\n<h2>Protocol</h2>\\n<pre><code>(\\n\\n  [header MAC (16)] // sends header MAC\\n     |\\n     |   .--header-box-----------------.\\n     \\\\-&gt; |length (2), [packet MAC (16)]| // sends encrypted header\\n         `--^------------|-------------`\\n            |            |\\n            |            |  .-packet-box-------.\\n            |            `-&gt;|data.. (length...)| // sends encrypted packet\\n            |               `-----------|------`\\n            \\\\---------------------------/\\n\\n) * // repeat 0-N times\\n\\n[final header MAC(16)]\\n   |\\n   |  .-final-header-box-------.\\n   \\\\-&gt;|length=0 (2), zeros (16)|\\n      `------------------------`\\n</code></pre>\\n<p>Since the packet mac is inside the header box, the packet\\nmust be boxed first.</p>\\n<p>The last 24 bytes of the 56 byte key is used as the nonce.\\nWhen boxing, you must use a different nonce everytime a particular key is used.</p>\\n<p>The recommended way to do this is to randomly generate an initial\\nnonce for that key, and then increment that nonce on each boxing.\\n(this way security is not dependant on the random number generator)</p>\\n<p>The protocol sends zero or more {header, packet} pairs, then a final\\nheader, that is same length, but is just boxed zeros.\\nEach header is 34 bytes long (header mac + packet_length + packet mac).\\nThen the packet_length is length long (with a maximum length of 4096\\nbytes long, if the in coming packet is longer than that it is split\\ninto 4096 byte long sections.)</p>\\n<p>Packet number P uses N+2P as the nonce on the header box,\\nand N+2P+1 as the nonce on the packet box.</p>\\n<p>A final packet is sent so that an incorrectly terminated session\\ncan be detected.</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,61],"version":"1.0.13","npmName":"pull-box-stream","category":"crypto"},{"user":"auditdrivencrypto","name":"secret-handshake","path":"auditdrivencrypto/secret-handshake","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/auditdrivencrypto/secret-handshake\\">secret-handshake</a><div class=\\"contrib\\"></div></h1>\\n<p>secure-channel based on a a mutually authenticating key agreement handshake, with forward secure identity metadata.</p>\\n<p>For a full explaination of the design, read the\\n<a href=\\"http://dominictarr.github.io/secret-handshake-paper/shs.pdf\\">Design Paper</a></p>\\n<h2>Implementations</h2>\\n<ul>\\n<li>javascript/node.js this repo.</li>\\n<li>go <a href=\\"https://github.com/cryptix/secretstream/\\">cryptix/secretstream</a></li>\\n<li>rust <a href=\\"https://github.com/AljoschaMeyer/secret-handshake-rs\\">AljoschaMeyer/secret-handshake-rs</a></li>\\n<li>c <a href=\\"https://github.com/AljoschaMeyer/shs1-c\\">AljoschaMeyer/shs1-c</a> (actually just implements the crypto, not the protocol used as a component in the rust implementation)</li>\\n<li>python/twisted <a href=\\"https://github.com/david415/txsecrethandshake\\">david415/txsecrethandshake</a> (WIP)</li>\\n<li>C++ <a href=\\"https://github.com/Kodest/cppshs\\">Kodest/cppshs</a> (WIP)</li>\\n<li>also <a href=\\"https://github.com/keks/tamarin-shs\\">keks/tamarin-shs</a> is a formal proof of the cryptographic properties!</li>\\n</ul>\\n<h2>Claims</h2>\\n<p>This protocol derives shared keys and mutually\\nauthenticates both ends of the connection.\\nThe shared secrets are forward secure, and\\nso is the identity metadata.</p>\\n<p>by &quot;forward secure identity metadata&quot; I mean:</p>\\n<ul>\\n<li>a later key compromise cannot confirm the public keys in the handshake.</li>\\n</ul>\\n<p>And also:</p>\\n<ul>\\n<li>an eavesdropper cannot learn public keys</li>\\n<li>replay attacker cannot learn public keys.</li>\\n<li>man in the middle cannot learn public keys.</li>\\n<li>a &quot;wrong number&quot; cannot learn public keys.</li>\\n<li>an unauthenticated client cannot learn server key.</li>\\n</ul>\\n<blockquote>\\n<p>note: a wrong number is just an accidental man in the middle.</p>\\n</blockquote>\\n<p>By &quot;confirm&quot; I mean check a guess at the public key.\\nBy &quot;learn&quot; I mean that you can <em>either</em> extract the public key,\\nor confirm the public key.</p>\\n<p>Also note that if the server decides not to authenticate a client,\\nit will learn their public key. To get to this stage, the client\\nmust know the server&apos;s key, so now the client and server both\\nknow each others key. This is fair.</p>\\n<h2>Disclaims</h2>\\n<p>This protocol cannot hide your ip address.\\nThis protocol does not attempt to obscure packet boundries.\\nIf a man in the middle or wrong number later compromises\\nthe server&apos;s key, they will be able to extract the client\\nkey from the client&apos;s hello packet.</p>\\n<h2>Example</h2>\\n<p>The simplest way to use secret-handshake is to use\\n<code>require(&apos;secret-handshake/net&apos;)</code>, a wrapper around net.\\nThis makes it easy to create encrypted tcp connections.</p>\\n<p><a href=\\"https://github.com/dominictarr/pull-streams\\">pull-streams</a> are used.\\nlearn about how pull-streams from <a href=\\"https://github.com/dominictarr/pull-stream-examples\\">these examples</a></p>\\n<p><a href=\\"https://github.com/dominictarr/chloride\\">chloride</a> is required to generate\\nkey pairs. (which is my fork of) <a href=\\"https://github.com/paixaop/node-sodium\\">sodium</a> (which is also compatible)</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> SHS = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;secret-handshake&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> cl = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;chloride&apos;</span>).api\\n<span class=\\"hljs-keyword\\">var</span> appKey = ... <span class=\\"hljs-comment\\">//32 random bytes</span>\\n<span class=\\"hljs-keyword\\">var</span> alice = cl.crypto_sign_keypair() <span class=\\"hljs-comment\\">//client</span>\\n<span class=\\"hljs-keyword\\">var</span> bob = cl.crypto_sign_keypair()   <span class=\\"hljs-comment\\">//server</span>\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">authorize</span>(<span class=\\"hljs-params\\">id, cb</span>) </span>{\\n  cb(<span class=\\"hljs-literal\\">null</span>, check(id)) <span class=\\"hljs-comment\\">//check wether id is authorized.</span>\\n}\\n\\n<span class=\\"hljs-comment\\">//initialize, with default timeouts.</span>\\n<span class=\\"hljs-keyword\\">var</span> ServerStream = SHS.createServer(alice, authorize, appKey)\\n<span class=\\"hljs-keyword\\">var</span> ClientStream = SHS.createClient(bob, appkey)\\n\\n<span class=\\"hljs-keyword\\">var</span> alice_stream = ServerStream(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, stream</span>) </span>{\\n  ...\\n})\\n\\n<span class=\\"hljs-keyword\\">var</span> bob_stream = ClientStream(alice.publicKey, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, stream</span>) </span>{\\n  ...\\n})\\n\\n<span class=\\"hljs-comment\\">//connect streams together.</span>\\npull(alice_stream, bob_stream, alice_stream)</code></pre>\\n<p>I recommend using secret-handshake via <a href=\\"https://github.com/dominictarr/multiserver\\">multiserver</a></p>\\n<h2>api</h2>\\n<h3>createClient(keypair, appkey, timeout) =&gt; createClientStream(key, seed?, cb(err, plainstream)) =&gt; cipherstream</h3>\\n<p><code>createClient</code> takes <code>keypair</code> <code>appkey</code> and <code>timeout</code> and\\nreturns a <code>createClientStream</code></p>\\n<p><code>createClientStream</code> takes a the public <code>key</code> for the remote peer,\\nan optional <code>seed</code> (which is used to generate a one-time private key),\\nand a callback, <code>cb</code>. <code>cipherstream</code>, an encrypted duplex pull-stream is returned.</p>\\n<p>Once the stream is connected to a server stream,\\nsecret-handshake will attempt to authorize, and will call\\n<code>cb</code> with an <code>err</code> if it fails, or <code>plainstream</code> if it succeeds.\\nIf <code>keypair</code> is null, <code>seed</code> <em>must</em> be provided.</p>\\n<h3>createServer(keypair, authorize(id, cb), appkey, timeout) =&gt; createServerStream(cb(err, plain_stream)) =&gt; cipherstream</h3>\\n<p><code>createServer</code> is similar, except it takes <code>authorize</code>,\\nwhich is an async function that will be called when a client connects.\\nA stream constructor function is returned, but the server does\\ntake the client id as an argument. Instead, in the process\\nof the handshake, the server learns the <code>id</code>, and passes it to\\n<code>authorize</code>. If <code>authorize</code> calls back truthy,\\nthen it will callback <code>cb(null, plainstream)</code> else it errors,\\n<code>cb(err)</code>. The value that <code>authorize</code> calls back <code>cb(null, &lt;V&gt;)</code>\\nwill be assigned to <code>plainstream.auth = &lt;V&gt;</code>. Also,\\nthe <code>id</code> of the remote will be assigned to <code>plainstream.id</code>.\\nThis way the application layer can know who it&apos;s peer is.</p>\\n<p>build a client constructor. <code>keypair</code> may be null,\\nif the stream will be used</p>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[0,62,63,64,19],"version":"1.1.13","npmName":"secret-handshake","category":"crypto"},{"user":"pietgeursen","name":"pull-dom-mutants","path":"pietgeursen/pull-dom-mutants","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pietgeursen/pull-dom-mutants\\">pull-dom-mutants</a><div class=\\"contrib\\"></div></h1>\\n<p><a href=\\"http://pull-stream.github.io/\\">pull-stream</a> source of mutations to a dom element using <a href=\\"https://developer.mozilla.org/en/docs/Web/API/MutationObserver\\">Mutation Observer</a>. Emits <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord\\">Mutation Records</a></p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pullMutants = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-dom-mutants&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> test = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;tape&apos;</span>)\\n\\ntest(<span class=\\"hljs-string\\">&apos;emitter emits a value when child element appended&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n  <span class=\\"hljs-keyword\\">var</span> elem = <span class=\\"hljs-built_in\\">document</span>.createElement(<span class=\\"hljs-string\\">&apos;main&apos;</span>)\\n  <span class=\\"hljs-keyword\\">var</span> child = <span class=\\"hljs-built_in\\">document</span>.createElement(<span class=\\"hljs-string\\">&apos;h1&apos;</span>)\\n  pull(\\n    pullMutants(elem, {<span class=\\"hljs-attr\\">childList</span>: <span class=\\"hljs-literal\\">true</span>}),\\n    pull.take(<span class=\\"hljs-number\\">1</span>),\\n    pull.drain(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">mutation</span>) </span>{\\n      <span class=\\"hljs-keyword\\">var</span> addedChild = mutation.target.querySelector(<span class=\\"hljs-string\\">&apos;h1&apos;</span>)\\n      t.equal(addedChild, child)\\n      t.end()\\n      <span class=\\"hljs-built_in\\">window</span>.close()\\n    })\\n  )\\n\\n  t.false(elem.querySelector(<span class=\\"hljs-string\\">&apos;h1&apos;</span>))\\n  elem.appendChild(child)\\n})</code></pre>\\n<h2>API</h2>\\n<pre><code class=\\"hljs language-js\\">  pullMutants(elem [, opts])</code></pre>\\n<p>Where opts are the options to pass along to <a href=\\"https://developer.mozilla.org/en/docs/Web/API/MutationObserver\\">Mutation Observer</a>, defaults to <code>{childList: true}</code></p>\\n","contributors":[65,3],"version":"1.0.1","npmName":"pull-dom-mutants","category":"dom"},{"user":"pietgeursen","name":"pull-dom-driver","path":"pietgeursen/pull-dom-driver","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pietgeursen/pull-dom-driver\\">pull-dom-driver</a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>A pullstream &quot;webdriver&quot; for interacting with changes to the dom.</p>\\n</blockquote>\\n<p>When you&apos;re testing client side apps like <a href=\\"https://facebook.github.io/react/\\">react</a> or <a href=\\"https://github.com/ahdinosaur/inu\\">inu</a>, finding and interacting with elements that appear dynamically is painful. pull-dom-driver uses a <a href=\\"https://github.com/ahdinosaur/inu\\">pull-stream</a> source of dom mutations from <a href=\\"http://pull-stream.github.io/#pull-dom-mutants\\">pull-dom-mutants</a> to <code>find(&quot;.list&quot;)</code> and <code>click(&quot;#go-button&quot;)</code> on elements once they&apos;re actually in the dom.</p>\\n<h2>Usage</h2>\\n<p>Let&apos;s find an element that isn&apos;t in the dom yet but will be:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-comment\\">//in the browser</span>\\n<span class=\\"hljs-keyword\\">var</span> createDomStream = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-dom-driver&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> domStream = createDomStream(<span class=\\"hljs-built_in\\">document</span>, <span class=\\"hljs-built_in\\">window</span>)\\npull(\\n  domStream.find(<span class=\\"hljs-string\\">&apos;#mutant&apos;</span>)\\n  pull.drain(<span class=\\"hljs-function\\">(<span class=\\"hljs-params\\">elem</span>) =&gt;</span> <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">`I found this: <span class=\\"hljs-subst\\">${elem}</span>`</span>))\\n)\\n\\n<span class=\\"hljs-keyword\\">var</span> myDiv = <span class=\\"hljs-built_in\\">document</span>.createElement(<span class=\\"hljs-string\\">&apos;div&apos;</span>)\\nmyDiv.id = <span class=\\"hljs-string\\">&quot;mutant&quot;</span> \\n<span class=\\"hljs-built_in\\">document</span>.body.appendChild(myDiv)</code></pre>\\n<p>This will output</p>\\n<pre><code>&quot;I found this: [object HTMLDivElement]&quot;\\n</code></pre>\\n<h2>API</h2>\\n<h3>var createDomStream = require(&apos;pull-dom-driver&apos;)</h3>\\n<h3>createDomStream(rootElement)</h3>\\n<p>Takes the <code>rootElement</code> on which you&apos;d like to obseve changes.</p>\\n<h3>var domStream = createDomStream(el)</h3>\\n<p>Returns an object with the following keys:</p>\\n<ul>\\n<li><code>subscribe</code> </li>\\n<li><code>find</code> </li>\\n<li><code>click</code> </li>\\n</ul>\\n<h3>domStream.find(cssSelectorString)</h3>\\n<p>Takes a <code>cssSelectorString</code> for the element(s) you&apos;d like to find.\\nReturns a pull-stream source of elements that have been found in the dom.\\nNote that if there is an element that matches the selector when the stream is created it will be emitted by the stream first.</p>\\n<h3>domStream.click(cssSelectorString)</h3>\\n<p>Takes a <code>cssSelectorString</code> for the element(s) you&apos;d like to click on.\\nReturns a pull-stream source of elements that have been clicked in the dom.\\nNote that if there is an element(s) that matches the selector when the stream is created it will be emitted by the stream first.</p>\\n<h3>domStream.subscribe()</h3>\\n<p>Returns a pull-stream source of dom mutations from <a href=\\"http://pull-stream.github.io/#pull-dom-mutants\\">pull-dom-mutants</a></p>\\n<h2>Install</h2>\\n<p>With <a href=\\"https://npmjs.org/\\">npm</a> installed, run</p>\\n<pre><code>$ npm install pull-dom-driver\\n</code></pre>\\n<h2>Acknowledgments</h2>\\n<p>pull-dom-driver was inspired by..</p>\\n<h2>See Also</h2>\\n<ul>\\n<li><a href=\\"https://github.com/noffle/common-readme\\"><code>noffle/common-readme</code></a></li>\\n</ul>\\n<h2>License</h2>\\n<p>MIT</p>\\n","contributors":[65],"version":"2.1.0","npmName":"pull-dom-driver","category":"dom"},{"user":"santiagogil","name":"pull-ric","path":"santiagogil/pull-ric","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/santiagogil/pull-ric\\">pull-ric</a><div class=\\"contrib\\"></div></h1>\\n<p>A pull through that works only on idle time</p>\\n<h2>Usage</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> ric = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-ric&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> pipe = pull(pull.infinite(),ric())\\n\\n<span class=\\"hljs-comment\\">// pipe executes reads and cb from any reader on browser idle time</span>\\n<span class=\\"hljs-comment\\">// this allows to do some work withowt interfering with render performance</span>\\n\\nsetInterval(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span>(<span class=\\"hljs-params\\"></span>)</span>{<span class=\\"hljs-keyword\\">return</span> pipe(<span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-built_in\\">console</span>.log)},<span class=\\"hljs-number\\">5</span>)</code></pre>\\n<p>It uses the average execution time of the readers cb to determine how many calls to do on each frame.</p>\\n<h2>Todo</h2>\\n<ul>\\n<li>tests</li>\\n<li>perf tests</li>\\n<li>demo with animation </li>\\n</ul>\\n","contributors":[66],"version":"0.1.0","npmName":"pull-ric","category":"dom"},{"user":"nichoth","name":"react-pull-stream","path":"nichoth/react-pull-stream","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/nichoth/react-pull-stream\\">react pull stream</a><div class=\\"contrib\\"></div></h1>\\n<p><strong>This is deprecated.</strong> See <a href=\\"http://npm.im/@invintus/react-pull-stream\\">http://npm.im/@invintus/react-pull-stream</a></p>\\n<p>Create a duplex stream from a react component.</p>\\n<h2>install</h2>\\n<pre><code>$ npm install react-pull-stream\\n</code></pre>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> React = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;react&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> h = React.createElement\\n<span class=\\"hljs-keyword\\">var</span> reactDom = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;react-dom&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> S = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> toStream = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;../&apos;</span>)\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">MyView</span> (<span class=\\"hljs-params\\">props</span>) </span>{\\n\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">click</span> (<span class=\\"hljs-params\\">n</span>) </span>{\\n        props.push(n)\\n    }\\n\\n    <span class=\\"hljs-keyword\\">return</span> h(<span class=\\"hljs-string\\">&apos;div&apos;</span>, {\\n        <span class=\\"hljs-attr\\">className</span>: <span class=\\"hljs-string\\">&apos;app&apos;</span>\\n    }, [\\n        h(<span class=\\"hljs-string\\">&apos;h1&apos;</span>, { <span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-string\\">&apos;h&apos;</span> }, props.count),\\n        h(<span class=\\"hljs-string\\">&apos;button&apos;</span>, { <span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-attr\\">onClick</span>: click.bind(<span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-number\\">1</span>) }, <span class=\\"hljs-string\\">&apos;1&apos;</span>),\\n        h(<span class=\\"hljs-string\\">&apos;button&apos;</span>, { <span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-attr\\">onClick</span>: click.bind(<span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-number\\">2</span>) }, <span class=\\"hljs-string\\">&apos;2&apos;</span>),\\n        h(<span class=\\"hljs-string\\">&apos;button&apos;</span>, { <span class=\\"hljs-attr\\">key</span>: <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-attr\\">onClick</span>: click.bind(<span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-number\\">3</span>) }, <span class=\\"hljs-string\\">&apos;3&apos;</span>),\\n    ])\\n}\\n\\nMyView.defaultProps = { <span class=\\"hljs-attr\\">count</span>: <span class=\\"hljs-number\\">0</span> }\\n\\n\\n<span class=\\"hljs-comment\\">// duplex stream</span>\\n<span class=\\"hljs-keyword\\">var</span> stream = toStream(MyView, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">onEnd</span> (<span class=\\"hljs-params\\">err</span>) </span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;its over&apos;</span>)\\n})\\n\\n<span class=\\"hljs-keyword\\">var</span> el = <span class=\\"hljs-built_in\\">document</span>.createElement(<span class=\\"hljs-string\\">&apos;div&apos;</span>)\\n<span class=\\"hljs-built_in\\">document</span>.body.appendChild(el)\\nreactDom.render(React.createElement(stream.view), el)\\n\\nS(\\n    stream,\\n    S.map( <span class=\\"hljs-function\\"><span class=\\"hljs-params\\">n</span> =&gt;</span> ({ <span class=\\"hljs-attr\\">count</span>: n }) ),\\n    stream\\n)\\n\\nS(\\n    <span class=\\"hljs-comment\\">// you can have mulitple subscripbers</span>\\n    stream.source.listen(),\\n    S.log()\\n)\\n\\nstream.abort()  <span class=\\"hljs-comment\\">// end things</span></code></pre>\\n","contributors":[6],"version":"2.0.3","npmName":"react-pull-stream","category":"dom"},{"user":"nichoth","name":"yo-pull-stream","path":"nichoth/yo-pull-stream","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/nichoth/yo-pull-stream\\">yo pull stream</a><div class=\\"contrib\\"></div></h1>\\n<p>Turn your view into a duplex stream. This uses <a href=\\"https://github.com/maxogden/yo-yo/\\">yo-yo</a> to render your view, and gives you a duplex stream interface for emitting events and subscribing to changes.</p>\\n<h2>install</h2>\\n<pre><code>$ npm install yo-pull-stream\\n</code></pre>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> S = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> scan = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-scan&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> ViewStream = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;../&apos;</span>)\\n<span class=\\"hljs-keyword\\">var</span> html = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;yo-yo&apos;</span>)\\n\\n<span class=\\"hljs-keyword\\">var</span> root = <span class=\\"hljs-built_in\\">document</span>.createElement(<span class=\\"hljs-string\\">&apos;div&apos;</span>)\\n<span class=\\"hljs-built_in\\">document</span>.body.appendChild(root)\\n\\n<span class=\\"hljs-comment\\">// viewStream is a duplex stream</span>\\n<span class=\\"hljs-keyword\\">var</span> viewStream = ViewStream(root, myView, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">onEnd</span> (<span class=\\"hljs-params\\">err</span>) </span>{\\n    <span class=\\"hljs-keyword\\">if</span> (err) <span class=\\"hljs-keyword\\">return</span> <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&apos;error&apos;</span>, err)\\n    <span class=\\"hljs-built_in\\">console</span>.log(<span class=\\"hljs-string\\">&quot;it&apos;s over&quot;</span>)\\n})\\n\\nS(\\n    viewStream,\\n    scan(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">state, ev</span>) </span>{\\n        <span class=\\"hljs-keyword\\">if</span> (ev === <span class=\\"hljs-string\\">&apos;plus&apos;</span>) <span class=\\"hljs-keyword\\">return</span> { <span class=\\"hljs-attr\\">count</span>: state.count + <span class=\\"hljs-number\\">1</span> }\\n        <span class=\\"hljs-keyword\\">return</span> state\\n    }),\\n    viewStream\\n)\\n\\n<span class=\\"hljs-comment\\">// push an initial event so our view renders</span>\\nviewStream.source.push({ <span class=\\"hljs-attr\\">count</span>: <span class=\\"hljs-number\\">0</span> })\\n\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">myView</span> (<span class=\\"hljs-params\\">state, push</span>) </span>{\\n    <span class=\\"hljs-comment\\">// call push to publish an event</span>\\n    <span class=\\"hljs-keyword\\">return</span> html<span class=\\"hljs-string\\">`&lt;div&gt;\\n        &lt;div&gt;<span class=\\"hljs-subst\\">${state.count}</span>&lt;/div&gt;\\n        &lt;button onclick=<span class=\\"hljs-subst\\">${push.bind(<span class=\\"hljs-literal\\">null</span>, <span class=\\"hljs-string\\">&apos;plus&apos;</span>)}</span>&gt;plus 1&lt;/button&gt;\\n    &lt;/div&gt;`</span>\\n}</code></pre>\\n<p>You can pass in a render function. This should work with any function like <code>morphdom</code>:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> ViewStream = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;yo-pull-stream/render-loop&apos;</span>)(myRenderFunction)\\n<span class=\\"hljs-keyword\\">var</span> viewStream = ViewStream(root, myView, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> <span class=\\"hljs-title\\">onEnd</span> (<span class=\\"hljs-params\\">err</span>) </span>{\\n})</code></pre>\\n","contributors":[6],"version":"0.0.11","npmName":"yo-pull-stream","category":"dom"},{"user":"jamen","name":"pull-css","path":"jamen/pull-css","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/jamen/pull-css\\">pull-css  </a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>Parse CSS into ASTs through a pull stream, or vice versa.</p>\\n</blockquote>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  source(),\\n  css(), <span class=\\"hljs-comment\\">// parse source as CSS</span>\\n  <span class=\\"hljs-comment\\">// ...</span>\\n)</code></pre>\\n<h2>Installation</h2>\\n<pre><code class=\\"hljs language-sh\\">$ npm install --save pull-css</code></pre>\\n<h2>API</h2>\\n<h3><code>css(options)</code></h3>\\n<p>Parse a pull-stream source with <a href=\\"https://npmjs.com/packages/css\\"><code>css</code></a></p>\\n<ul>\\n<li><code>options</code> (<code>Object</code>): Options passed to <a href=\\"https://github.com/reworkcss/css#cssparsecode-options\\"><code>css.parse</code></a></li>\\n</ul>\\n<p>Returns a <a href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/index.md\\"><code>through</code> stream</a> that pulls tokens.</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull.values([\\n    <span class=\\"hljs-string\\">&apos;div { color: red }&apos;</span>\\n  ]),\\n  css(),\\n  <span class=\\"hljs-comment\\">// ...</span>\\n)</code></pre>\\n<h3><code>css.stringify(options)</code></h3>\\n<p>Stringify a pull-stream source that is a <a href=\\"https://github.com/reworkcss/css#ast\\"><code>css</code> AST</a>  (probably originating from <code>css()</code>)</p>\\n<ul>\\n<li><code>options</code> (<code>Object</code>): Options passed to <a href=\\"https://github.com/reworkcss/css#cssstringifyobject-options\\"><code>css.stringify</code></a></li>\\n</ul>\\n<p>Returns a <code>through</code> pull stream that pulls strings.</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull.values([\\n    <span class=\\"hljs-string\\">&apos;div { color: red }&apos;</span>\\n  ]),\\n  css(),\\n  <span class=\\"hljs-comment\\">// do transformations on ast...</span>\\n  <span class=\\"hljs-comment\\">// then serialize:</span>\\n  css.serialize(),\\n  <span class=\\"hljs-comment\\">// ...</span>\\n)</code></pre>\\n<h2>License</h2>\\n<p>MIT &#xA9; <a href=\\"https://github.com/jamen\\">Jamen Marz</a></p>\\n","contributors":[10],"version":"0.1.0","npmName":"pull-css","category":"parser"},{"user":"elavoie","name":"pull-probe","path":"elavoie/pull-probe","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/elavoie/pull-probe\\">pull-probe</a><div class=\\"contrib\\"></div></h1>\\n<p>Logs synchronization events inside a pull-stream. Follows the convention of the\\ndebug module for activating the output.</p>\\n<p>Useful for debugging synchronization bugs in pull-stream modules in development\\nand trace the behaviour of tests.</p>\\n<p>Prints the &apos;source(abort, cb)&apos; when its source is read, and prints &apos;sink(err, data)&apos;\\nwhen it receives a value on its sink. &apos;cb(err, data)&apos; is called immediately after\\nthe sink received a value.</p>\\n<h2>Quick Example</h2>\\n<pre><code>var pull = require(&apos;pull-stream&apos;)\\nvar probe = require(&apos;pull-probe&apos;)\\n\\npull(\\n  pull.count(3),\\n  probe(&apos;quick-example&apos;),\\n  pull.drain()\\n)\\n\\n// usage: DEBUG=quick-example node quick-example.js\\n</code></pre>\\n","contributors":[28],"version":"1.0.1","npmName":"pull-probe","category":"debugging"},{"user":"pull-stream","name":"pull","path":"pull-stream/pull-stream","subpath":"pull","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/pull.md\\">pull-stream/pull</a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>pipe many pull streams into a pipeline</p>\\n</blockquote>\\n<h2>Background</h2>\\n<p>In pull-streams, you need a complete pipeline before data will flow.</p>\\n<p>That means: a source, zero or more throughs, and a sink.</p>\\n<p>But you can still create a <em>partial</em> pipeline, which is a great for tiny pull-stream modules.</p>\\n<h2>Usage</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream/pull&apos;</span>)</code></pre>\\n<p>Create a simple complete pipeline:</p>\\n<pre><code class=\\"hljs language-js\\">pull(source, sink) =&gt; <span class=\\"hljs-literal\\">undefined</span></code></pre>\\n<p>Create a source modified by a through:</p>\\n<pre><code class=\\"hljs language-js\\">pull(source, through) =&gt; source</code></pre>\\n<p>Create a sink, but modify it&apos;s input before it goes.</p>\\n<pre><code class=\\"hljs language-js\\">pull(through, sink) =&gt; sink</code></pre>\\n<p>Create a through, by chainging several throughs:</p>\\n<pre><code class=\\"hljs language-js\\">pull(through1, through2) =&gt; through</code></pre>\\n<p>These streams combine just like normal streams.</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull(source, through),\\n  pull(through1, through2),\\n  pull(through, sink)\\n) =&gt; <span class=\\"hljs-literal\\">undefined</span></code></pre>\\n<p>The complete pipeline returns undefined, because it cannot be piped to anything else.</p>\\n<p>Pipe duplex streams like this:</p>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> a = duplex()\\n<span class=\\"hljs-keyword\\">var</span> b = duplex()\\n\\npull(a.source, b.sink)\\npull(b.source, a.sink)\\n\\n<span class=\\"hljs-comment\\">//which is the same as</span>\\n\\nb.sink(a.source); a.sink(b.source)\\n\\n<span class=\\"hljs-comment\\">//but the easiest way is to allow pull to handle this</span>\\n\\npull(a, b, a)\\n\\n<span class=\\"hljs-comment\\">//&quot;pull from a to b and then back to a&quot;</span></code></pre>\\n<h2>API</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> pull = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream/pull&apos;</span>)</code></pre>\\n<h3><code>pull(...streams)</code></h3>\\n<p><code>pull</code> is a function that receives n-arity stream arguments and connects them into a pipeline.</p>\\n<p><code>pull</code> detects the type of stream by checking function arity, if the function takes only one argument it&apos;s either a sink or a through. Otherwise it&apos;s a source. A duplex stream is an object with the shape <code>{ source, sink }</code>.</p>\\n<p>If the pipeline is complete (reduces into a source being passed into a sink), then <code>pull</code> returns <code>undefined</code>, as the data is flowing.</p>\\n<p>If the pipeline is partial (reduces into either a source, a through, or a sink), then <code>pull</code> returns the partial pipeline, as it must be composed with other streams before the data will flow.</p>\\n<h2>Install</h2>\\n<p>With <a href=\\"https://npmjs.org/\\">npm</a> installed, run</p>\\n<pre><code class=\\"hljs language-sh\\">$ npm install pull-stream</code></pre>\\n<h2>See Also</h2>\\n<ul>\\n<li><a href=\\"https://github.com/mafintosh/pump\\"><code>mafintosh/pump</code></a></li>\\n<li><a href=\\"https://github.com/mafintosh/pumpify\\"><code>mafintosh/pumpify</code></a></li>\\n</ul>\\n<h2>License</h2>\\n<p><a href=\\"https://tldrlegal.com/license/mit-license\\">MIT</a></p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"count","path":"pull-stream/pull-stream","subpath":"sources/count","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sources/count.md\\">pull-stream/sources/count</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>count = require(&apos;pull-stream/sources/count&apos;)</code></h3>\\n<h3><code>count(max, onAbort)</code></h3>\\n<p>create a stream that outputs <code>0 ... max</code>.\\nby default, <code>max = Infinity</code>, see\\n<a href=\\"http://github.com/pull-stream/pull-stream/blob/master/docs/sources/count/../../throughs/take.md\\">take</a></p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"empty","path":"pull-stream/pull-stream","subpath":"sources/empty","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sources/empty.md\\">pull-stream/sources/empty</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>empty = require(&apos;pull-stream/sources/empty&apos;)</code></h3>\\n<h3><code>empty()</code></h3>\\n<p>A stream with no contents (it just ends immediately)</p>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  pull.empty(),\\n  pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, ary</span>) </span>{\\n    <span class=\\"hljs-built_in\\">console</span>.log(arg)\\n    <span class=\\"hljs-comment\\">// ==&gt; []</span>\\n  })\\n}</code></pre>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"error","path":"pull-stream/pull-stream","subpath":"sources/error","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sources/error.md\\">pull-stream/sources/error</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>error = require(&apos;pull-stream/sources/error&apos;)</code></h3>\\n<h3><code>error(err)</code></h3>\\n<p>a stream that errors immediately</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"infinite","path":"pull-stream/pull-stream","subpath":"sources/infinite","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sources/infinite.md\\">pull-stream/sources/infinite</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>infinite = require(&apos;pull-stream/sources/infinite&apos;)</code></h3>\\n<h3><code>infinite(generator, onAbort)</code></h3>\\n<p>create an unending stream by repeatedly calling a generator\\nfunction (by default, <code>Math.random</code>)\\nsee <a href=\\"http://github.com/pull-stream/pull-stream/blob/master/docs/sources/infinite/../../throughs/take.md\\">take</a></p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"keys","path":"pull-stream/pull-stream","subpath":"sources/keys","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sources/keys.md\\">pull-stream/sources/keys</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>keys = require(&apos;pull-stream/sources/keys&apos;)</code></h3>\\n<h3><code>keys(array | object, onAbort)</code></h3>\\n<p>stream the key names from an object (or array)</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"once","path":"pull-stream/pull-stream","subpath":"sources/once","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sources/once.md\\">pull-stream/sources/once</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>once = require(&apos;pull-stream/sources/once&apos;)</code></h3>\\n<h3><code>once(value, onAbort)</code></h3>\\n<p>a stream with a single value</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"values","path":"pull-stream/pull-stream","subpath":"sources/values","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sources/values.md\\">pull-stream/sources/values</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>values = require(&apos;pull-stream/sources/values&apos;)</code></h3>\\n<h3><code>values(array | object, onAbort)</code></h3>\\n<p>create a SourceStream that reads the values from an array or object and then stops.</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"async-map","path":"pull-stream/pull-stream","subpath":"throughs/async-map","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/async-map.md\\">pull-stream/throughs/async-map</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>asyncMap = require(&apos;pull-stream/throughs/async-map&apos;)</code></h3>\\n<h3><code>asyncMap(fn)</code></h3>\\n<p>Like <a href=\\"http://github.com/pull-stream/pull-stream/blob/master/docs/throughs/async-map/.././map.md\\"><code>map</code></a> but the signature of <code>fn</code> must be\\n<code>function (data, cb) { cb(null, data) }</code></p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"filter-not","path":"pull-stream/pull-stream","subpath":"throughs/filter-not","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/filter-not.md\\">pull-stream/throughs/filter-not</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>filterNot = require(&apos;pull-stream/throughs/filter-not&apos;)</code></h3>\\n<h3><code>filterNot(test)</code></h3>\\n<p>Like <a href=\\"http://github.com/pull-stream/pull-stream/blob/master/docs/throughs/filter-not/.././filter.md\\"><code>filter</code></a>, but remove items where the filter returns true.</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"filter","path":"pull-stream/pull-stream","subpath":"throughs/filter","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/filter.md\\">pull-stream/throughs/filter</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>filter = require(&apos;pull-stream/throughs/filter&apos;)</code></h3>\\n<h3><code>filter(test)</code></h3>\\n<p>Like <code>[].filter(function (data) {return true || false})</code>\\nonly <code>data</code> where <code>test(data) == true</code> are let through\\nto the next stream.</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"flatten","path":"pull-stream/pull-stream","subpath":"throughs/flatten","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/flatten.md\\">pull-stream/throughs/flatten</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>flatten = require(&apos;pull-stream/throughs/flatten&apos;)</code></h3>\\n<h3><code>flatten(streams)</code></h3>\\n<p>Turn a stream of streams or a stream of arrays into a stream of their items, (undoes group).</p>\\n<h2>example</h2>\\n<pre><code class=\\"hljs language-js\\">test(<span class=\\"hljs-string\\">&apos;flatten arrays&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n  pull(\\n    pull.values([\\n      [<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>],\\n      [<span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-number\\">5</span>, <span class=\\"hljs-number\\">6</span>],\\n      [<span class=\\"hljs-number\\">7</span>, <span class=\\"hljs-number\\">8</span>, <span class=\\"hljs-number\\">9</span>]\\n    ]),\\n    pull.flatten(),\\n    pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, numbers</span>) </span>{\\n      t.deepEqual([<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-number\\">5</span>, <span class=\\"hljs-number\\">6</span>, <span class=\\"hljs-number\\">7</span>, <span class=\\"hljs-number\\">8</span>, <span class=\\"hljs-number\\">9</span>], numbers)\\n      t.end()\\n    })\\n  )\\n})\\n\\ntest(<span class=\\"hljs-string\\">&apos;flatten stream of streams&apos;</span>, <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">t</span>) </span>{\\n\\n  pull(\\n    pull.values([\\n      pull.values([<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>]),\\n      pull.values([<span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-number\\">5</span>, <span class=\\"hljs-number\\">6</span>]),\\n      pull.values([<span class=\\"hljs-number\\">7</span>, <span class=\\"hljs-number\\">8</span>, <span class=\\"hljs-number\\">9</span>])\\n    ]),\\n    pull.flatten(),\\n    pull.collect(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">err, numbers</span>) </span>{\\n      t.deepEqual([<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>, <span class=\\"hljs-number\\">4</span>, <span class=\\"hljs-number\\">5</span>, <span class=\\"hljs-number\\">6</span>, <span class=\\"hljs-number\\">7</span>, <span class=\\"hljs-number\\">8</span>, <span class=\\"hljs-number\\">9</span>], numbers)\\n      t.end()\\n    })\\n  )\\n\\n})</code></pre>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"map","path":"pull-stream/pull-stream","subpath":"throughs/map","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/map.md\\">pull-stream/throughs/map</a><div class=\\"contrib\\"></div></h1>\\n<blockquote>\\n<p>[].map for pull-streams</p>\\n</blockquote>\\n<h2>Background</h2>\\n<p>Pull-streams are arrays of data in time rather than space.</p>\\n<p>As with a <a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\"><code>[].map</code></a>, we may want to map a function over a stream.</p>\\n<h2>Example</h2>\\n<pre><code class=\\"hljs language-js\\"><span class=\\"hljs-keyword\\">var</span> map = <span class=\\"hljs-built_in\\">require</span>(<span class=\\"hljs-string\\">&apos;pull-stream/throughs/map&apos;</span>)</code></pre>\\n<pre><code class=\\"hljs language-js\\">pull(\\n  values([<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">3</span>]),\\n  map(<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">function</span> (<span class=\\"hljs-params\\">x</span>) </span>{\\n    <span class=\\"hljs-keyword\\">return</span> x * x\\n  }),\\n  log()\\n)\\n<span class=\\"hljs-comment\\">// 0</span>\\n<span class=\\"hljs-comment\\">// 1</span>\\n<span class=\\"hljs-comment\\">// 4</span>\\n<span class=\\"hljs-comment\\">// 9</span></code></pre>\\n<h2>Usage</h2>\\n<h3><code>map = require(&apos;pull-stream/throughs/map&apos;)</code></h3>\\n<h3><code>map((data) =&gt; data)</code></h3>\\n<p><code>map(fn)</code> returns a through stream that calls the given <code>fn</code> for each chunk of incoming data and outputs the return value, in the same order as before.</p>\\n<h2>Install</h2>\\n<p>With <a href=\\"https://npmjs.org/\\">npm</a> installed, run</p>\\n<pre><code>$ npm install pull-stream\\n</code></pre>\\n<h2>See Also</h2>\\n<ul>\\n<li><a href=\\"https://github.com/brycebaril/through2-map\\"><code>brycebaril/through2-map</code></a></li>\\n<li><a href=\\"http://xgrommx.github.io/rx-book/content/observable/observable_instance_methods/map.html\\"><code>Rx.Obsevable#map</code></a></li>\\n</ul>\\n<h2>License</h2>\\n<p><a href=\\"https://tldrlegal.com/license/mit-license\\">MIT</a></p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"non-unique","path":"pull-stream/pull-stream","subpath":"throughs/non-unique","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/non-unique.md\\">pull-stream/throughs/non-unique</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>nonUnique = require(&apos;pull-stream/throughs/non-unique&apos;)</code></h3>\\n<h3><code>nonUnique(prop)</code></h3>\\n<p>Filter unique items -- get the duplicates.\\nThe inverse of <a href=\\"http://github.com/pull-stream/pull-stream/blob/master/docs/throughs/non-unique/.././unique.md\\"><code>unique</code></a></p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"take","path":"pull-stream/pull-stream","subpath":"throughs/take","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/take.md\\">pull-stream/throughs/take</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>take = require(&apos;pull-stream/throughs/take&apos;)</code></h3>\\n<h3><code>take(test [, opts])</code></h3>\\n<p>If test is a function, read data from the source stream and forward it downstream until test(data) returns false.</p>\\n<p>If <code>opts.last</code> is set to true, the data for which the test failed will be included in what is forwarded.</p>\\n<p>If test is an integer, take n item from the source.</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"through","path":"pull-stream/pull-stream","subpath":"throughs/through","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/through.md\\">pull-stream/throughs/filter</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>filter = require(&apos;pull-stream/throughs/filter&apos;)</code></h3>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"unique","path":"pull-stream/pull-stream","subpath":"throughs/unique","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/throughs/unique.md\\">pull-stream/throughs/unique</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>unique = require(&apos;pull-stream/throughs/unique&apos;)</code></h3>\\n<h3><code>unique(prop)</code></h3>\\n<p>Filter items that have a repeated value for <code>prop()</code>,\\nby default, <code>prop = function (it) {return it }</code>, if prop is a string,\\nit will filter nodes which have repeated values for that property.</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"collect","path":"pull-stream/pull-stream","subpath":"sinks/collect","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sinks/collect.md\\">pull-stream/sinks/collect</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>collect = require(&apos;pull-stream/sinks/collect&apos;)</code></h3>\\n<h3><code>collect(cb)</code></h3>\\n<p>Read the stream into an array, then callback.</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"concat","path":"pull-stream/pull-stream","subpath":"sinks/concat","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sinks/concat.md\\">pull-stream/sinks/concat</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>concat = require(&apos;pull-stream/sinks/concat&apos;)</code></h3>\\n<h3><code>concat(cb)</code></h3>\\n<p>concat stream of strings into single string, then callback.</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"drain","path":"pull-stream/pull-stream","subpath":"sinks/drain","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sinks/drain.md\\">pull-stream/sinks/drain</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>drain = require(&apos;pull-stream/sinks/drain&apos;)</code></h3>\\n<h3><code>drain(op?, done?)</code></h3>\\n<p>Drain the stream, calling <code>op</code> on each <code>data</code>.\\ncall <code>done</code> when stream is finished.\\nIf op returns <code>===false</code>, abort the stream.</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"find","path":"pull-stream/pull-stream","subpath":"sinks/find","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sinks/find.md\\">pull-stream/sinks/find</a><div class=\\"contrib\\"></div></h1>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"log","path":"pull-stream/pull-stream","subpath":"sinks/log","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sinks/log.md\\">pull-stream/sinks/log</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>log = require(&apos;pull-stream/sinks/log&apos;)</code></h3>\\n<h3><code>log()</code></h3>\\n<p>output the stream to <code>console.log</code></p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"on-end","path":"pull-stream/pull-stream","subpath":"sinks/on-end","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sinks/on-end.md\\">pull-stream/sinks/on-end</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>onEnd = require(&apos;pull-stream/sinks/on-end&apos;)</code></h3>\\n<h3><code>onEnd(cb)</code></h3>\\n<p>Drain the stream and then callback when done.</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"},{"user":"pull-stream","name":"reduce","path":"pull-stream/pull-stream","subpath":"sinks/reduce","readme":"<h1 class=\\"title\\"><a target=\\"_blank\\" href=\\"https://github.com/pull-stream/pull-stream/blob/master/docs/sinks/reduce.md\\">pull-stream/sinks/reduce</a><div class=\\"contrib\\"></div></h1>\\n<h2>usage</h2>\\n<h3><code>reduce = require(&apos;pull-stream/sinks/reduce&apos;)</code></h3>\\n<h3><code>reduce (reduce, initial, cb)</code></h3>\\n<p>reduce stream into single value, then callback.</p>\\n","contributors":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],"version":false,"npmName":false,"category":"core"}]}'),router=require("./router"),nav=require("./views/nav"),modulePage=require("./views/module-page"),prefix=(null||!0)&&"_b03c5c45",app={
init:function(){var s=router.init();return{model:Object.assign(model,{modules:model.modules.map(function(s){return Object.assign(s,{contributors:deIndexContributors(model.contributors,s.contributors)})}),route:s.model}),effect:s.effect}},update:function(s,a){return"router"===a.type.split(":")[0]?{model:Object.assign({},s,{route:router.update(s,a).model})}:{model:s}},view:function(s){var a=s.route||"pull-stream",e=find(s.modules,function(s){return s.name===a});return inu.html(_templateObject,prefix,nav(s),modulePage(e))},run:router.run},main=document.querySelector("main");pull(inu.start(app).views(),pull.drain(function(s){inu.html.update(main,s)}));
},{"./router":53,"./views/module-page":55,"./views/nav":56,"array-find":1,"insert-css":11,"inu":13}]},{},[57]);
